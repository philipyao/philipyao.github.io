<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="PHILIP x BLOG">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="PHILIP x BLOG">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHILIP x BLOG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>PHILIP x BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PHILIP x BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心有猛虎，细嗅蔷薇</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/服务器性能优化备忘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/服务器性能优化备忘/" itemprop="url">服务器性能优化备忘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T15:33:15+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/29/服务器性能优化备忘/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/29/服务器性能优化备忘/" class="cy_cmt_count" data-xid="2018/09/29/服务器性能优化备忘/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近对服务器进行了一次性能优化，这里记录一下要点以供备忘。</p>
<h2 id="Go-Profile"><a href="#Go-Profile" class="headerlink" title="Go Profile"></a>Go Profile</h2><p>golang 官方提供了一个称为 pprof 的性能调优工具。我们可以利用该工具来进行诊断。pprof 的原理是每秒钟暂停100次，然后对当前正在运行的 goroutine 堆栈进行采样并记录次数。</p>
<h5 id="pprof-开启"><a href="#pprof-开启" class="headerlink" title="pprof 开启"></a>pprof 开启</h5><p>对于服务器，一般通过 http 方式来启用 pprof，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(http.ListenAndServe(<span class="string">"0.0.0.0:6060"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h5 id="pprof-诊断热点函数"><a href="#pprof-诊断热点函数" class="headerlink" title="pprof 诊断热点函数"></a>pprof 诊断热点函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof bin/sessionsvr http://your-ip:port/debug/pprof/profile?seconds=30</span><br></pre></td></tr></table></figure>
<p>30秒后，数据采集完成，top20 可以列出 CPU 占用最高的20项，结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top20</span><br><span class="line">6300ms of 8360ms total (75.36%)</span><br><span class="line">Dropped 236 nodes (cum &lt;= 41.80ms)</span><br><span class="line">Showing top 20 nodes out of 137 (cum &gt;= 430ms)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1200ms 14.35% 14.35%     3070ms 36.72%  runtime.mapassign1</span><br><span class="line">    1000ms 11.96% 26.32%     1010ms 12.08%  runtime.mapiternext</span><br><span class="line">     750ms  8.97% 35.29%      750ms  8.97%  runtime.aeshashbody</span><br><span class="line">     430ms  5.14% 40.43%      690ms  8.25%  runtime.scanobject</span><br><span class="line">     320ms  3.83% 44.26%     4980ms 59.57%  hgame/sessionsvr/logic/territory.(*territoryMap).moveSight</span><br><span class="line">     280ms  3.35% 47.61%      430ms  5.14%  runtime.evacuate</span><br><span class="line">     260ms  3.11% 50.72%      260ms  3.11%  runtime.usleep</span><br><span class="line">     250ms  2.99% 53.71%      310ms  3.71%  syscall.Syscall</span><br><span class="line">     240ms  2.87% 56.58%      240ms  2.87%  runtime.memmove</span><br><span class="line">     210ms  2.51% 59.09%      210ms  2.51%  runtime.futex</span><br><span class="line">     190ms  2.27% 61.36%      190ms  2.27%  runtime.memclr</span><br><span class="line">     180ms  2.15% 63.52%      290ms  3.47%  runtime.mapiterinit</span><br><span class="line">     180ms  2.15% 65.67%      380ms  4.55%  runtime.typedmemmove</span><br><span class="line">     160ms  1.91% 67.58%      160ms  1.91%  sync/atomic.AddUint32</span><br><span class="line">     140ms  1.67% 69.26%      140ms  1.67%  runtime.heapBitsForObject</span><br><span class="line">     140ms  1.67% 70.93%      200ms  2.39%  runtime.strequal</span><br><span class="line">     110ms  1.32% 72.25%      450ms  5.38%  runtime.mallocgc</span><br><span class="line">     110ms  1.32% 73.56%      180ms  2.15%  runtime.mapaccess2_faststr</span><br><span class="line">      90ms  1.08% 74.64%       90ms  1.08%  runtime.heapBitsSetType</span><br><span class="line">      60ms  0.72% 75.36%      430ms  5.14%  github.com/ugorji/go/codec.encFnInfo.kStruct</span><br></pre></td></tr></table></figure>
<p>其中前两列 flat 表示该函数调用的时间和百分比，后两列 cum 表示该函数处于堆栈中的时间和百分比，包含正在被调用或者等待其他子函数返回的情况。 sum 表示前面 N 行到当前行函数累计的时间百分比。</p>
<p>从上面的结果可以知道 cum% 为 59.57% 的 moveSight 函数长时间处于栈列表中，是正在运行或者等待该函数里面其他函数调用返回。而其很可能主要等待前面几个 map 的操作完成。</p>
<p>运行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top mapassign1</span><br><span class="line">2590ms of 7720ms total (33.55%)</span><br><span class="line">Dropped 9 nodes (cum &lt;= 38.60ms)</span><br><span class="line">Showing top 10 nodes out of 42 (cum &gt;= 30ms)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1020ms 13.21% 13.21%     2710ms 35.10%  runtime.mapassign1</span><br><span class="line">     550ms  7.12% 20.34%      550ms  7.12%  runtime.aeshashbody</span><br><span class="line">     240ms  3.11% 23.45%      240ms  3.11%  runtime.memmove</span><br><span class="line">     240ms  3.11% 26.55%      540ms  6.99%  runtime.typedmemmove</span><br><span class="line">     210ms  2.72% 29.27%      240ms  3.11%  runtime.strequal</span><br><span class="line">     130ms  1.68% 30.96%      370ms  4.79%  runtime.evacuate</span><br><span class="line">     100ms  1.30% 32.25%      100ms  1.30%  runtime.memclr</span><br><span class="line">      40ms  0.52% 32.77%       60ms  0.78%  runtime.heapBitsBulkBarrier</span><br><span class="line">      30ms  0.39% 33.16%       30ms  0.39%  runtime.aeshash32</span><br><span class="line">      30ms  0.39% 33.55%       30ms  0.39%  runtime.aeshashstr</span><br><span class="line">      </span><br><span class="line">(pprof) svg mapassign1</span><br><span class="line">Generating report in cpu.svg</span><br></pre></td></tr></table></figure>
<p>用浏览器打开 生成的结果 <code>cpu.svg</code> 可以看到</p>
<p><img src="/images/image-20180930144018771.png" alt="image-20180930144018771"></p>
<p>从图中可以证实，确实是 moveSight 导致的 map 操作占用 CPU 时间较多。</p>
<p>利用 list 命令查看具体是那一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list moveSight</span><br></pre></td></tr></table></figure>
<p>找到具体数据结构后，就可以有针对性的修改。一般来说 map 的优化主要是 key 要使用比较简单的类型，这样计算 hash 的时候也比较快。通常来说 int 类型 key 比 string 类型的 key 要快。此外由于 map 的内存增长是指数级的，新插入的时候如果发现空间不足，需要重新分配空间 hashGrow 和进行内存 typedmemmove，很耗性能，所以如果能预估 map 的大小，最好一开始就分配足够大的空间，以空间换时间。</p>
<h2 id="机器人策略"><a href="#机器人策略" class="headerlink" title="机器人策略"></a>机器人策略</h2><h2 id="Lua-Profile"><a href="#Lua-Profile" class="headerlink" title="Lua Profile"></a>Lua Profile</h2><ul>
<li>数据库数据的分批拉取、存储。Mysql 一次 update 多条记录会比多次 update 快。(有网络开销，获取锁开销等)</li>
<li>配置数据的加载，预处理。</li>
<li>map 或者 slice 预分配空间大小，减少频繁扩容及数据拷贝代价。</li>
<li>注意共享资源锁的粒度。</li>
<li>数据更新量。大且频繁的数据使用版本号做增量通知。</li>
<li>算法优化：KDtree 查找距离最近，KNN 算法；模糊查找算法。</li>
<li>广播裁剪</li>
<li>包大小优化，序列化方法，压缩</li>
<li>登录模块，预分配 user 池</li>
<li>增加 metrics 统计项，及早发现问题</li>
<li>snap 快照对比，找出 lua 内存泄露</li>
<li>lua 有性能问题的地方改用 c 或者 go 实现（加解密、time、socket、json 等序列化、随机数发生器、位操作）</li>
<li>gettimeofday</li>
<li>避免密集操作，如避免定点发放物品，分批发放</li>
<li>利用 goroutine 多核并行执行</li>
<li>空间换时间</li>
<li>消峰：均摊思想。例如哈希表的扩容时候，不是一次做完数据迁移。</li>
<li>用 SSD 硬盘。</li>
<li>数据库分表分库，读写分离</li>
</ul>
<h5 id="算法调优"><a href="#算法调优" class="headerlink" title="算法调优"></a>算法调优</h5><h5 id="代码调优"><a href="#代码调优" class="headerlink" title="代码调优"></a>代码调优</h5><ul>
<li>尽量用整形取代字符串（例如用整形 flags 来表示多个状态，利用位操作来查询设置状态；数据库用整形做 key）</li>
<li>单线程中，不要用带锁相关的数据结构，很多 stl 的线程安全的容器或者智能指针 AutoPtr 都是加锁的，很耗性能；多线程环境下，尽量用无锁编程，乐观锁，读写锁等来替代互斥锁、悲观锁；最后，尽量用单线程</li>
<li>池化技术：内存池、对象池、连接池、线程池</li>
<li>缓存技术：LRU 缓存</li>
<li>将同步操作转换为异步操作，提高 throughout</li>
</ul>
<h5 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h5><ul>
<li>及时关闭空闲连接，避免资源耗尽。客户端服务器心跳 keepalive 机制。</li>
<li>TIMEWAIT 状态的处理。</li>
<li>TCP buff 的选择。理论上的RWIN应该设置成：吞吐量  * 回路时间。Sender端的buffer应该和RWIN有一样的大小，因为Sender端发送完数据后要等Receiver端确认，如果网络延时很大，buffer过小了，确认的次数就会多，于是性能就不高，对网络的利用率也就不高了。也就是说，对于延迟大的网络，我们需要大的buffer，这样可以少一点ack，多一些数据，对于响应快一点的网络，可以少一些buffer。因为，如果有丢包（没有收到ack），buffer过大可能会有问题，因为这会让TCP重传所有的数据，反而影响网络性能。</li>
<li>对于一个UDP的包，我们要尽量地让他大到MTU的最大尺寸再往网络上传，这样可以最大化带宽利用率。对于这个MTU，以太网是1500字节，光纤是4352字节，802.11无线网是7981。</li>
<li>Epoll 的使用。</li>
<li>DNS lookup。gethostbyaddr/gethostbyname 这个函数可能会相当的费时，因为其要到网络上去找域名，因为DNS的递归查询，会导致严重超时，而又不能通过设置什么参数来设置time out，对此你可以通过配置hosts文件来加快速度，或是自己在内存中管理对应表，在程序启动时查好，而不要在运行时每次都查。</li>
</ul>
<h5 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h5><ul>
<li>选对引擎</li>
<li>索引</li>
<li>数据类型选择</li>
<li>分表分库</li>
<li>读写分离</li>
</ul>
<ul>
<li><p>实现层优化：vtune 等工具查找热点，针对性优化。</p>
</li>
<li><p>实现层优化：空间换时间，为高频不善变计算建立缓存。</p>
</li>
<li>业务层优化：柔性可用，设立资源消耗配额(定时重置)，每次请求消费一个配额，控制总体。</li>
<li>业务层优化：有损服务，对业务需求进行必要裁剪。</li>
</ul>
<p>参考资料</p>
<p><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go Programs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/MySQL-Cheat-Sheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/MySQL-Cheat-Sheet/" itemprop="url">MySQL Cheat Sheet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T09:33:08+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/13/MySQL-Cheat-Sheet/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/13/MySQL-Cheat-Sheet/" class="cy_cmt_count" data-xid="2018/09/13/MySQL-Cheat-Sheet/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h5 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h5><p>关于 mysql 的版本选择，可以参考 <a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">如何选择 MySQL 版本</a> 这篇文章。我们选择社区版的 5.6 版本。</p>
<h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><p>为了方便用户安装，MySQl 官方提供了单独的 repository，对于Linux 发行版，有专门的 yum 源和 apt 源。将源添加好后，就可以很方便的通过 linux 的 yum 或者 apt 工具进行安装。这里我们以 yum 为例来讲述 MySQL 社区版本的安装过程。</p>
<ul>
<li>首先下载  MySQL yum 源，页面位于 <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">Download MySQL Yum Repository</a> </li>
</ul>
<blockquote>
<p>注意下载的文件名虽然统一叫做 <code>mysql80-community-release-&lt;platform-and-version&gt;.noarch.rpm</code>，但是里面包含了 8.0，5.7，5.6，5.5 等各个版本以及工具。</p>
</blockquote>
<ul>
<li><p>本地安装下载的源，我们以 centos7为例，下载的文件为 <code>mysql80-community-release-el7-1.noarch.rpm</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">$ rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看启用的版本，默认是启用 8.0 版本</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum repolist enabled | grep mysql</span><br><span class="line">mysql-connectors-community/x86_64 MySQL Connectors Community                  65</span><br><span class="line">mysql-tools-community/x86_64      MySQL Tools Community                       69</span><br><span class="line">mysql80-community/x86_64          MySQL 8.0 Community Server                 412</span><br></pre></td></tr></table></figure>
<ul>
<li>修改启用版本为 5.6</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">disable</span> mysql80-community</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> mysql56-community</span><br></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install mysql-community-server</span><br><span class="line">$ mysql --version</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果安装时下载有问题，可以考虑修改 /etc/yum.conf 里的 proxy 代理配置为你的 http 代理地址 <a href="http://your_proxy_ip:port" target="_blank" rel="noopener">http://your_proxy_ip:port</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>默认安装路径是 <code>/var/lib/mysql</code>, 可以自定义数据文件路径。一般来说云主机的 data 盘较大，可以将数据库的数据存放于此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">socket=/data/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">socket=/data/mysql/mysql.sock   # 供 mysql client 连接用</span><br></pre></td></tr></table></figure>
<p>这里自定义的<code>/data/mysql</code> 路径需要设置为 mysql 用户拥有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mysql:mysql /data/mysql</span><br></pre></td></tr></table></figure>
<p>开启慢查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=1 # 1s</span><br><span class="line">slow_query_log_file=/data/mysql/mysqld-slow.log</span><br></pre></td></tr></table></figure>
<p>开启 binlog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>设置字符集(character)及校对规则(collation，字符串比较规则)，字符集默认是 latin1，我们设置为 utf8</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>配置完成后，启动 mysqld 服务器进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysqld start</span><br></pre></td></tr></table></figure>
<h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><p>运行 <code>mysql_secure_installation</code> 命令，来对新安装的 mysql 进行安全性设置，这包括 root 密码设置、限制 root 只能本机登录、删除 test 库、删除匿名用户等。对于生产环境，强烈建议设置一下。</p>
<blockquote>
<p>注意 5.7 及以上版本已经不需要运行该命令</p>
</blockquote>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>使用 sysbench 工具来对 MySQL 进行测试(这里我们只测试 select primary key)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua <span class="built_in">help</span></span><br><span class="line">sysbench 1.0.9 (using system LuaJIT 2.0.4)</span><br><span class="line"></span><br><span class="line">oltp_read_only.lua options:</span><br><span class="line">  --distinct_ranges=N           Number of SELECT DISTINCT queries per transaction [1]</span><br><span class="line">  --sum_ranges=N                Number of SELECT SUM() queries per transaction [1]</span><br><span class="line">  --skip_trx[=on|off]           Don<span class="string">'t start explicit transactions and execute all queries in the AUTOCOMMIT mode [off]</span></span><br><span class="line"><span class="string">  --secondary[=on|off]          Use a secondary index in place of the PRIMARY KEY [off]</span></span><br><span class="line"><span class="string">  --create_secondary[=on|off]   Create a secondary index in addition to the PRIMARY KEY [on]</span></span><br><span class="line"><span class="string">  --index_updates=N             Number of UPDATE index queries per transaction [1]</span></span><br><span class="line"><span class="string">  --range_size=N                Range size for range SELECT queries [100]</span></span><br><span class="line"><span class="string">  --auto_inc[=on|off]           Use AUTO_INCREMENT column as Primary Key (for MySQL), or its alternatives in other DBMS. When disabled, use client-generated IDs [on]</span></span><br><span class="line"><span class="string">  --delete_inserts=N            Number of DELETE/INSERT combination per transaction [1]</span></span><br><span class="line"><span class="string">  --tables=N                    Number of tables [1]</span></span><br><span class="line"><span class="string">  --mysql_storage_engine=STRING Storage engine, if MySQL is used [innodb]</span></span><br><span class="line"><span class="string">  --non_index_updates=N         Number of UPDATE non-index queries per transaction [1]</span></span><br><span class="line"><span class="string">  --table_size=N                Number of rows per table [10000]</span></span><br><span class="line"><span class="string">  --pgsql_variant=STRING        Use this PostgreSQL variant when running with the PostgreSQL driver. The only currently supported variant is '</span>redshift<span class="string">'. When enabled, create_secondary is automatically disabled, and delete_inserts is set to 0</span></span><br><span class="line"><span class="string">  --simple_ranges=N             Number of simple range SELECT queries per transaction [1]</span></span><br><span class="line"><span class="string">  --order_ranges=N              Number of SELECT ORDER BY queries per transaction [1]</span></span><br><span class="line"><span class="string">  --range_selects[=on|off]      Enable/disable all range SELECT queries [on]</span></span><br><span class="line"><span class="string">  --point_selects=N             Number of point SELECT queries per transaction [10]</span></span><br></pre></td></tr></table></figure>
<p>准备数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua --threads=4  --mysql-user=root --mysql-password=xxxxx --mysql-db=db_test --db-driver=mysql --tables=10 --table_size=1000000 prepare</span><br><span class="line"></span><br><span class="line">sysbench 1.0.9 (using system LuaJIT 2.0.4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creating table <span class="string">'sbtest3'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest4'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest1'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest2'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest3'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest2'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest4'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest1'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest4'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest2'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest1'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest3'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest8'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest8'</span></span><br><span class="line">Creating table <span class="string">'sbtest6'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest6'</span></span><br><span class="line">Creating table <span class="string">'sbtest5'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest5'</span></span><br><span class="line">Creating table <span class="string">'sbtest7'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest7'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest8'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest6'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest5'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest7'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest10'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest10'</span></span><br><span class="line">Creating table <span class="string">'sbtest9'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest9'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest10'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest9'</span>...</span><br></pre></td></tr></table></figure>
<p>数据准备好之后，开始运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua --threads=16 --events=0 --time=300 --mysql-db=db_test --mysql-user=root --mysql-password=xxxxx --db-driver=mysql --table_size=1000000 --range_selects=off --db-ps-mode=<span class="built_in">disable</span> --report-interval=1 --histogram run</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[ 298s ] thds: 16 tps: 4907.59 qps: 58910.03 (r/w/o: 49095.86/0.00/9814.17) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line">[ 299s ] thds: 16 tps: 4915.22 qps: 58992.64 (r/w/o: 49161.20/0.00/9831.44) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line">[ 300s ] thds: 16 tps: 4909.87 qps: 58891.44 (r/w/o: 49070.70/0.00/9820.74) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line"></span><br><span class="line">SQL statistics:</span><br><span class="line">    queries performed:</span><br><span class="line">        <span class="built_in">read</span>:                            14678040</span><br><span class="line">        write:                           0</span><br><span class="line">        other:                           2935608</span><br><span class="line">        total:                           17613648</span><br><span class="line">    transactions:                        1467804 (4892.54 per sec.)</span><br><span class="line">    queries:                             17613648 (58710.46 per sec.)</span><br><span class="line">    ignored errors:                      0      (0.00 per sec.)</span><br><span class="line">    reconnects:                          0      (0.00 per sec.)</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          300.0070s</span><br><span class="line">    total number of events:              1467804</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                  0.80</span><br><span class="line">         avg:                                  3.27</span><br><span class="line">         max:                                114.77</span><br><span class="line">         95th percentile:                      3.96</span><br><span class="line">         sum:                            4797566.33</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           91737.7500/481.98</span><br><span class="line">    execution time (avg/stddev):   299.8479/0.00</span><br></pre></td></tr></table></figure>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>通过 <code>mysql_secure_installation</code> 脚本设置好 root 密码后，就可以登录了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h [host] -u [user] -p</span><br><span class="line">Enter password: ********</span><br></pre></td></tr></table></figure>
<p>登录并使用某一数据库(例子中密码前面不能有空格)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h [host] -u [user] -p[passwd] [DB_NAME]</span><br></pre></td></tr></table></figure>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>创建用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &apos;user&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP USER &apos;user&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>
<p>赋权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT SELECT, INSERT, DELETE ON base.* TO &apos;user&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;</span><br><span class="line">mysql&gt; GRANT SELECT ON `db\_oss\_%`.* TO &apos;query&apos;@&apos;172.31.%&apos; IDENTIFIED BY &apos;123&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>更新密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;user&apos;@&apos;host&apos; = PASSWORD(&apos;new_pass&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看当前正在 use 的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| mysql      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看建表语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t_xxx;</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from table t_xxx;</span><br></pre></td></tr></table></figure>
<p>查看字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;character_set_%&apos;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;collation%&apos;;</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| Variable_name        | Value           |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| collation_connection | utf8_general_ci |</span><br><span class="line">| collation_database   | utf8_general_ci |</span><br><span class="line">| collation_server     | utf8_general_ci |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure>
<p>设置连接编码为 utf8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET NAMES &apos;utf8&apos;;</span><br></pre></td></tr></table></figure>
<p>修改表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE [table] ADD COLUMN [column] VARCHAR(120);</span><br><span class="line">mysql&gt; ALTER TABLE [table] DROP COLUMN [column];</span><br></pre></td></tr></table></figure>
<p>插入一条记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO [table] ([column], [column]) VALUES (&apos;[value]&apos;, &apos;[value]&apos;);</span><br></pre></td></tr></table></figure>
<p>解释执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM [table] WHERE [column] LIKE &apos;%[value]%&apos;;</span><br></pre></td></tr></table></figure>
<p>更新数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE [table] SET [column] = &apos;[updated-value]&apos; WHERE [column] = [value];</span><br></pre></td></tr></table></figure>
<p>为一列或者多列添加命名索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE table ADD INDEX [index_name](column, ...);</span><br><span class="line">mysql&gt; CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table (column,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p>使用 group by 和 having 来获取特定组数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table GROUP BY column_1 HAVING condition;</span><br></pre></td></tr></table></figure>
<p>设置所有 row 的某一列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE table SET column_1 = value_1, ...;</span><br></pre></td></tr></table></figure>
<h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><h5 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h5><p>物理备份是拷贝数据库的文件，比较快，适用于数据迁移等场景。</p>
<h5 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h5><p>逻辑备份可以无视版本和架构对数据进行备份，比如进行 mysql 升级就可以使用逻辑备份来备份数据。逻辑备份通常结合全量备份和增量备份。</p>
<p>在 mysql 服务器本地，使用 mysqldump 进行全量备份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump --single-transaction --all-databases --flush-logs -u [username] -p &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>如果要备份特定的库和表，可以这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump --single-transaction --flush-logs -u [username] -p [db_name] &lt;table_name&gt; &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>如果不需要导出建库，使用–no-create–db选项，不需要建表语句，使用 –no-create-info 选项；导出特定条件的行，使用 –where 选项。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -h 10.137.213.82 -udbuser -ppassword --no-create-info db_hgame_1020 t_user --<span class="built_in">where</span>=<span class="string">"accid=776085"</span> &gt; /tmp/776085.sql</span><br></pre></td></tr></table></figure>
<p>导入备份的 sql 语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>
<p>或者使用 mysql 的 source 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source backup.sql;</span><br></pre></td></tr></table></figure>
<p>如果备份的数据比较大，可以压缩一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -u [username] -p --default-character-set=utf8 [db_name] | gzip &gt; backup.sql.gz</span><br><span class="line">$ gunzip -c backup.sql.gz | mysql -u [username] -p [db_name] 1&gt; load.log 2&gt;err.log</span><br></pre></td></tr></table></figure>
<p>如果想将一台服务器的数据直接导入另外一台机器，可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -u root -p database_name | mysql -h other-host database_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mysqldump 需要 SELECT 权限，对于没有指定 –single-transaction 选项的还需要 LOCK TABLES 权限。</p>
</blockquote>
<p>对于增量备份，可以使用 binlog。</p>
<p>查看所有的 binlog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       120 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看当前正在写的 binlog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      120 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>导出特定时间的 binlog 以便根据 pos 来进行具体恢复(binlog 是二进制格式，利用 mysqlbinlog 工具导出成 sql)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog --start-datetime=<span class="string">"2018-05-20 9:58:00"</span> --stop-datetime=<span class="string">"2018-05-20 10:01:00"</span> /data/mysql/mysql-bin.000001 &gt; /tmp/mysql_restore.sql</span><br></pre></td></tr></table></figure>
<p>通过 mysql_restore.sql 我们发现只需要恢复到 log_pos 为368312 的位置，则执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog --stop-position=368312 /data/mysql/mysql-bin.000001 | mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>先查询安装了哪些 mysql 的文件，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | grep mysql</span><br><span class="line">mysql-community-libs-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-devel-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-client-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-server-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-common-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-libs-compat-5.7.21-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>yum remove</code> 命令卸载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove mysql</span><br><span class="line">$ sudo yum remove mysql-community-common</span><br><span class="line">$ sudo yum -y remove mysql-libs</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果已知旧密码，需要修改 root 密码为新密码，可以这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysqladmin</span><br><span class="line">/usr/bin/mysqladmin</span><br><span class="line">$ /usr/bin/mysqladmin -u root -p password <span class="string">'new-password'</span></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>
<p>如果忘记密码，在 my.cnf [mysqld] 部分最后添加  skip-grant-tables 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>
<p>重启 mysqld</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysqld restart</span><br></pre></td></tr></table></figure>
<p>使用 root 无需密码登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot</span><br></pre></td></tr></table></figure>
<p>更新密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET password=password(&apos;new-password&apos;) WHERE user = &apos;root&apos; ;</span><br><span class="line">mysql&gt; flush privileges ;</span><br></pre></td></tr></table></figure>
<p>退出，删除 skip-grant-tables 选项并重启 mysqld 即可</p>
<p>参考资料</p>
<p><a href="http://www.ywnds.com/?p=9806" target="_blank" rel="noopener">如何选择 MySQL 版本</a></p>
<p><a href="https://severalnines.com/blog/how-benchmark-performance-mysql-mariadb-using-sysbench" target="_blank" rel="noopener">How to Benchmark Performance of MySQL &amp; MariaDB using SysBench</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/深入浅出MySQL-笔记之优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/深入浅出MySQL-笔记之优化/" itemprop="url"><深入浅出MySQL>笔记之优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T19:01:18+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/03/深入浅出MySQL-笔记之优化/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/03/深入浅出MySQL-笔记之优化/" class="cy_cmt_count" data-xid="2018/09/03/深入浅出MySQL-笔记之优化/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要是 &lt;深入浅出 MySQL&gt; 一书中对于 MySQL 优化相关内容的读书笔记，另外参考了一些其他资料得出的总结性内容。</p>
<h2 id="引擎选择"><a href="#引擎选择" class="headerlink" title="引擎选择"></a>引擎选择</h2><p>查看本 MySQL server 支持的引擎</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show engines\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">      Engine: InnoDB</span><br><span class="line">     Support: DEFAULT</span><br><span class="line">     Comment: Supports transactions, row-level locking, and foreign keys</span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: YES</span><br><span class="line">  Savepoints: YES</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">      Engine: MRG_MYISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Collection of identical MyISAM tables</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">      Engine: MEMORY</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">      Engine: BLACKHOLE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: /dev/null storage engine (anything you write to it disappears)</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">      Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: MyISAM storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">      Engine: CSV</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: CSV storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">      Engine: ARCHIVE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Archive storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">      Engine: PERFORMANCE_SCHEMA</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Performance Schema</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">      Engine: FEDERATED</span><br><span class="line">     Support: NO</span><br><span class="line">     Comment: Federated MySQL storage engine</span><br><span class="line">Transactions: NULL</span><br><span class="line">          XA: NULL</span><br><span class="line">  Savepoints: NULL</span><br><span class="line">9 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>MyISAM 引擎适合多读的情况，对于有很多写的情况，其性能很差，因为其只支持表锁。</p>
<p>InnoDB 引擎支持行锁和表锁，且默认情况下是行锁。且支持事务。对于有不少写的情况，优先选择 InnoDB 引擎。</p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>要查找自己业务数据库的问题，可以依次采取下面措施来定位</p>
<h5 id="SQL-语句频率统计"><a href="#SQL-语句频率统计" class="headerlink" title="SQL 语句频率统计"></a>SQL 语句频率统计</h5><p>打印数据库启动后运行一段时间后，各项数据统计：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status;</span><br><span class="line">+--------------------------------+------------+</span><br><span class="line">| Variable_name                  | Value      |</span><br><span class="line">+--------------------------------+------------+</span><br><span class="line">| Aborted_clients                | 631        |</span><br><span class="line">| Aborted_connects               | 7          |</span><br><span class="line">| Binlog_cache_disk_use          | 0          |</span><br><span class="line">| Binlog_cache_use               | 0          |</span><br><span class="line">| Bytes_received                 | 3967622624 |</span><br><span class="line">| Bytes_sent                     | 8593148107 |</span><br><span class="line">| Com_admin_commands             | 1          |</span><br><span class="line">| Com_assign_to_keycache         | 0          |</span><br><span class="line">| Com_alter_db                   | 0          |</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>其中，Com_xxx 表示 xxx 语句的执行次数，通过这类选项我们可以统计数据库的增删改查次数。</p>
<p>例如，生产环境的次数统计数据如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Com_update                     | 616602     |</span><br><span class="line">| Com_delete                     | 87616      |</span><br><span class="line">| Com_select                     | 111538287  |</span><br><span class="line">| Com_insert                     | 283173     |</span><br></pre></td></tr></table></figure>
<p>查询数量远远大于更新数量。</p>
<h5 id="查找慢查询语句"><a href="#查找慢查询语句" class="headerlink" title="查找慢查询语句"></a>查找慢查询语句</h5><p>通过以下配置项开启慢查询日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=1 # 1s</span><br><span class="line">slow_query_log_file=/data/mysql/mysqld-slow.log</span><br></pre></td></tr></table></figure>
<p>开启后测试一下是否起效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SLEEP(2);</span><br></pre></td></tr></table></figure>
<p>此时到 mysql 数据目录，我这里是 /data/mysql，查看 mysqld-slow.log</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat mysqld-slow.log </span><br><span class="line">/usr/libexec/mysqld, Version: 5.1.73-log (Source distribution). started with:</span><br><span class="line">Tcp port: 0  Unix socket: /data/mysql/mysql.sock</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line"><span class="comment"># Time: 180913 10:28:34</span></span><br><span class="line"><span class="comment"># Query_time: 2.000476  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0</span></span><br><span class="line">SET timestamp=1536805714;</span><br><span class="line">SELECT SLEEP(2);</span><br></pre></td></tr></table></figure>
<p>可见，慢查询的 SQL 语句以及执行情况已经被记录下来。可以利用 explain 来具体分析慢查询语句的问题所在。</p>
<h5 id="Explain慢查询"><a href="#Explain慢查询" class="headerlink" title="Explain慢查询"></a>Explain慢查询</h5><p>下面是一个典型的慢查询的语句 Expain 分析结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row *************************** </span><br><span class="line">id: 1</span><br><span class="line">select_type: SIMPLE </span><br><span class="line">table: a</span><br><span class="line">type: ALL </span><br><span class="line">possible_keys: NULL </span><br><span class="line">key: NULL </span><br><span class="line">key_len: NULL </span><br><span class="line">ref: NULL </span><br><span class="line">rows: 1000</span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure>
<p>type 表示表的连接类型，常见的有 ALL表示全表扫描、Ref 表示索引查找</p>
<p>key 表示使用的索引</p>
<p>rows 表示扫码的行数</p>
<p>上面的结果表明 mysql 使用的全表扫描，性能很差，我们可以为 where 字段建个索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index ind_sale_year on t_sale(year);</span><br></pre></td></tr></table></figure>
<p>再次分析结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row *************************** </span><br><span class="line">id: 1</span><br><span class="line">select_type: SIMPLE </span><br><span class="line">table: a</span><br><span class="line">type: ref </span><br><span class="line">possible_keys: ind_sale_year</span><br><span class="line">key: ind_sale_year</span><br><span class="line">key_len: 2</span><br><span class="line">ref: const</span><br><span class="line">rows: 1</span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure>
<p>效果很明显，只需要扫描1行了。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>大部分 MySQL 的索引(<code>PRIMARY KEY</code>, <code>UNIQUE</code>, <code>INDEX</code>, and <code>FULLTEXT</code>) 是以 BTREE 方式存储的。</p>
<p>索引具有前缀特性，特别是针对多列索引的情况，从左到右部分连续涉及到的字段 where 查询都会用到索引。例如我们有个三列索引建在 (col1, col2, col3) 上，那么where 条件是 (col1) 或者 (col1, col2) 或者 (col1, col2, col3) 都会用到该索引，其他情况如 (col2)、(col1, col3) 等均不会用到索引。</p>
<p>对于 where 条件中有 like 的语句，只有 % 不是第一个字符的才会用到索引。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from company2 where name like &apos;%3&apos;\G; *************************** 1. row ***************************</span><br><span class="line">id: 1 </span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: company2 </span><br><span class="line">type: ALL</span><br><span class="line">possible_keys: NULL </span><br><span class="line">key: NULL </span><br><span class="line">key_len: NULL </span><br><span class="line">ref: NULL </span><br><span class="line">rows: 1000</span><br><span class="line">Extra: Using where </span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from company2 where name like &apos;3%&apos;\G; *************************** 1. row ***************************</span><br><span class="line">id: 1 </span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: company2 </span><br><span class="line">type: range</span><br><span class="line">possible_keys: ind_company2_name </span><br><span class="line">key: ind_company2_name</span><br><span class="line">key_len: 11</span><br><span class="line">ref: NULL</span><br><span class="line">rows: 103</span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure>
<p>可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于 % 的位置不同，前者把 % 放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。如果确实有必要搜索 <code>%pattern%</code>的情况，索引是无法解决的，可以考虑使用 mysql 的 <a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html" target="_blank" rel="noopener">全文索引</a></p>
<p>如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90;</span><br></pre></td></tr></table></figure>
<p>假如 key_part1 的取值均匀分布在 1 - 100，那此时使用全表扫描可能更快。</p>
<p>此外，对于用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么也不会用到索引。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from sales\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Table: sales</span><br><span class="line">Non_unique: 1</span><br><span class="line">Key_name: ind_sales_year</span><br><span class="line">Seq_in_index: 1</span><br><span class="line">Column_name: year</span><br><span class="line">Collation: A </span><br><span class="line">Cardinality: NULL </span><br><span class="line">Sub_part: NULL </span><br><span class="line">Packed: NULL</span><br><span class="line">Null: </span><br><span class="line">Index_type: BTREE</span><br><span class="line">Comment:</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from sales where year = 2001 or country = &apos;China&apos;\G; *************************** 1. row ***************************</span><br><span class="line">id: 1 </span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: sales </span><br><span class="line">type: ALL</span><br><span class="line">possible_keys: ind_sales_year </span><br><span class="line">key: NULL</span><br><span class="line">key_len: NULL </span><br><span class="line">ref: NULL</span><br><span class="line">rows: 12</span><br><span class="line">Extra: Using where</span><br></pre></td></tr></table></figure>
<p>查看索引使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &apos;Handler_read%&apos;;</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Handler_read_first    | 299      |</span><br><span class="line">| Handler_read_key      | 20554298 |</span><br><span class="line">| Handler_read_next     | 17493910 |</span><br><span class="line">| Handler_read_prev     | 0        |</span><br><span class="line">| Handler_read_rnd      | 4269136  |</span><br><span class="line">| Handler_read_rnd_next | 11003400 |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="优化-SQL-语句"><a href="#优化-SQL-语句" class="headerlink" title="优化 SQL 语句"></a>优化 SQL 语句</h2><h5 id="优化-select"><a href="#优化-select" class="headerlink" title="优化 select"></a>优化 select</h5><p>当要查询的数据确认只有一条记录时，我们可以使用 <code>limit 1</code> 来提高性能，数据库引擎可以在找到一条记录后立即返回而不是再继续向后查找（实验结果并非如此）。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_user where accid = 123456 limit 1;</span><br></pre></td></tr></table></figure>
<p>效果就要比下面的好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_user where accid = 123456;</span><br></pre></td></tr></table></figure>
<h5 id="优化-insert"><a href="#优化-insert" class="headerlink" title="优化 insert"></a>优化 insert</h5><ul>
<li><p>对于插入多行的情况，一次插入多行比分多次插入数据要快，主要是避免了多次与数据库的连接、关闭操作。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t_test(col1, col2) values(1, 2) (3, 4) (5, 6);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当从文件中加载表时，使用 <code>LOAD DATA INFILE</code>，通常比很多 insert 的语句要快。</p>
</li>
</ul>
<h5 id="优化-group-by"><a href="#优化-group-by" class="headerlink" title="优化 group by"></a>优化 group by</h5><p>默认情况下 group by 语句会对字段进行排序，效果类似于  order by 语句。如果避免排序带来的性能消耗，可以在 group by 语句后显示指定 order by null 来禁止排序。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select id,sum(moneys) from sales2 group by id\G; *************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales2</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1000</span><br><span class="line">Extra: Using temporary; Using filesort</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id,sum(moneys) from sales2 group by id order by null\G; *************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: sales2</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1000</span><br><span class="line">Extra: Using temporary</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出第一个 SQL 语句需要进行 filesort，而第二个 SQL 由于 ORDER BY NULL 不需要进行 filesort，而 filesort 往往非常耗费时间。</p>
<h2 id="表字段类型"><a href="#表字段类型" class="headerlink" title="表字段类型"></a>表字段类型</h2><h5 id="尽量使用短的数据类型"><a href="#尽量使用短的数据类型" class="headerlink" title="尽量使用短的数据类型"></a>尽量使用短的数据类型</h5><p>如果数据容量足够，尽量选用比较段的数据类型，例如可以使用 SMALLINT 就不用 INT。</p>
<h5 id="尽量使用-NOT-NULL"><a href="#尽量使用-NOT-NULL" class="headerlink" title="尽量使用 NOT NULL"></a>尽量使用 NOT NULL</h5><p>对于允许 NULL 的字段，数据库需要额外的空间来存储该字段是否为 NULL，且在涉及比较操作时，会更为复杂。因此除非特殊情况，尽量使用 NOT NULL。</p>
<h5 id="定长-vs-变长"><a href="#定长-vs-变长" class="headerlink" title="定长 vs 变长"></a>定长 vs 变长</h5><p>常见的非定长数据类型是 VARCHAR，TEXT，BLOB，其他基本都是定长。</p>
<p>对于 MyISAM 引擎，固定长度的表会提高性能，因为搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要查找主键索引。</p>
<p>并且，固定长度的表在 crash 之后也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>
<p>而对于 InnoDB 引擎，行存储格式并没有区分定长还是变长，所有数据行都使用指向数据列值的头指针。因此变长数据类型的优势会更大。</p>
<h5 id="VARCHAR-vs-BLOB"><a href="#VARCHAR-vs-BLOB" class="headerlink" title="VARCHAR vs BLOB"></a>VARCHAR vs BLOB</h5><p>如果存储的数据大小小于8KB，那使用二进制 varchar 类型，而不使用 blob。</p>
<h5 id="顺序主键（InnoDB）"><a href="#顺序主键（InnoDB）" class="headerlink" title="顺序主键（InnoDB）"></a>顺序主键（InnoDB）</h5><p>对于 InnoDB 引擎，如果主键的值是个完全随机值，则比较好的方式是在主键前面加上一个当前日期或者时间的前缀，那么这些有序的主键存储时就会相邻，在插入或者获取时会更快。</p>
<h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><p>如果一个 blob 内存储的是很大的文本内容，可以考虑在存储时先进行压缩。</p>
<h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><h5 id="水平切割"><a href="#水平切割" class="headerlink" title="水平切割"></a>水平切割</h5><p>一般数据库的行数如果超过1000w 行，则读写性能会显著下降。因此可以根据一定规则来对所有数据进行水平切割，也即分表分库。分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。</p>
<h5 id="垂直切割"><a href="#垂直切割" class="headerlink" title="垂直切割"></a>垂直切割</h5><p>和水平切割对应的就是垂直切割了，意思是对数据库里的列进行分类，单表不能包含太多的列，可以划分成很多张表，列少的小表相对于列多的大表性能会好很多。</p>
<p>一个例子是，如果表中有一些很不常用的列，可以将这些单独拎出来组成一张表。</p>
<p>还有个例子是，假如有一张表拥有一个 <code>last_login</code> 的字段，每次登录之后都会更新该字段。更新该字段意味着数据的查询缓存每次都会被清空。因此将该字段单独出来，保证查询缓存的有效性也是个不错的主意。</p>
<p>另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去 Join 他们，不然的话，这样的性能会比不分割时还要差。</p>
<h2 id="自助分析"><a href="#自助分析" class="headerlink" title="自助分析"></a>自助分析</h2><p>如果现有数据库表已经有一定的数据量了， 则 MySQL 的自助分析工具 <code>PROCEDURE ANALYSE()</code>会显得很有用处。 它会根据表中列的数据类型和实际存储的数据来分析，并给出优化建议。</p>
<h2 id="定期优化"><a href="#定期优化" class="headerlink" title="定期优化"></a>定期优化</h2><p>对含有 TEXT 和 BLOB 字段的表，如果经常做删除和修改记录的操作要定时执行 OPTIMIZE TABLE 功能对表进行碎片整理。 </p>
<p>删除操作会在数据表中留下很大的『空洞』，以后填入这些『空洞』的记录在插入的性能上会有影响。为了提高性能建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理，避免因为『空洞』导致性能问题。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; OPTIMIZE TABLE t_territory_action;</span><br></pre></td></tr></table></figure>
<h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><ul>
<li>使用连接池</li>
<li>增加 cache 层，如 redis、memcache 等</li>
<li>主从读写分离</li>
<li>分布式</li>
</ul>
<p>参考资料</p>
<p>&lt;深入浅出 MySQL&gt;</p>
<p><a href="https://code.tutsplus.com/tutorials/top-20-mysql-best-practices--net-7855" target="_blank" rel="noopener">Top 20+ MySQL Best Practices</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/01/Linux内存Cache问题定位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/Linux内存Cache问题定位/" itemprop="url">Linux内存Cache问题定位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T11:53:06+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/01/Linux内存Cache问题定位/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/01/Linux内存Cache问题定位/" class="cy_cmt_count" data-xid="2018/09/01/Linux内存Cache问题定位/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近在做服务器压力测试，经常关注的就是服务器的负载情况。我们目前服务器的逻辑进程主要使用 lua 编写，开启定期 GC 后单个用户占用内存大概在1M 左右，开多逻辑进程后，单个进程占用内存都不大。</p>
<p>这次的小范围内部测试，只申请了一台 4 核 8 G的机器，测试开始后，cpu 和其他负载都不大。但是跑了大概1个小时左右，查看内存发现 free 的很少，只有几百兆了。其实实际占用的也并不多，但是很大一部分内存被 cache 住了，大概有 4 个多 G。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7870       7698        172          0        153       4852</span><br><span class="line">-/+ buffers/cache:       2691       5179 </span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure>
<p>以前只知道 cached 的内存一般是缓存的磁盘文件，如果后续需要内存，内核会采取策略释放这些 cached 的内存，不会出什么问题。但是这次很想知道是什么文件被 cache 住了，有没有优化措施。于是决定查下资料定位一下是哪些文件导致内存被大量 cache 的。</p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p>首先通过 proc 文件系统的 meminfo 看下当前内存的使用情况。由于 top、vmstat、free 命令都是采样的 proc 文件系统的数据，所以直接看 meminfo 会更全面准确。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo </span><br><span class="line">MemTotal:        8059260 kB</span><br><span class="line">MemFree:          176040 kB</span><br><span class="line">Buffers:          157708 kB</span><br><span class="line">Cached:          4969824 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:          6487916 kB</span><br><span class="line">Inactive:        1093960 kB</span><br><span class="line">Active(anon):    2454360 kB</span><br><span class="line">Inactive(anon):      536 kB</span><br><span class="line">Active(file):    4033556 kB</span><br><span class="line">Inactive(file):  1093424 kB</span><br><span class="line">Unevictable:           0 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:             0 kB</span><br><span class="line">SwapFree:              0 kB</span><br><span class="line">Dirty:                24 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:       2454348 kB</span><br><span class="line">Mapped:            66424 kB</span><br><span class="line">Shmem:               552 kB</span><br><span class="line">Slab:             214400 kB</span><br><span class="line">SReclaimable:     188528 kB</span><br><span class="line">SUnreclaim:        25872 kB</span><br><span class="line">KernelStack:        4176 kB</span><br><span class="line">PageTables:        10540 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:     4029628 kB</span><br><span class="line">Committed_AS:   10610552 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">VmallocUsed:       30988 kB</span><br><span class="line">VmallocChunk:   34359664624 kB</span><br><span class="line">HardwareCorrupted:     0 kB</span><br><span class="line">AnonHugePages:   2281472 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">DirectMap4k:        8180 kB</span><br><span class="line">DirectMap2M:     8380416 kB</span><br></pre></td></tr></table></figure>
<p>其中<code>anno</code> 匿名内存应该就是我们程序分配的堆栈内存，而 <code>file</code> 应该就是和文件关联的内存，比如我们的程序代码，打开的文件等。可以看到 <code>Active(file)</code>项已经很大了。</p>
<p>那怎么知道是哪个进程占用的比较多呢？这时候就要借助 top 命令的输出了。</p>
<p><img src="/images/image-20180901122607751.png" alt="image-20180901122607751"></p>
<p><code>shift + M</code> 按内存占用排序后可以看到，果然是我们的游戏进程占用最多。</p>
<p>看 <code>RES</code> 列的实际占用内存并不高，但是虚拟内存 <code>VIRT</code> 就将近3倍于实际使用内存，多出来的内存基本就是 cache 住的文件缓存了。</p>
<p>为了查看进程打开了哪些文件，我们 lsof 看下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p PID</span><br></pre></td></tr></table></figure>
<p>具体结果由于涉及业务这里就不贴了， 打开的文件主要是程序可执行文件、连接的 so、网络连接、日志文件等。从 size 大小看除日志文件外，其他都很小。我们的日志轮转大小是100M，打开的日志文件大概有 200M 左右，总的加起来也不会有4G 大小。</p>
<p>于是猜想，是不是可能缓存了其他日志文件。由于我们测试为了方便查找问题，是开启 DEBUG 级别日志的，因此日志量比较大，一个小时单个进程轮转了9个日志文件，如果缓存了部分，那就很可观了。为了证实这个猜想，我查找了一些工具来统计 cache 内存的大小。</p>
<h2 id="统计大小"><a href="#统计大小" class="headerlink" title="统计大小"></a>统计大小</h2><p>网上推荐了 <a href="https://code.google.com/archive/p/linux-ftools/" target="_blank" rel="noopener">linux-ftools</a> 这个工具来进行统计，<code>fincore</code> 是其中的一个。<code>fincore</code> 的工作原理是将指定的文件的相应 inode data 与 kernel 的 page cache table 做对比，如果 page cache table 有这个 inode 信息，就找该inode 对应的 data block 的大小。因为 kernel 的 page cache table 只存储 data block 的引用而不是文件名，即文件的 inode 信息。所以并没有任何一个工具运行一次就可以找出所有的文件使用缓存的情况。 </p>
<p>不过遗憾的是，linux-ftools 不再维护了，编译这个程序会出问题。所幸的是，还有个 Go 实现的类似功能的工具，叫 pcstat，下载方式是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -o pcstat https://github.com/tobert/pcstat/raw/2014-05-02-01/pcstat.x86_64</span><br><span class="line">或者</span><br><span class="line">curl -L -o pcstat https://github.com/tobert/pcstat/raw/2014-05-02-01/pcstat.x86_32</span><br></pre></td></tr></table></figure>
<p>这里感谢下作者的付出。</p>
<p>我们列出 log 目录下的所有目录文件，然后运行 pcstat 命令得到统计结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ ~/pcstat `ls *.0831*.<span class="built_in">log</span>`</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br><span class="line">| Name                         | Size           | Pages      | Cached    | Percent |</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br><span class="line">| dbsvr.0831.00.log            | 91415          | 23         | 6         | 026.087 |</span><br><span class="line">| dbsvr.error.0831.00.log      | 2              | 1          | 1         | 100.000 |</span><br><span class="line">| gamesvr1.0831.00.log         | 104861059      | 25601      | 8040      | 031.405 |</span><br><span class="line">| gamesvr1.0831.01.log         | 104940405      | 25621      | 20750     | 080.988 |</span><br><span class="line">| gamesvr1.0831.02.log         | 105522786      | 25763      | 23659     | 091.833 |</span><br><span class="line">| gamesvr1.0831.03.log         | 105247528      | 25696      | 25693     | 099.988 |</span><br><span class="line">| gamesvr1.0831.04.log         | 105221709      | 25689      | 25689     | 100.000 |</span><br><span class="line">| gamesvr1.0831.05.log         | 105098602      | 25659      | 25659     | 100.000 |</span><br><span class="line">| gamesvr1.0831.06.log         | 105151912      | 25672      | 22430     | 087.371 |</span><br><span class="line">| gamesvr1.0831.07.log         | 104904682      | 25612      | 3266      | 012.752 |</span><br><span class="line">| gamesvr1.0831.08.log         | 78897232       | 19263      | 4666      | 024.223 |</span><br><span class="line">| gamesvr1.error.0831.00.log   | 600715         | 147        | 10        | 006.803 |</span><br><span class="line">| gamesvr2.0831.00.log         | 104963951      | 25626      | 9292      | 036.260 |</span><br><span class="line">| gamesvr2.0831.01.log         | 104965184      | 25627      | 19936     | 077.793 |</span><br><span class="line">| gamesvr2.0831.02.log         | 105106982      | 25661      | 14924     | 058.158 |</span><br><span class="line">| gamesvr2.0831.03.log         | 105292165      | 25707      | 24521     | 095.386 |</span><br><span class="line">| gamesvr2.0831.04.log         | 104927914      | 25618      | 23745     | 092.689 |</span><br><span class="line">| gamesvr2.0831.05.log         | 105090378      | 25657      | 13332     | 051.962 |</span><br><span class="line">| gamesvr2.0831.06.log         | 105175478      | 25678      | 10070     | 039.216 |</span><br><span class="line">| gamesvr2.0831.07.log         | 104893356      | 25609      | 21299     | 083.170 |</span><br><span class="line">| gamesvr2.0831.08.log         | 73241449       | 17882      | 10886     | 060.877 |</span><br><span class="line">| gamesvr2.error.0831.00.log   | 618867         | 152        | 9         | 005.921 |</span><br><span class="line">| gamesvr3.0831.00.log         | 105143734      | 25670      | 10861     | 042.310 |</span><br><span class="line">| gamesvr3.0831.01.log         | 104923026      | 25616      | 19485     | 076.066 |</span><br><span class="line">| gamesvr3.0831.02.log         | 104971350      | 25628      | 21631     | 084.404 |</span><br><span class="line">| gamesvr3.0831.03.log         | 104984690      | 25632      | 23985     | 093.574 |</span><br><span class="line">| gamesvr3.0831.04.log         | 105210760      | 25687      | 23336     | 090.848 |</span><br><span class="line">| gamesvr3.0831.05.log         | 104935556      | 25620      | 12325     | 048.107 |</span><br><span class="line">| gamesvr3.0831.06.log         | 105270020      | 25701      | 17420     | 067.779 |</span><br><span class="line">| gamesvr3.0831.07.log         | 105085266      | 25656      | 23922     | 093.241 |</span><br><span class="line">| gamesvr3.0831.08.log         | 50092509       | 12230      | 11285     | 092.273 |</span><br><span class="line">| gamesvr3.error.0831.00.log   | 563414         | 138        | 6         | 004.348 |</span><br><span class="line">| gamesvr4.0831.00.log         | 104876090      | 25605      | 23576     | 092.076 |</span><br><span class="line">| gamesvr4.0831.01.log         | 105038856      | 25645      | 22705     | 088.536 |</span><br><span class="line">| gamesvr4.0831.02.log         | 105311253      | 25711      | 23118     | 089.915 |</span><br><span class="line">| gamesvr4.0831.03.log         | 105305787      | 25710      | 24598     | 095.675 |</span><br><span class="line">| gamesvr4.0831.04.log         | 104948309      | 25623      | 24237     | 094.591 |</span><br><span class="line">| gamesvr4.0831.05.log         | 104858573      | 25601      | 24100     | 094.137 |</span><br><span class="line">| gamesvr4.0831.06.log         | 105359076      | 25723      | 24075     | 093.593 |</span><br><span class="line">| gamesvr4.0831.07.log         | 105010884      | 25638      | 23978     | 093.525 |</span><br><span class="line">| gamesvr4.0831.08.log         | 58704318       | 14333      | 13332     | 093.016 |</span><br><span class="line">| gamesvr4.error.0831.00.log   | 605733         | 148        | 11        | 007.432 |</span><br><span class="line">| gatesvr.0831.00.log          | 104982018      | 25631      | 802       | 003.129 |</span><br><span class="line">| gatesvr.0831.01.log          | 30392638       | 7421       | 395       | 005.323 |</span><br><span class="line">| gatesvr.error.0831.00.log    | 364959         | 90         | 4         | 004.444 |</span><br><span class="line">| gmtool.0831.00.log           | 1818           | 1          | 0         | 000.000 |</span><br><span class="line">| gmtool.error.0831.00.log     | 2              | 1          | 1         | 100.000 |</span><br><span class="line">| sessionsvr.0831.00.log       | 104899344      | 25611      | 3047      | 011.897 |</span><br><span class="line">| sessionsvr.0831.01.log       | 21431262       | 5233       | 1166      | 022.282 |</span><br><span class="line">| sessionsvr.error.0831.00.log | 25675          | 7          | 1         | 014.286 |</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br></pre></td></tr></table></figure>
<p>可以看到大量的轮转过的日志文件，虽然没有再被打开使用，仍然被操作系统缓存了起来，百分比不等。</p>
<p>我们可以使用 linux 的清除 cache 命令来手动释放一下试试，使用 root 执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sync</span><br><span class="line">$ <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches </span><br><span class="line">$ <span class="built_in">echo</span> 0 &gt; /proc/sys/vm/drop_caches 	<span class="comment"># 恢复0</span></span><br></pre></td></tr></table></figure>
<p>再查看内存使用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          7870       2587       5282          0          2         62</span><br><span class="line">-/+ buffers/cache:       2521       5348 </span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure>
<p>cache 的大量内存被释放了，再查看 pcstat 的统计结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ ~/pcstat `ls *.0831*.<span class="built_in">log</span>`</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br><span class="line">| Name                         | Size           | Pages      | Cached    | Percent |</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br><span class="line">| dbsvr.0831.00.log            | 91415          | 23         | 0         | 000.000 |</span><br><span class="line">| dbsvr.error.0831.00.log      | 2              | 1          | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.00.log         | 104861059      | 25601      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.01.log         | 104940405      | 25621      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.02.log         | 105522786      | 25763      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.03.log         | 105247528      | 25696      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.04.log         | 105221709      | 25689      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.05.log         | 105098602      | 25659      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.06.log         | 105151912      | 25672      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.07.log         | 104904682      | 25612      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.0831.08.log         | 78897232       | 19263      | 0         | 000.000 |</span><br><span class="line">| gamesvr1.error.0831.00.log   | 600715         | 147        | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.00.log         | 104963951      | 25626      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.01.log         | 104965184      | 25627      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.02.log         | 105106982      | 25661      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.03.log         | 105292165      | 25707      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.04.log         | 104927914      | 25618      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.05.log         | 105090378      | 25657      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.06.log         | 105175478      | 25678      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.07.log         | 104893356      | 25609      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.0831.08.log         | 73241449       | 17882      | 0         | 000.000 |</span><br><span class="line">| gamesvr2.error.0831.00.log   | 618867         | 152        | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.00.log         | 105143734      | 25670      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.01.log         | 104923026      | 25616      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.02.log         | 104971350      | 25628      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.03.log         | 104984690      | 25632      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.04.log         | 105210760      | 25687      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.05.log         | 104935556      | 25620      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.06.log         | 105270020      | 25701      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.07.log         | 105085266      | 25656      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.0831.08.log         | 50092509       | 12230      | 0         | 000.000 |</span><br><span class="line">| gamesvr3.error.0831.00.log   | 563414         | 138        | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.00.log         | 104876090      | 25605      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.01.log         | 105038856      | 25645      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.02.log         | 105311253      | 25711      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.03.log         | 105305787      | 25710      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.04.log         | 104948309      | 25623      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.05.log         | 104858573      | 25601      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.06.log         | 105359076      | 25723      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.07.log         | 105010884      | 25638      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.0831.08.log         | 58704318       | 14333      | 0         | 000.000 |</span><br><span class="line">| gamesvr4.error.0831.00.log   | 605733         | 148        | 0         | 000.000 |</span><br><span class="line">| gatesvr.0831.00.log          | 104982018      | 25631      | 0         | 000.000 |</span><br><span class="line">| gatesvr.0831.01.log          | 30392638       | 7421       | 0         | 000.000 |</span><br><span class="line">| gatesvr.error.0831.00.log    | 364959         | 90         | 0         | 000.000 |</span><br><span class="line">| gmtool.0831.00.log           | 1818           | 1          | 0         | 000.000 |</span><br><span class="line">| gmtool.error.0831.00.log     | 2              | 1          | 0         | 000.000 |</span><br><span class="line">| sessionsvr.0831.00.log       | 104899344      | 25611      | 0         | 000.000 |</span><br><span class="line">| sessionsvr.0831.01.log       | 21431262       | 5233       | 0         | 000.000 |</span><br><span class="line">| sessionsvr.error.0831.00.log | 25675          | 7          | 0         | 000.000 |</span><br><span class="line">|------------------------------+----------------+------------+-----------+---------|</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，这里只是通过清除命令展示一下 cache 前后的统计结果，生产环境在运行时，不要手动释放这些缓存，否则可能带来性能方面的问题，应该放心的由操作系统去实时他的策略。</p>
<p>参考资料</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s2-proc-meminfo" target="_blank" rel="noopener">/proc/meminfo官方文档</a></p>
<p><a href="https://colobu.com/2017/03/07/what-is-in-linux-cached/" target="_blank" rel="noopener">谁吃了我的Linux内存?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/30/linux下服务器端口冲突/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/30/linux下服务器端口冲突/" itemprop="url">linux下服务器端口冲突</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-30T16:52:04+08:00">
                2018-08-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/30/linux下服务器端口冲突/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/30/linux下服务器端口冲突/" class="cy_cmt_count" data-xid="2018/08/30/linux下服务器端口冲突/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在生产环境部署服务器集群的时候，由于服务器进程众多，需要监听的端口也非常多，通常我们会通过一定规则为每个进行指定特定的端口来绑定，这没什么问题。</p>
<p>但是由于服务器之间需要通信，因此服务器进程之间会建立大量的 TCP 连接。在主动连接的一方，我们不必类似于监听一样手动 bind 固定的端口，操作系统会为我们随机选择一个端口，来与目的端口进行通信。当连接数量很多时，这种随机选择的端口会和我们指定的端口冲突。（注意 UDP 虽然没有连接的概念，也是要占用端口的）</p>
<p>一种典型的情况是</p>
<ul>
<li><p>进程 A 和 B 启动完成，B 建立了一条连接到 A，本地端口选择为10000</p>
</li>
<li><p>进程 C 恰好监听在端口10000，于是 C 进程启动时就会因为端口被占用而启动失败</p>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决这个问题，我们通常分别约定监听端口和随机选择端口的范围。</p>
<p>例如，在指定监听端口的时候，我们可以指定 5000 - 15000 是可用的监听范围。而本地随机选择的端口范围设置为 15000 - 65000。这样就可以有效避免冲突。</p>
<p>在 linux 下有内核选项可以设置本地端口的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/ip_local_port_range </span><br><span class="line">4000	65000</span><br></pre></td></tr></table></figure>
<p>关于 <code>ip_local_port_range</code> 的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The /proc/sys/net/ipv4/ip_local_port_range defines the local port range that is used by TCP and UDP traffic to choose the local port. </span><br><span class="line">You will see in the parameters of this file two numbers: The first number is the first local port allowed for TCP and UDP traffic on the server, the second is the last local port number. </span><br><span class="line">For high-usage systems you may change its default parameters to 32768-61000 -first-last.</span><br></pre></td></tr></table></figure>
<p>我们利用 <code>sysctl</code> 命令修改其值为<code>15000 65000</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.ip_local_port_range=<span class="string">"15000 65000"</span></span><br></pre></td></tr></table></figure>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p>还有一个很常见的影响端口使用的是连接 TIME_WAIT 状态。</p>
<p>在 TCP 连接关闭时，需要经历四次挥手的过程，而主动发起关闭的一方，发送完最后一个 ACK (最后一步) 后，进入  TIME_WAIT 状态，且需要等待 <code>2MSL</code> 的时间。等待时间过去后，连接关闭。</p>
<p>示意图如下</p>
<p><img src="/images/D0D404D6-3813-412A-B5C5-4333E7F20F5D.png" alt="D0D404D6-3813-412A-B5C5-4333E7F20F5D"></p>
<p><code>MSL(Maximum Segment Lifetime)</code>：报文最大生存时间，用于限制 TCP 包在网络中最大留存时间，超过这个时间，包将被丢弃。IP 层有个类似的 TTL 跳数来决定 IP 报文的去留，MSL 和 TTL 共同限制了 TCP 包的生存时间。由此可知，当网络拥塞时，超过 TCP 生存时间的包会被丢弃，导致丢包。RFC 建议 MSL 为 2 分钟，而 Linux 下为 30 秒。</p>
<p>TIME_WAIT 等待的时间 2MSL 是常量 <code>TCP_TIMEWAIT_LEN</code>（linux 下就是1分钟）定义的，除非重新编译内核，否则不能修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT</span><br><span class="line">                                  * state, about 60 seconds     */</span><br></pre></td></tr></table></figure>
<p>那为什么需要等待 <code>2MSL</code> 的时间呢？</p>
<p><strong>第一个原因</strong>，是为了正常终止通信的一半通道(我方已关闭一半，确保对方也正确关闭另一半)。由于 TCP 是全双工，连接终止时需要双方分别关闭对应的通道。在收到进入 TIME_WAIT 时，肯定一方已经关闭了一半通道且本方收到了关闭另一半通道的 FIN 包，剩下的就是本方发出 FIN 包的 ACK，然后等待接收，完成后整个 TCP 连接就关闭了。</p>
<p>也就是说，进入 TIME_WAIT 状态之后，唯一的步骤就是对方收到 ACK 包之后关闭 TCP。这里的问题就在于万一 ACK 包由于网络拥塞没有及时被对方收到，那一段时间之后，对方会认为是之前发的 FIN 包没有被收到造成的，采取的措施就是重发 FIN 包到本方，那之前丢的那个 ACK 包的最大存活时间是 MSL，重发的 FIN 包也是在 MSL 时间内存活，加起来就是 2MSL 的时间。只要在 2MSL 时间内，其状态一直是 TIME_WAIT，那么就能处理这种丢包的情况。处理完了，就能关闭了（仁至义尽，如果再丢包，那就不管了）。</p>
<p>可以想像一下，如果没有这个 TIME_WAIT 状态而直接关闭呢？如果最后一个 ACK 丢失，那对方会处于 LAST_ACK 状态。这种情况下，如果主动关闭的一方再次发起一次连接到对方，且双方端口也一样，那该条连接相当于被复用，对方在该连接收到新的三次握手的 SYN 包 (并且序列号满足要求) 后，会直接返回 RST，认为包非法。</p>
<p><strong>还有一个原因</strong>，就是让被关闭的连接上所有的包都消逝掉，防止新建的连接误收了之前连接的包。这种情况可能发生吗？</p>
<p>我们假设进入 TIME_WAIT 状态之后只等很短的时间就关闭连接，释放资源，在这里就是之前连接的本方端口可以再次被使用了。如果是客户端主动关闭的，那可以复用的就是之前随机分配的本地端口（客户端 connect 服务器的时候，操作系统随机选择一个本地端口与服务器的固定端口建立连接）；如果是服务器主动关闭的，可以复用的就是之前监听的固定端口。</p>
<p>如果端口被复用后，连接的五元组（双方 IP，双方端口，协议类型）都一样，那么这条连接建立后就很可能接收到之前被关闭的同样五元组的连接的残余包了。（其实我在想，用五元组标识连接有隐患，为啥不再搞个序列号加以区分）。</p>
<p>残余包很可能是比较危险的，例如上面提到的如果本方发出的最后一个 ACK 包没有收到，那对方重发的 FIN 包被新建的连接收到了，那就麻烦了。此外，还可能有延迟收到的普通包。</p>
<p>有了持续 2MSL 时间的 TIME_WAIT 状态，就可以处理延迟包的情况了：收到重发的 FIN 包，再回一个 ACK；收到其他包，直接丢弃。</p>
<p>了解了 TIME_WAIT 状态的原理，我们再来说下其造成的端口冲突情况。</p>
<p>TIME_WAIT 状态，如果是客户端主动断开连接，影响并不大，主要是之前随机选择的本地端口 2MSL 时间内不可用，再建立连接时选一个其他的就可以了。但是如果是服务器主动断开连接呢？我们经常遇到的一种情况就是服务器临时关闭然后重启，此时服务器会主动关闭所有监听端口上已经建立的连接，然后重新启动监听在同一端口。</p>
<p>前面我们也分析了，如果是服务器主动断开的连接，本方端口，也就是监听的端口，在 2MSL 时间内不能再被使用，这造成了我们重启启动进程并监听时，提示『端口已被使用』，启动失败。</p>
<blockquote>
<p>除了 TIME_WAIT，其他状态如 CLOSE_WAIT、ESTABLISHED 状态的连接对应的本方端口也是不可用的</p>
</blockquote>
<p>为了解决这个问题，通常服务器的做法是在设置监听 socket 启用 <code>SO_REUSEADDR</code> 选项重用处于 2MSL 时间内的连接资源。</p>
<p>具体使用可以这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuseaddr = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上 SO_REUSEADDR 选项不仅能重用端口，还能重用 IP 资源。例如一个进程在监听在地址 0.0.0.0:80，而另一个进程可以监听地址 10.1.164.1:80。</p>
</blockquote>
<p>另一种方式是修改 linux 的内核参数 <code>net.ipv4.tcp_tw_reuse</code>，缺省是 0 不开启重用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><br></pre></td></tr></table></figure>
<p>从名字可以想到，这个选项是允许重用处于 TIME_WAIT 状态的 socket 连接。<code>man 7 tcp</code> 的文档中有如下解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_tw_reuse (Boolean; default: disabled; since Linux 2.4.19/2.6)</span><br><span class="line">	Allow  to reuse TIME_WAIT sockets for new connections when it is safe from protocol 	viewpoint.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然选项设置里名字里是 ipv4，对 ipv6 也是适用的。</p>
</blockquote>
<p>其重用原理可能是根据 tcp 的时间戳来区分新老连接的包，具体可以查看 <a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>而另外一个选项 <code>net.ipv4.tcp_tw_recycle</code>意思是开启 TIME_WAIT 状态 sockets 的快速回收。之前 2MSL 时间才回收的连接，很可能很快就被回收（一种说法回收时间是连接的 RTT）。启用之后，对于涉及 NAT 的网络情况会产生一些问题，因此<strong>不建议使用</strong>。似乎该选项在新版的 linux 内核中已经被废弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_tw_recycle (Boolean; default: disabled; since Linux 2.4)</span><br><span class="line">	Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not recommended 	 since this causes problems when working with NAT  (Network Address Translation).</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<p><a href="https://zhuanlan.zhihu.com/p/20365900" target="_blank" rel="noopener">网络编程（六）：端口那些事儿</a></p>
<p><a href="http://wudaijun.com/2015/10/tcp-notes-2/" target="_blank" rel="noopener">TCP服务器参见问题和参数设置</a></p>
<p><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/Go调度模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/Go调度模型/" itemprop="url">Go调度模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T19:55:54+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/21/Go调度模型/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/21/Go调度模型/" class="cy_cmt_count" data-xid="2018/08/21/Go调度模型/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-的-Runtime"><a href="#Go-的-Runtime" class="headerlink" title="Go 的 Runtime"></a>Go 的 Runtime</h2><p>下面这张图说明了 Go 程序在执行时与操作系统的大致交互原理。</p>
<p><img src="/images/image-20180822155050672.png" alt="image-20180822155050672"></p>
<p>我们编写的 Go 程序除了运行自己的逻辑之外，还会涉及到与操作系统的交互，例如分配内存、创建 goroutine、通过channel与其他 goroutine 进行交互等。那么程序代码和操作系统之间是怎么交互的呢？这就用到了 go 里的 runtime 库。runtime 库主要的功能包含垃圾回收、调度、goroutine 管理等。</p>
<p>上图中程序代码和 runtime 库一起运行在用户空间，并在必要时(例如触发系统调用) 时与操作系统进行交互。</p>
<p>本文我们将只讲述 Runtime 库的调度器，其他不做涉及。</p>
<h2 id="Runtime-Scheduler"><a href="#Runtime-Scheduler" class="headerlink" title="Runtime Scheduler"></a>Runtime Scheduler</h2><h3 id="调度器的必要性"><a href="#调度器的必要性" class="headerlink" title="调度器的必要性"></a>调度器的必要性</h3><p>既然操作系统可以帮助我们来调度线程，那么为什么Go 还要实现一个用户空间级别的调度器呢？</p>
<p>Posix 的线程 API 本质上是对 Unix 进程模型的逻辑扩展，所以有很多类似于进程的控制机制，例如线程有自己的信号掩码，可以被指定到固定的 CPU 上执行，可以被放入 cgroups等等，这些控制机制使得线程运行时有很大的开销(overhead)。想想一下如果随着 goroutine 的增加，你的进程里有100,000个线程的情景。其实对于 goroutine，这些开销并不那么必要。</p>
<p>另外一个问题是垃圾回收时，调度会发生在任意时间点，需要所有线程停止执行，直到待回收的 memory 处于一致性的状态，中间只能等待。而有了 go 的调度器，它只会在线程内存处于一致性的时候进行垃圾回收，也就是说只需要等待那些正在 CPU 上运行的线程(等待他们的内存趋于一致性)。</p>
<h3 id="调度模型"><a href="#调度模型" class="headerlink" title="调度模型"></a>调度模型</h3><p>通常有三种线程调度模型：</p>
<ul>
<li>N:1模型。N 个用户级的线程运行在一个 OS 线程上。由于是多个用户级线程，因此上下文切换很快；但是不能利用到CPU 的多核特性。</li>
<li>1:1模型。本质上是 N:N 的模型，每个用户线程唯一对应了一个 OS 线程，好处是利用了所有的核心，但是线程间上下文切换非常慢，因为要跨越 OS。</li>
<li>M:N 模型。这是 go使用的调度模型。它将任意多个 goroutine 运行在任意数量的 OS 线程上(通常 goroutine 数量要远多于OS线程数量)，既充分利用了多核，又能很快的调度(goroutine 调度)。</li>
</ul>
<h3 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h3><p>为了完成 goroutine 的调度，go 给出了三个概念M、P、G</p>
<p><img src="/images/image-20180822171005278.png" alt="image-20180822171005278"></p>
<p>G 就是我们的 goroutine，是用户级别的调度单位。它有自己的栈、指令指针(IP)及调度器需要的信息、状态等。</p>
<p>M 代表 OS 线程，由操作系统负责管理。M 用来实际执行 G。</p>
<p>P 是一个抽象概念。在 G 被 M 实际执行前，P 负责管理多个待执行的 G。如果 M 中的 G 执行完毕，则会从 P 中 顺序取出另一个待执行的 G 来执行。</p>
<p>通过多个 P 可以将 N:1的调度模型转为 M:N 的模型。每个 P 对应了一个 M 来实际执行 G。</p>
<p>大致的调度示意图如下</p>
<p><img src="/images/image-20180822173934726.png" alt="image-20180822173934726"></p>
<p>图中一共有6个 goroutine，被放入 3 个队列 P1、P2、P3 来调度。其中有 3 个 G 已经在对应的 M 中运行，另外 3 个在队列中等待执行。</p>
<p>那么程序启动后如何选择 P 的数量呢？默认情况下，它等于 CPU 的逻辑核心数。例如我的 Mac 是单 CPU 双核四线程的，则 P 的数量就是 4。这个数量也可以通过 <code>GOMAXPROCS</code> 环境变量或者 <code>runtime.GOMAXPROCS()</code> 函数来进行设置，一般来说使用默认的即可。</p>
<p>下面我们分别来看看以下几种场景，调度器如何工作：</p>
<h5 id="场景1：创建-goroutine"><a href="#场景1：创建-goroutine" class="headerlink" title="场景1：创建 goroutine"></a>场景1：创建 <code>goroutine</code></h5><p>goroutine 的创建通过 <code>go func()</code>语句来触发，实际调用的是 <code>runtime.newproc</code> 函数 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用<code>newproc1</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()  <span class="comment">// 获取当前运行的 goroutine G	</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    _p_ := _g_.m.p.ptr()   <span class="comment">// 找到当前 G 所在工作线程 M 所关联的 P </span></span><br><span class="line">	newg := gfget(_p_)     <span class="comment">// 如果 P 有之前创建并回收了的空闲的 G，则复用</span></span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;       <span class="comment">// 没有则新建一个</span></span><br><span class="line">        newg = malg(_StackMin) <span class="comment">// new 一个栈大小为_StackMin(2k)的 G </span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg)</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)	<span class="comment">//新 G 放入 P 的待执行队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可知，新的 goroutine 会被放入到特定 P 的本地执行队列中，如果 P 的本地队列已满，则会放入一个称为『全局队列』的队列，通常全局队列很少用到，大部分操作在本地队列中。</p>
<h5 id="场景2：队列调度"><a href="#场景2：队列调度" class="headerlink" title="场景2：队列调度"></a>场景2：队列调度</h5><p>队列的调度循环主要是<code>schedule</code>函数。</p>
<p>M 执行 G 的时候，需要关联一个 P。当 M 执行完某个 G 时，它会从 P 的等待队列中 pop 出一个新的 G 来执行。注意 P 的待执行本地队列是一个无锁队列，存取都是比较高效。而全局队列会被很多 P 访问，因此加入了锁保证安全性。选择可以执行的 G 通过函数<code>findrunnable()</code>来完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>findrunnable()</code>中，并不总是从本地队列里取，否则全局队列里的 G 将被『饿死』，永远无法执行。为了公平起见，每61次调度检查一下全局队列。此外， go 的网络操作也是整合到 runtime 中的，<code>findrunnable</code> 也会从 network 从寻找阻塞的 G 来执行。</p>
<p>如果以上所有都没有可供执行的 G 呢？我们不能让该工作线程 M 处于空闲状态，必须充分利用。为此，就用到了一种被称为<code>Work-Stealing</code> 的调度算法，当前 P 会尝试从其他的 P 随机选择一个，从中『偷取』一半的 G 放入本队列，于是当前 P 又可以继续调度了。<code>Work-Stealing</code> 保证了整个调度系统内队列的平衡。示意图如下</p>
<p><img src="/images/image-20180822194002035.png" alt="image-20180822194002035"></p>
<h5 id="场景3：执行中断"><a href="#场景3：执行中断" class="headerlink" title="场景3：执行中断"></a>场景3：执行中断</h5><p>我们知道，当一个 G 在 M 中执行时，队列中的其他 G 会处于等待状态，那么如果这个 G 中的代码是个长时间执行的代码，那其他 G 会一直等待，直到 G 执行完成吗？我们通过一段代码来看看。简单起见，我们设置 P 的数量为1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char := ‘a’; char &lt; ‘a’+<span class="number">26</span>; char++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./runtime2 </span><br><span class="line">Starting Go Routines</span><br><span class="line">Waiting To Finish</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 </span><br><span class="line">Terminating Program</span><br></pre></td></tr></table></figure>
<p>可见，前一个 goroutine 执行完成之后才会执行下一个 goroutine。</p>
<blockquote>
<p>这里注意，goroutine 的执行顺序和代码里的顺序正好相反，是因为最新创建的 goroutine 被放入了优先执行队列 runnext 里。所以后创建的 goroutine 反而最优先执行。</p>
</blockquote>
<p>有没有可能是前一个 G 执行太快导致后一个G 没来得及执行？为此我们将后一个 goroutine 改为死循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果显示，打印数字的 goroutine 永远得不到执行。</p>
<p>那 goroutine 可能被中断执行吗？答案是 yes。正在运行的 goroutine 中如果有以下操作，将会导致其被中断执行</p>
<ul>
<li>系统调用 (例如打开一个文件)</li>
<li>time.Sleep</li>
<li>channel 读写操作</li>
<li>sync 包中的锁操作</li>
<li>网络 IO </li>
<li>主动调用 runtime.Sched()</li>
</ul>
<p>中断执行的 M 及其 G，会从对应的 P 上 detach，进入阻塞状态，等待系统调用或者其他操作的完成。而 P 会尝试寻找另一个可用的 M，使其可以继续调度后续的 G 来执行。一般可以从空闲的 M 中选择一个，如果没有空闲的 M，则新创建一个 M（OS 线程）来 attach 到 P 上，如下图所示</p>
<p><img src="/images/image-20180822205943304.png" alt="image-20180822205943304"></p>
<p>我们看到</p>
<ul>
<li>线程 M0 放弃了它关联的 P，开始等待阻塞的 OS 调用的完成；</li>
<li>P 找到了一个线程 M1(空闲的或者新建的) 继续调度；</li>
<li>当 M0上的 OS 调用完成后，它需要找到一个可用的 P 来继续执行返回的 G 上的代码</li>
<li>如果没有找到可用的 P，则 M0 会将其上的 G 放到全局队列，自身进入空闲状态，被动等待其他 P 调用</li>
</ul>
<p>这里我们利用一段代码来实验下这个特性。现在在死循环过程中周期性的插入系统调用代码。常用的 fmt.Printf 打印信息到标准输出，就包含一个典型的系统调用 syscall.Write (syscall 包里还有很多其他系统调用)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            a++</span><br><span class="line">            <span class="keyword">if</span> a % <span class="number">1e9</span> == <span class="number">0</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"\nperiodly syscall."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./runtime6</span><br><span class="line">Starting Go Routines</span><br><span class="line">Waiting To Finish</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 </span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>显然另一个 goroutine 也得到了调度运行。</p>
<p>而如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到一个 wait 队列中，这个队列会是 channel 的发送或接收队列或者网络 IO 的等待队列；而 M 会尝试运行下一个 runnable 的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，在 wait 队列中的 G 会被唤醒，标记为runnable，放入到某P的队列中，绑定一个 M 继续执行。</p>
<p>这里我们使用 http 包来拉取百度首页为例来测试网络 IO 的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%v start\n"</span>, idx)</span><br><span class="line">            _, err := http.Get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%v error %v\n"</span>, idx, err)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%v end\n"</span>, idx)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Terminating Go Routines"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go run runtime6.go </span><br><span class="line">Starting Go Routines</span><br><span class="line">0 start</span><br><span class="line">1 start</span><br><span class="line">2 start</span><br><span class="line">3 start</span><br><span class="line">4 start</span><br><span class="line">2 end</span><br><span class="line">1 end</span><br><span class="line">0 end</span><br><span class="line">3 end</span><br><span class="line">4 end</span><br><span class="line">Terminating Go Routines</span><br></pre></td></tr></table></figure>
<p>可见网络 IO 确实触发了 goroutine 的执行中断。</p>
<p>综上可以知道：</p>
<p><strong>即使设置 GOMAXPROCS 为1，程序仍然可能会执行在多个OS线程上，即实际上的并发执行(非并行执行)</strong></p>
<h5 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h5><p>G-P-M模型的实现算是Go scheduler的一大进步，但Scheduler仍然有一个头疼的问题，那就是不支持抢占式调度，导致一旦某个G中出现死循环或永久循环的代码逻辑，也没有导致中断执行的调用，那么G将永久占用分配给它的P和M，位于同一个P中的其他G将得不到调度，出现『<strong>饿死</strong>』的情况。更为严重的是，当只有一个P时(GOMAXPROCS=1)时，整个Go程序中的其他G都将“饿死”。于是Dmitry Vyukov又提出了《<a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#!" target="_blank" rel="noopener">Go Preemptive Scheduler Design</a>》并在<a href="https://blog.golang.org/go12" target="_blank" rel="noopener">Go 1.2</a>中实现了『抢占式』调度。</p>
<p>这个抢占式调度的原理则是在每个函数或方法的入口，加上一段额外的代码 (morestack调用)，让runtime有机会检查是否需要执行抢占调度。这种解决方案只能说局部解决了“饿死”问题，对于没有函数调用，纯算法循环计算的G，scheduler依然无法抢占。为此，我们利用下面这段代码看看抢占式的调用是否起效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfn</span><span class="params">(ptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ptr != <span class="literal">nil</span> &#123;</span><br><span class="line">        (*ptr)++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dummy</span><span class="params">(ptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    myfn(ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            dummy(&amp;a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序是对前面一段死循环赋值程序的改写，使用了函数调用。需要注意的是，在编译时候需要禁用编译器优化，否则简单函数将被内联优化掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">"-N -l"</span> runtime5.go</span><br></pre></td></tr></table></figure>
<p>另外，为什么不直接调用 <code>myfn</code> 函数，而是中间再插入一个<code>dummy</code>函数呢？那是因为 <code>myfn</code> 函数位于调用树的leaf（叶子）位置，compiler可以确保其不再有新栈帧生成，不会导致栈分裂或超出现有栈边界，于是就不再插入morestack 来检查是否需要进行抢占式调度。具体实验过程可以参考 TonyBai 的 <a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="调度追踪"><a href="#调度追踪" class="headerlink" title="调度追踪"></a>调度追踪</h2><p>golang 的 runtime 库提供了 GODEBUG 来输出调试信息，通过 schedtrace=X 选项可以使调度器每隔一定时间向标准错误输出调度状态。我们利用该选项追踪一下下面这段代码的调度过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    wg.Add(num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> work(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait to see the global run queue deplete.</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e10</span>; i++ &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 GODEBUG 来观察调度器的执行情况 (使用默认的 GOMAXPROCS = 4) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./runtime4</span><br><span class="line">SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=2 spinningthreads=0 idlethreads=0 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 3008ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 4012ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 5018ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 6026ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 7035ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=3 [2 0 1 0]</span><br><span class="line">SCHED 8041ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 9046ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 10055ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 11055ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 12056ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 13064ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 14072ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 15074ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 16083ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 17087ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 18095ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 19097ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>首先看下 1000ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>此时，4个工作线程 M 刚刚被创建，对应 4 个 P，并处于 idle 状态；另有 2 个线程被 runtime 使用，一共是 6 个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br></pre></td></tr></table></figure>
<p>在 2006ms，idleprocs 为 0，表示 4 个 procs 均处于工作状态，各持有一个 G，剩余的 6 个 G 分别放置在4个 P 对应的本地队列中 （ 2 + 1 + 2 + 1），全局队列中有 0 个 G</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 7035ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=3 [2 0 1 0]</span><br></pre></td></tr></table></figure>
<p>在 7035ms，有 3 个 G 执行完成，放入全局队列中等待结束，再从 3 个 P 中取出 3 个 G 放入 M 中执行，因此全局队列和本地队列数量分别是 <code>runqueue=3 [2 0 1 0]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 8041ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br></pre></td></tr></table></figure>
<p>在 8041ms，又有一个 G 执行完成，放入全局队列中，再从其关联的 P 中取出一个 G 放入 M 中执行，因此全局队列和本地队列数量分别是 <code>runqueue=4 [1 0 1 0]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 13064ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>在 13064ms，此时没有待执行的 G 了，只有 4 个正在执行的 G，其余 6 个都已经执行完毕并退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 17087ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>在17087ms，所有 G 执行完毕，<code>idleprocs=4</code>，所有 proc 处于空闲状态</p>
<p>更详细的关于追踪的情况，可以参考 William Kennedy 写的博客 [ Scheduler Tracing In Go]<a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html</a></p>
<p>参考资料</p>
<p><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener"> Scheduler Tracing In Go</a></p>
<p><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">The Go scheduler</a></p>
<p><a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="noopener">Analysis of the Go runtime scheduler</a></p>
<p><a href="https://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener">Golang源码探索(二) 协程的实现原理</a></p>
<p><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">也谈goroutine调度器</a></p>
<p><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/c-c-编译过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/c-c-编译过程/" itemprop="url">c/c++编译过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T14:35:40+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/21/c-c-编译过程/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/21/c-c-编译过程/" class="cy_cmt_count" data-xid="2018/08/21/c-c-编译过程/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C/C++ 是高级编译型语言，执行的时候需要将容易阅读的源码编译成机器可以识别的机器指令，交由 CPU 执行。这篇文章我们来研究一下编译是怎样一个过程。</p>
<p>绝大多数编译器并不是一个单一的庞大程序，它通常由六七个稍小的程序组成，这些程序由一个叫做『编译器驱动器』(compiler driver) 的控制程序来调度。整个编译过程大致可以分为四个主要阶段：</p>
<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ul>
<p>我们以一个简单的 c 程序来举例，c 代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(a, b) (a + b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// here is comment</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"DEBUG defined\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> DEBUG not defined!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addition is: %d\n"</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 centos 环境利用 gcc 进行编译，添加选项 <code>-save-temps</code> 我们可以获取编译过程每个阶段产生的临时文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -save-temps -DDEBUG filename.c -o filename</span><br></pre></td></tr></table></figure>
<p>可以看到分别生成了以下文件</p>
<p><img src="/images/image-20180821150535977.png" alt="image-20180821150535977"></p>
<p>其中</p>
<p><code>filename.c</code> 源码文件 </p>
<p><code>filename.i</code> 预编译后文件</p>
<p><code>filename.s</code> 汇编文件</p>
<p><code>filename.o</code> 编译目标文件</p>
<p><code>filename</code> 链接后的可执行文件</p>
<p>下面我们分别看看每个阶段具体在进行哪些操作。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理阶段，编译器驱动调动预处理器处理 <strong>预处理指令</strong> ，所谓预处理指令是指以 <code>#</code> 开头的指令，主要有注释、宏、头文件包含、条件编译等，因此这个阶段包括以下几个操作</p>
<ul>
<li>去除注释</li>
<li>展开宏定义</li>
<li>展开头文件包含</li>
<li>条件编译<code>#ifdef</code>、<code>#ifndef</code> 处理</li>
<li>error 抛出错误信息</li>
</ul>
<p>我们打开预处理后的 <code>filename.i</code> 文件可以看到：注释被去除了，参数宏 <code>add(a, b)</code> 也被 <code>(a + b)</code> 替换，包含的头文件 <code>&lt;stdio.h&gt;</code> 中的内容被拷贝到源文件 <code>filename.c</code> 中；此外编译时候有没有指定 <code>-DDEBUG</code> 得到的结果 (是否有<code>myfunc</code>) 也不一样。</p>
<blockquote>
<p>其他的预处理指令还包括 pragma、 line 等，这里就不详细说明了</p>
</blockquote>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译阶段，主要将扩展的源码文件如<code>filename.i</code> 编译成汇编文件<code>filename.s</code>。其中又分为三个主要步骤：</p>
<ul>
<li><p>Lexical Analysis / tokenization 词法分析。</p>
<p>主要就是将输入的源码文件从左到右逐个字符(character)的分析，划分成不同的 token：symbols, numbers, identifiers, strings, operators 等。下面看个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    a = b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过词法分析，会产生以下 token</span></span><br><span class="line">Scanner production:</span><br><span class="line">[Keyword(Int), Id(<span class="string">"main"</span>), Symbol(LParen), Symbol(RParen), Symbol(LBrace), Keyword(Int), Id(<span class="string">"a"</span>), Symbol(Semicolon), Keyword(Int), Id(<span class="string">"b"</span>), Symbol(Semicolon), Id(<span class="string">"a"</span>), Operator(Assignment), Id(<span class="string">"b"</span>),</span><br><span class="line">Operator(Assignment), Integer(<span class="number">4</span>), Symbol(Semicolon), Keyword(Return), Id(<span class="string">"a"</span>), Operator(Minus), Id(<span class="string">"b"</span>), Symbol(Semicolon), Symbol(RBrace)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Parsing 语法解析。</p>
<p>该过程是将上面词法分析产生的 tokens 进行匹配，看是否符合特定的模式：如函数调用、变量赋值、数学运算、表达式求值等等。最终，语法分析会产生一种称为 AST (abstract syntax tree) 的语法树结构。</p>
<p><img src="/images/image-20181217144627779.png" alt="image-20181217144627779"></p>
<p>上面就是 <code>12 + 3</code> 对应的AST结构</p>
<p><img src="/images/image-20181216215749680.png" alt="image-20181216215749680"></p>
<p>上面是 C 代码 <code>if(net&gt;0.0)total+=net*(1.0+tax/100.0);</code> 经过词法分析和语法分析生成的AST 结构</p>
</li>
<li><p>Code generator 代码生成。</p>
<p>代码生成的主要任务，就是将上述的中间结果即 AST 树结构转换成一行行线性的机器指令。包括</p>
<ul>
<li><p>选用什么样的指令。通过对 AST 树执行后续遍历 (postorder traversal) 依次选用指令。例如，对于 AST <code>W := ADD(X,MUL(Y,Z))</code> ，根是 <code>ADD</code> ，左右节点分别是 <code>X</code> 和 <code>MUL(Y,Z)</code>，指令会是 <code>t1 := X</code> 和 <code>t2 := MUL(Y,Z)</code> ，最后是 <code>ADD W, t1, t2</code></p>
</li>
<li><p>安排指令顺序。由于CPU流水线机制，可能会有乱序执行以提高代码执行效率。</p>
</li>
<li><p>变量的寄存器分配</p>
</li>
<li><p>调试代码生成</p>
</li>
</ul>
<p>此外它还会对生成的指令进行一定的优化。</p>
</li>
</ul>
<p>很多情况下，代码生成的机器指令为汇编代码，包含了很多汇编指令。</p>
<p>下面是 <code>filename.c</code> 编译生成的汇编指令代码 <code>filename.s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  1     .file   &quot;filename.c&quot;</span><br><span class="line">  2     .section    .rodata</span><br><span class="line">  3 .LC0:</span><br><span class="line">  4     .string &quot;DEBUG defined&quot;</span><br><span class="line">  5     .text</span><br><span class="line">  6 .globl myfunc</span><br><span class="line">  7     .type   myfunc, @function</span><br><span class="line">  8 myfunc:</span><br><span class="line">  9 .LFB0:</span><br><span class="line"> 10     .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16 </span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    call    puts</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret </span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   myfunc, .-myfunc</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC1:</span><br><span class="line">    .string &quot;addition is: %d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">.globl main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16 </span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $5, -8(%rbp)</span><br><span class="line">    movl    $4, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    -8(%rbp), %edx</span><br><span class="line">    addl    %eax, %edx</span><br><span class="line">    movl    $.LC1, %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret </span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-17)&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>编译过程还可以被分为 前端、后端，前端包括前面提到的词法分析、语法分析，生成 AST 结构；后端指代码生成，输入是 AST，输出机器指令代码或者汇编代码。其实，前后端中间还有个中端，做些优化的工作。</p>
<p>前后端的工作是独立的，互相不依赖。对于不同的语言，编译器可能使用不同类型的前端来生成 AST，而后端其输入只要求是AST，因此可以复用。举例来说，对于知名编译器 GCC (the GNU Compiler Collection)，其不同的前端可以编译 <code>C,C++,Objective-C,Fortran,Ada,Go,D</code> 成 AST，而通过统一的后端将 AST 转换成汇编代码。</p>
<p>编译的整个过程用一张图来表示就是</p>
<p><img src="/images/image-20181217143846903.png" alt="image-20181217143846903"></p>
<h2 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(<strong>Assembly</strong>)</h2><p>该过程通过调度汇编器(as)来完成，将汇编指令文件<code>filename.s</code> 翻译成与处理器结构有关的机器指令文件<code>filename.o</code>，这是一个二进制文件，不能直接查看，用 <code>file</code> 命令查看可知</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file filename.o </span><br><span class="line">filename.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure>
<p>这一个64位 <code>ELF</code> 文件，可以使用 <code>objdump -x</code> 命令来查看所有文件头，包含符号表和重定位信息等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -x filename.o</span><br><span class="line"></span><br><span class="line">filename.o:     file format elf64-x86-64</span><br><span class="line">filename.o</span><br><span class="line">architecture: i386:x86-64, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x0000000000000000</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000049  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       0000001f  0000000000000000  0000000000000000  0000008c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002e  0000000000000000  0000000000000000  000000ab  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d9  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000e0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 filename.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     F .text	0000000000000010 myfunc</span><br><span class="line">0000000000000000         *UND*	0000000000000000 puts</span><br><span class="line">0000000000000010 g     F .text	0000000000000039 main</span><br><span class="line">0000000000000000         *UND*	0000000000000000 <span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line">000000000000002f R_X86_64_32       .rodata+0x000000000000000e</span><br><span class="line">000000000000003e R_X86_64_PC32     <span class="built_in">printf</span>-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br><span class="line">0000000000000040 R_X86_64_PC32     .text+0x0000000000000010</span><br></pre></td></tr></table></figure>
<p>上面符号表里的 <code>text</code> 表示在代码段找到了定义，而有 <code>UND</code> 标识的 <code>puts</code>函数和<code>printf</code>函数因为属于库函数，尚未链接进来，因此属于未定义。</p>
<p>上面的<code>filename.o</code> 文件虽然是二进制指令文件，但是还不能被执行。最终的可执行文件还要经过下面的链接过程。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>该阶段由编译器驱动程序驱动链接器 linker 来完成。linker 只和平台有关，是不同操作系统下的工具程序。对于windows平台，linker.exe 是链接器 (集成在Visual Studio中)，它将多个<code>.obj</code>文件和库文件一起链接成 <code>.exe</code>可执行文件或库文件；对于 linux 和 mac 平台，ld (也是GNU出品) 是链接器，它将多个 <code>.o</code> 文件和库文件一起链接成二进制可执行文件或库文件。</p>
<p>链接器的工作主要包含：地址和空间分配（<code>Address and Storage Allocation</code>），符号决议（<code>Symbol Resolution</code>），重定位（<code>Relocation</code>）等。</p>
<p><img src="/images/image-20181217141632692.png" alt="image-20181217141632692"></p>
<p>链接主要分为动态连接和静态链接。对于静态链接，linker 会将静态库的代码直接加到可执行文件中，因此文件大小比较大。而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</p>
<p>GCC 默认使用动态链接方式链接库文件。对比目标文件<code>filename.o</code> 和我们链接完成的可执行文件 <code>filename</code>大小可知，<code>text</code> 部分增加的大小为必要的描述信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ size filename.o</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">    192	      0	      0	    192	     c0	filename.o</span><br><span class="line">$ size filename</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">   1319	    500	     16	   1835	    72b	filename</span><br></pre></td></tr></table></figure>
<p>再看<code>file</code>命令的输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file filename</span><br><span class="line">filename: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.18, not stripped</span><br></pre></td></tr></table></figure>
<p>可见与上面的<code>filename.o</code>不同的是该文件已经链接(GCC 默认动态连接 Linux 的 c 运行时库 libc.so.6，即 glibc )</p>
<p>此外，利用 ldd 命令可以看到可执行程序依赖的动态链接库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ldd -v filename</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007fff36f24000)</span><br><span class="line">	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8f61001000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f8f613a0000)</span><br><span class="line"></span><br><span class="line">	Version information:</span><br><span class="line">	./filename:</span><br><span class="line">		libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6</span><br><span class="line">	/lib64/libc.so.6:</span><br><span class="line">		ld-linux-x86-64.so.2 (GLIBC_PRIVATE) =&gt; /lib64/ld-linux-x86-64.so.2</span><br><span class="line">		ld-linux-x86-64.so.2 (GLIBC_2.3) =&gt; /lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用一个图来表示整个编译的过程如下</p>
<p><img src="/images/image-20180821172053123.png" alt="image-20180821172053123"></p>
<p>参考资料</p>
<p>&lt;C专家编程&gt;</p>
<p><a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/" target="_blank" rel="noopener">Compiling a C program:- Behind the Scenes</a></p>
<p><a href="https://towardsdatascience.com/understanding-compilers-for-humans-version-2-157f0edb02dd" target="_blank" rel="noopener">Understanding Compilers — For Humans (Version 2)</a></p>
<p><a href="http://smilejay.com/2012/01/c_compilation_stages/" target="_blank" rel="noopener">C程序编译过程浅析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/GCC分支预测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/GCC分支预测/" itemprop="url">分支预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T18:01:28+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/20/GCC分支预测/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/20/GCC分支预测/" class="cy_cmt_count" data-xid="2018/08/20/GCC分支预测/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GCC-扩展-builtin-expect"><a href="#GCC-扩展-builtin-expect" class="headerlink" title="GCC 扩展 __builtin_expect"></a>GCC 扩展 __builtin_expect</h2><p>C 语言的标准从最开始的 K&amp;R C演变到目前的 ANSI C，在各操作系统平台已经有很多编译器支持了，如 MSVC、GCC、CLANG 等。而 linux 平台的 GCC 除了支持ANSI C 标准之外，还有自己的编译器扩展特性。</p>
<p>其中一个特性就是GCC 支持的编译器分支预测 __builtin_expect 宏，作为编译分支时候的暗示。这个特性在 linux 的内核代码中很常用，用来提升代码执行速度。</p>
<p>具体的，是有 likely 和 unlikely 这两个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>
<p>实际使用时，我们可以在很大可能执行的分支前面加上 likely。例如下例中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (likely(a))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hula!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Woo~\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，如果 likely 所在的分支如果有非常大可能执行，则程序运行效率要比普通的分支判断高。具体原因是什么呢？这就涉及到 CPU 流水线作业的相关知识。</p>
<h2 id="CPU-流水线"><a href="#CPU-流水线" class="headerlink" title="CPU 流水线"></a>CPU 流水线</h2><p>这里我们以 Intel 发明的 X86结构的 CPU 为例来大致讲述下 CPU 流水线技术的演进。</p>
<p>CPU 在执行程序的时候依赖于很多寄存器，例如通用寄存器、段寄存器、索引寄存器等。此外还有一个很重要的寄存器：指令指针(IP)。指令指针寄存器是一个拥有特殊功能的指针。指令指针的功能是指向将要运行的下一条指令。</p>
<p>所有的X86处理器都按照相同的模式运行。首先，根据指令指针指向的地址取得下一条即将运行的指令并解析该指令（译码）。在译码完成后，会有一个指令的执行阶段。有些指令用来从内存读取数据或者向内存写数据，有些指令用来执行计算或者比较等工作。当指令执行完成后，这条指令会通过退出(retire)阶段并将指令指针修改为下一条指令。</p>
<p>译码，执行和退出的分阶段模式组成了X86处理器指令执行的基本模式。从最初的8086处理器到新的酷睿i7处理器都基本遵循了这样的过程。</p>
<p>1989年 i486引入了五级流水线模式，分别是：取指(Fetch)，译码(D1, main decode)，转址(D2, translate)，执行(EX, execute)，写回(WB)。之前的三级模式，并不是流水线，每一条指令必须等待前一条指令执行完退出之后才能继续执行。而这种新引入的五级流水线模式，可以同时运行多条指令，每一级流水线在同一时刻都运行着不同的指令。这个设计使得i486比同频率的386处理器性能提升了不止一倍。五级流水线中的取指阶段(F)将指令从指令缓存中取出；第二级为译码阶段(D1)，将取出的指令翻译为具体的功能操作；第三级为转址阶段(D2)，用来将内存地址和偏移进行转换；第四级为执行阶段(EX)，指令在该阶段真正执行运算；第五级为退出阶段(WB)，运算的结果被写回寄存器或者内存。由于处理器同时运行了多条指令，大大提升了程序运行的性能。 </p>
<p><img src="/images/image-20180820190943347.png" alt="image-20180820190943347"></p>
<p>流水线化通过同时执行一系列操作增加了吞吐量(throughput)，但是她并没有减少延迟，即并没有减少一条指令从执行开始到执行结束的时间，仍要等到这一系列指令完成。实际上,流水线化由于将一条指令拆分成了几个步骤从而可能会增加延迟。</p>
<h2 id="CPU-分支猜测"><a href="#CPU-分支猜测" class="headerlink" title="CPU 分支猜测"></a>CPU 分支猜测</h2><p>流水线技术的主要目的就是通过重叠连续指令的步骤来提高吞吐量从而获得性能，要做到这一点，就必须能够实现确定要执行指令的序列和先后顺序，这样才能使流水线中充满了待执行的指令。当处理器遇到分支条件跳转时，通常不能确定执行那个分支，因此处理器采用分支预测器来猜测每条跳转指令是否会执行。如果猜测比较可靠，那么流水线中就会充满指令。但是，如果对跳转的指令猜测错误，那么就要要求处理器丢掉它这个跳转指令后的所有已做的操作，然后再开始用从正确位置处起始的指令去填充流水线，可以看到这种预测错误会导致很严重的性能惩罚，会导致大约20-40个时钟周期的浪费，从而导致性能的严重下降。</p>
<p>一个很直观的说明 CPU 的分支预测器的例子是 stackoverflow 上的提问： <a href="http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array" target="_blank" rel="noopener">Why is processing a sorted array faster than an unsorted array?</a> </p>
<p>一段排序和未排序过的代码执行速度差别很大，具体代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// generate data</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> arraySize = <span class="number">32768</span>;</span><br><span class="line">    <span class="keyword">int</span> data[arraySize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">        data[c] = <span class="built_in">std</span>::rand() % <span class="number">256</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序这行不注释掉下面的for循环会快得多</span></span><br><span class="line">    <span class="built_in">std</span>::sort(data, data + arraySize); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// primary loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">                sum += data[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> elapsedTime = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(clock() - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elapsedTime &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在我的 Mac 上运行的结果分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 未排序</span><br><span class="line">21.3109</span><br><span class="line">sum = 312426300000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 排序后</span><br><span class="line">6.30532</span><br><span class="line">sum = 312426300000</span><br></pre></td></tr></table></figure>
<p>这里影响代码执行的主要片段是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">    sum += data[c];</span><br></pre></td></tr></table></figure>
<p>对于这段分支代码的执行，CPU 会启用分支预测(branch prediction)，排序和未排序的不同正是分支预测是否有大概率命中。对于命中的情况，CPU 指令可以一路顺畅的执行；而对于预测失败的情况，处理器要flush掉pipelines，回滚到之前的分支，然后重新热启动，选择另一条路径，这里的性能损失非常大。</p>
<p>那么一般怎么做分支预测呢？答案就是根据历史结果来做决定。对于排序的情况，很容易根据历史结果做出决策:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = branch taken</span><br><span class="line">N = branch not taken</span><br><span class="line"></span><br><span class="line">data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...</span><br><span class="line">branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...</span><br><span class="line"></span><br><span class="line">       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)</span><br></pre></td></tr></table></figure>
<p>而如果未排序的数组，则其取到的结果完全随机，分支预测基本无效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...</span><br><span class="line">branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...</span><br><span class="line"></span><br><span class="line">       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)</span><br></pre></td></tr></table></figure>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面说的 CPU 分支预测是属于硬件层面，其实从上层的软件或者程序员角度也是可以协助做好分支预测的。还是回到我们最开始提到的__builtin_expect 宏，示例代码反汇编得到的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.LC1:</span><br><span class="line">    .string &quot;Hula!&quot;</span><br><span class="line">.LC2:</span><br><span class="line">    .string &quot;Woo~&quot;</span><br><span class="line"> </span><br><span class="line">    call    __isoc99_scanf</span><br><span class="line">    movl    28(%esp), %eax</span><br><span class="line">    testl   %eax, %eax</span><br><span class="line">    je  .L2</span><br><span class="line">    movl    $.LC1, (%esp)</span><br><span class="line">    call    puts</span><br><span class="line">.L3:</span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.L2:</span><br><span class="line">    movl    $.LC2, (%esp)</span><br><span class="line">    call    puts</span><br><span class="line">    jmp .L3</span><br></pre></td></tr></table></figure>
<p>对于使用了 likely 的分支，其指令将更靠近 <code>testl</code> 分支判断，CPU 在执行分支判断指令的同时，将预先取出后续指令进行执行，而另一个分支指令则需要进行跳转(<code>je .L2</code>)。其本质是优化 CPU 的指令顺序，提高流水线的执行效率。</p>
<p>此外，编写代码时，我们也要注意分支的先后顺序，尽量将概率大的分支放在前面，尽量合并分支，尽量使用排序后的数据来判断，适当使用 goto 和 do while 来优化代码组织等。</p>
<p>参考资料</p>
<p><a href="http://blog.jobbole.com/40844/" target="_blank" rel="noopener">CPU流水线的探秘之旅</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22469702" target="_blank" rel="noopener">深入理解CPU的分支预测(Branch Prediction)模型</a></p>
<p><a href="https://www.zhihu.com/question/27650017" target="_blank" rel="noopener">如何在 C++ 代码中提示编译器某个分支的执行概率高？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/无锁队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/无锁队列/" itemprop="url">无锁队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T12:51:37+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/14/无锁队列/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/14/无锁队列/" class="cy_cmt_count" data-xid="2018/08/14/无锁队列/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>无锁队列是一种广泛使用的数据结构</p>
<h2 id="单读单写"><a href="#单读单写" class="headerlink" title="单读单写"></a>单读单写</h2><p>我们先看下最简单的一种情况，就是一个生产者负责写，一个消费者负责读的情况。</p>
<p>这种情况通常是利用环形缓冲区 RingBuffer （有时候也称为 circular queue）来实现，那首先看看 RingBuffer 是怎么实现读写的。</p>
<p><img src="/images/image-20180830113817331.png" alt="image-20180830113817331"></p>
<h5 id="RingBuffer-实现"><a href="#RingBuffer-实现" class="headerlink" title="RingBuffer 实现"></a>RingBuffer 实现</h5><p>一个数组buff，大小是 SIZE，两个指针变量 head 和 tail 来表示队列的头和尾。写的时候，控制 tail 加1；读的时候，控制 head 加1。</p>
<ul>
<li>初始状态，数组为空，tail 和 head 都为 0</li>
<li>写入元素时，tail 加1向后更新</li>
<li>读取元素时，head 加1向后更新</li>
<li>由于数组大小size有限，tail 或者 head指针不能永远向后增加，当到达数组尾部（指向<code>size-1</code>）的时候，需要绕回到数组开头，实现的时候使用 <code>val = (val + 1) % size</code> 取余即可</li>
<li>绕回的机制正是环形缓冲的特色，因此 head 和 tail 的前后关系可能会一直变化</li>
<li>队列为空时，读取失败，此时 head 和 tail 相等</li>
<li>队列满时，写入失败，规定如果 tail + 1后，做可能的回绕，然后检查 tail 和head 是否相等，如果相等则满。这种约定浪费了一个元素的位置不让写入，从而保证写满时，head 和 tail差一个元素而不是相等，和队列为空的情况区分开来。此时的情况是可能是<ol>
<li>tail 在前，head 在后且为 0， tail - head = size - 1 ，此时队列里除最后一个元素外全满，tail + 1 回绕后和head 都为 0</li>
<li>head 在前，tail 在后，且 head - tail = 1，tail 加1后和 head 相等</li>
</ol>
</li>
</ul>
<p>PUSH</p>
<p><img src="/images/image-20180830140357796.png" alt="image-20180830140357796"></p>
<p>POP</p>
<p><img src="/images/image-20180830140426815.png" alt="image-20180830140426815"></p>
<p>EMPTY</p>
<p><img src="/images/image-20180830140237745.png" alt="image-20180830140237745"></p>
<p>FULL</p>
<p><img src="/images/image-20180830140102099.png" alt="image-20180830140102099"></p>
<p>下面看下实现代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_RING_BUFFER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_RING_BUFFER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    RingBuffer() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RingBuffer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(_tail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[_tail] = item;</span><br><span class="line">        _tail = nextTail;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[_head];</span><br><span class="line">        _head = increment(_head);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _tail;</span><br><span class="line">    <span class="keyword">int</span> _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_RING_BUFFER_H_</span></span></span><br></pre></td></tr></table></figure>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>现在回到初始的单读单写的情况，生产者调用 push() 来唯一控制 tail 的更新，而消费者调用 pop() 来唯一控制 head 的更新。<br>实际实现时，通常分步，写入（或读取）缓冲区内容，更新指针。我们要保证：</p>
<ul>
<li>对 tail 和 head 指针的更新必须是原子的</li>
<li>读的时候，先读取缓冲区内容，再更新 head</li>
<li>写的时候，先写入内容到缓冲区，再更新 tail</li>
</ul>
<p>关于 int 类型赋值的原子性，C++ 标准是没有定义的，依赖于编译器的实现和系统架构的内存对齐策略等。</p>
<p>根据 <a href="https://www.codeproject.com/script/Membership/View.aspx?mid=4385931" target="_blank" rel="noopener">KjellKod.cc</a> 的文章的说法，大部分现代处理器上，对于自然对齐的基础类型的读写是原子的，不会出现读一半或者写一半的情况。对于 x86 和 x64 平台，长度大于8的类型，其读写不保证是原子的。而对于我们的 head 和 tail，在 32 位处理器和 64 位处理器上大小分别是 4 和 8 (注：int 的大小和平台和编译器实现有关，这里说法不准) ，因此可以保证是原子的。其英文原话是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">On almost all modern processors, reads and writes of naturally aligned native types are atomic. This means that as long as the memory bus is at least as wide as the type being read or written the CPU reads and writes will happen in a single bus transaction. This makes it impossible for other threads to see them half-completed.</span><br><span class="line"></span><br><span class="line">For x86 and x64 platforms, types larger than 8 bytes are not guaranteed to be atomic. But in our example the head and tail indexes are integers of size 32bits (4 bytes) on 32-bit processor or 64bits (8bytes) on a 64-bit processor, thus making reading and writing them atomic.</span><br><span class="line"></span><br><span class="line">// Example of integers</span><br><span class="line">counter++;                // 1. not atomic operation, but three operations</span><br><span class="line">counter = 0;              // 2. this write is atomic</span><br><span class="line">other_variable = counter; // 3. this read is atomic</span><br><span class="line"></span><br><span class="line">For fun, you can compile the operations above to assembly language or use the debugger to view the disassembly. You should then see that the actual store only takes one instruction.</span><br><span class="line"></span><br><span class="line">On multiple core CPUs, this is also true. A word in memory must be coherent between all cores when it is written (using one CPU instruction). It is simply not allowed or even possible to split a 4 byte writing (I use a 32-bit example) between cores, since a word (4 bytes) is written as a single instruction.</span><br><span class="line"></span><br><span class="line">In short. Reads and writes of tail and head are atomic. First is still OK.</span><br></pre></td></tr></table></figure>
<p>保险的措施是使用c++11中的 <code>std::atomic</code> 来保证原子性。我们修改下 head 和 tail 定义后的 ssqueue 结构(single producer &amp; single consumer queue) 如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    SSQueue() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~SSQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currTail = _tail.load();</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(currTail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head.load()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[currTail] = item;</span><br><span class="line">        _tail.store(nextTail);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currHead = _head.load();</span><br><span class="line">        <span class="keyword">if</span> (currHead == _tail.load()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[currHead];</span><br><span class="line">        _head.store(increment(currHead));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _tail;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_SSQUEUE_H_</span></span></span><br></pre></td></tr></table></figure>
<h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><p>由于都是分步执行，中间有可能被打断。但是只要保证了读写缓冲区的和更新指针的顺序，就能保证无锁的安全性。</p>
<p>现在来分析一下打断的情况：<br>假如读的时候，消费者先读取了缓冲区内容，而未来得及更新 head，执行权就被生产者抢占，于是生产者读的 head 就是老的，类似快照数据。但这并没有太大影响，顶多是极端情况下由于没有更新head 导致生产者认为队列满而写入失败，下次继续写就可以了；如果队列没满，写入不受影响。<br>同样的道理，假如写的时候，生产者先写入内容到缓冲区(也可能是写一部分)，而未来得及更新 tail，执行权就被消费者抢占，于是消费者读到的 tail 也是老的。这也没有多大影响，顶多是极端情况下由于没有更新tail导致消费者认为队列空而读取失败，下次继续读就读到数据了；如果队列非空，读取不受影响。</p>
<p>这里特别注意的是，head 和 tail 指针永远只由一方来更新，且是单方向更新。</p>
<p>那是不是代码里先写缓冲区操作，再写更新指针操作就可以了呢？答案是否。</p>
<p>编译器优化我们的代码时，可能会改变代码的执行顺序，反应在汇编指令的前后顺序调整。这是编译时乱序。</p>
<p>上面提到的利用 volatile 修饰的 int 变量，vs 和 gcc 编译器似乎都能保证其汇编指令顺序，但是没有得到权威的资料证明 (<a href="https://blog.csdn.net/xtlisk/article/details/39098981" target="_blank" rel="noopener">查看</a>)</p>
<p>此外，由于现代CPU普遍采用了多级流水线技术，一条指令的执行是多级流水线协同完成。为了提高执行效率，可以同时执行多条指令；而且随着分支预测和乱序执行的引入，互不依赖的两条指令在执行时是不保证先后顺序的，这是运行时乱序。</p>
<p>编译器开发者和cpu厂商都遵守着内存乱序的基本原则，简单归纳如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能改变单线程程序的行为</span><br></pre></td></tr></table></figure>
<p>在单线程环境，我们不必关心内存乱序的影响。而此时，我们关注的恰恰是多线程执行的情况，如何保证我们代码的顺序执行就是需要解决的关键问题。</p>
<p>一种方式是依赖 <code>volatile int</code> 的一种实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>这里特别指出，volatile 关键字语义上只是提示编译器不要优化该变量，本质上和顺序执行没有任何关系。有说法是 volatile 的使用保证读写变量时其汇编指令顺序不会变更，但是没有可靠依据。</p>
<p>而对于执行乱序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU Reordering Summary for x86 and x64 Platforms</span><br><span class="line"></span><br><span class="line">1. Reads moving ahead of other reads: No</span><br><span class="line">2. Writes moving ahead of other writes: No</span><br><span class="line">3. Writes moving ahead of reads: No</span><br><span class="line">4. Reads moving ahead of writes: Yes</span><br></pre></td></tr></table></figure>
<p>由 2、3 两条保证了写的顺序不被置于读之前，且写之间顺序不乱。</p>
<p>同样，保险的方式还是使用平台无关的机制：c++11提供的内存屏障。</p>
<h5 id="Acquire-Release-内存屏障代码"><a href="#Acquire-Release-内存屏障代码" class="headerlink" title="Acquire-Release 内存屏障代码"></a>Acquire-Release 内存屏障代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    SSQueue() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~SSQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currTail = _tail.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(currTail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[currTail] = item;</span><br><span class="line">        _tail.store(nextTail, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currHead = _head.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (currHead == _tail.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[currHead];</span><br><span class="line">        _head.store(increment(currHead), <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _tail;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_SSQUEUE_H_</span></span></span><br></pre></td></tr></table></figure>
<p><a href="http://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/" target="_blank" rel="noopener">http://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/</a></p>
<h2 id="多读多写"><a href="#多读多写" class="headerlink" title="多读多写"></a>多读多写</h2><p>如果情况扩展到多读多写的情况，我们就不能像上面这样来实现了。必须要借助 CPU 提供的 CAS 操作指令。</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>Compare &amp; Set，或是 Compare &amp; Swap，<strong>现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。</strong>有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。</p>
<p>维基百科是这么说的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In computer science, compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization. It compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail. The result of the operation must indicate whether it performed the substitution; this can be done either with a simple boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).</span><br><span class="line">Algorithms built around CAS typically read some key memory location and remember the old value. Based on that old value, they compute some new value. Then they try to swap in the new value using CAS, where the comparison checks for the location still being equal to the old value. If CAS indicates that the attempt has failed, it has to be repeated from the beginning: the location is re-read, a new value is re-computed and the CAS is tried again.</span><br></pre></td></tr></table></figure>
<p>使用 c 代码形象的来表示这个操作就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *accum, <span class="keyword">int</span> *dest, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*accum == *dest) &#123;</span><br><span class="line">      *dest = newval;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *accum = *dest;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将变量值 <em>accum 与 </em>dest 进行 compare，如果相等则进行 Swap/Set。如果不相等，则返回一个标识值。上层需要重复调用该 CAS 操作，直到操作成功。</p>
<h5 id="C-中使用-CAS"><a href="#C-中使用-CAS" class="headerlink" title="C 中使用 CAS"></a>C 中使用 CAS</h5><p>C 语言中使用 CAS，可以使用</p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision" target="_blank" rel="noopener">C11</a>) <code>&lt;stdatomic.h&gt;</code> 里的一系列函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_<span class="function">Bool <span class="title">atomic_compare_exchange_strong</span><span class="params">( <span class="keyword">volatile</span> A* obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      C* expected, C desired )</span></span>;</span><br><span class="line">_<span class="function">Bool <span class="title">atomic_compare_exchange_weak</span><span class="params">( <span class="keyword">volatile</span> A *obj, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    C* expected, C desired )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特定编译器的非标准 C 扩展</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCC</span></span><br><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)	</span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows API</span></span><br><span class="line">InterlockedCompareExchange ( __inout LONG <span class="keyword">volatile</span> *Target,</span><br><span class="line">                                __in LONG Exchange,</span><br><span class="line">                                __in LONG Comperand);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接调用<code>compare-and-swap</code> 汇编指令编写的函数。</p>
</li>
</ul>
<p>下面是使用链表实现的基于 CAS 操作的无锁队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EnQueue(x) <span class="comment">//进队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//准备新加入的结点数据</span></span><br><span class="line">    q = <span class="keyword">new</span> record();</span><br><span class="line">    q-&gt;value = x;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p = tail; <span class="comment">//取链表尾指针的快照</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(CAS(p-&gt;next, <span class="literal">NULL</span>, q) != TRUE); <span class="comment">//如果没有把结点链在尾指针上，再试</span></span><br><span class="line"> </span><br><span class="line">    CAS(tail, p, q); <span class="comment">//置尾结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeQueue() <span class="comment">//出队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_EMPTY_QUEUE;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>( CAS(head, p, p-&gt;next) != TRUE );</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>所谓ABA（<a href="http://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="noopener">见维基百科的ABA词条</a>），问题基本是这个样子：</p>
<ol>
<li>进程P1在共享变量中读到值为A</li>
<li>P1被抢占了，进程P2执行</li>
<li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li>
<li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li>
</ol>
<p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的地址。如果这个地址被重用了呢，问题就很大了。</strong>（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址）</p>
<p>比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被DeQueue() 然后回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（<strong>内存管理中重用内存基本上是一种很常见的行为</strong>）</p>
<p>维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容</p>
<p>1）一次用CAS检查双倍长度的值，前半部是指针，后半部分是一个计数器。</p>
<p>2）只有这两个都一样，才算通过检查。然后把指针赋新的值，并把计数器累加1。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><p>无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。</p>
</li>
<li><p>对于Retry-Loop，其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。</p>
</li>
</ol>
<p>参考资料</p>
<p><a href="https://sites.google.com/site/kjellhedstrom2/threadsafecircularqueue" target="_blank" rel="noopener">Lock-Free Single Producer - Single Consumer Circular Queue 1</a></p>
<p><a href="https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular" target="_blank" rel="noopener">Lock-Free Single-Producer - Single Consumer Circular Queue 2</a></p>
<p><a href="https://blog.csdn.net/xtlisk/article/details/39098981" target="_blank" rel="noopener">无锁环形队列，volatile和乱序执行</a></p>
<p><a href="http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484" target="_blank" rel="noopener">volatile vs. volatile</a></p>
<p><a href="https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword-in-c" target="_blank" rel="noopener">Why do we use volatile keyword in C++?</a></p>
<p><a href="http://lday.me/2017/12/02/0018_cpp_atomic_summary/" target="_blank" rel="noopener">C++内存屏障（内存顺序）总结</a></p>
<p><a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/" target="_blank" rel="noopener">Memory Barriers Are Like Source Control Operations</a></p>
<p><a href="https://coolshell.cn/articles/8239.html" target="_blank" rel="noopener">无锁队列的实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/tcp-ip备忘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/tcp-ip备忘/" itemprop="url">tcp/ip备忘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T13:11:03+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/13/tcp-ip备忘/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/13/tcp-ip备忘/" class="cy_cmt_count" data-xid="2018/08/13/tcp-ip备忘/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">philipyao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/philipyao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sjtutrume@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">philipyao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div style="text-align:center;width:100%;height:50">
   备案号：沪ICP备17048801号
<div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytDLaiT8"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
