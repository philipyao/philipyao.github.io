<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="PHILIP x BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PHILIP x BLOG">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHILIP x BLOG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>PHILIP x BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PHILIP x BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心有猛虎，细嗅蔷薇</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/Go研究之channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/Go研究之channel/" itemprop="url">Go研究之channel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T20:43:35+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/12/13/Go研究之channel/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/12/13/Go研究之channel/" class="cy_cmt_count" data-xid="2018/12/13/Go研究之channel/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h2><p>CSP，全称 <code>Communicating sequential processes</code> 是指并发系统中的一种模式。简单来说，CSP 模型由并发执行的实体（线程或者进程或其他）所组成，实体之间通过消息进行通信。Go语言的并发特性正是基于CSP模型发展而来，具体来说，goroutine 就是并发执行的实体，而 goroutine 之前通信就是借助了 channel 来进行消息传递。Go语言有一种哲学叫做</p>
<p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p>
<p>意思是尽量通过通信来共享内存，而不是通过共享内存来通信。由此可见 channel 在 Go 中的重要地位。</p>
<h2 id="Go的channel"><a href="#Go的channel" class="headerlink" title="Go的channel"></a>Go的channel</h2><p>通常的线程模型，一个很重要的问题就是各线程之前的同步。我们通常采用条件变量或者信号量来做同步操作，如果需要传递消息，经常要自己实现一个带锁的线程安全的消息队列。</p>
<p>而在Go中，为了方便 goroutine 之前的通信，原生支持了一种称为 channel 的数据结构，用来做同步和消息传递。它的常用操作如下：</p>
<p>创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unBufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// 无缓冲</span></span><br><span class="line">bufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, N) <span class="comment">// 带缓冲</span></span><br></pre></td></tr></table></figure>
<p>读写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞读操作</span></span><br><span class="line">x := &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞写操作</span></span><br><span class="line">ch &lt;- x</span><br></pre></td></tr></table></figure>
<p>关闭</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>select (类似IO多路复用)，只要其中一个满足，则执行后续操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作都是阻塞的，同时 channel 也支持非阻塞的读写操作，类似于 IO 操作中如果没有满足条件的则返回 EAGAIN 或者 EWOULDBLOCK。这需要借助 select 的 default 分支来实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e := &lt;-ch:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的非阻塞操作，如果 ch 中没有读取到数据，也不会阻塞，而是进入default分支。类似的还有非阻塞写，这里就不具体说明了。</p>
<h2 id="Channel的实现原理"><a href="#Channel的实现原理" class="headerlink" title="Channel的实现原理"></a>Channel的实现原理</h2><p>下面以 Go1.8 的源码为例来研究下 channel 各个操作的实现原理。</p>
<h3 id="channel-结构"><a href="#channel-结构" class="headerlink" title="channel 结构"></a>channel 结构</h3><p>hchan 结构用来表示一个channel，具体信息如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudog is necessary because the g ↔ synchronization object relation</span></span><br><span class="line"><span class="comment">// is many-to-many. A g can be on many wait lists, so there may be</span></span><br><span class="line"><span class="comment">// many sudogs for one g; and many gs may be waiting on the same</span></span><br><span class="line"><span class="comment">// synchronization object, so there may be many sudogs for one object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this.</span></span><br><span class="line"></span><br><span class="line">	g          *g</span><br><span class="line">	selectdone *<span class="keyword">uint32</span> <span class="comment">// CAS to 1 to win select race (may point to stack)</span></span><br><span class="line">	next       *sudog</span><br><span class="line">	prev       *sudog</span><br><span class="line">	elem       unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// waitlink is only accessed by g.</span></span><br><span class="line"></span><br><span class="line">	acquiretime <span class="keyword">int64</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">	ticket      <span class="keyword">uint32</span></span><br><span class="line">	waitlink    *sudog <span class="comment">// g.waiting list</span></span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，hchan主要包含</p>
<ul>
<li><p>环形队列，用来存放消息(只针对带缓冲channel)。涉及的字段有</p>
<ul>
<li><p><code>qcount</code> 当前队列中的消息数量</p>
</li>
<li><p><code>dataqsiz</code> 队列大小</p>
</li>
<li><p><code>buf</code> 队列具体数据buf</p>
</li>
<li><p><code>sendx</code>、<code>recvx</code> 环形队列的发送和接收游标</p>
</li>
</ul>
</li>
<li>元素信息 <code>elemtype</code> 、<code>elemsize</code>。其中<code>elemtype</code> 的类型 <code>_type</code> 是 Go 中表示变量类型的基础结构，在反射和interface 的实现中很常用。因为 channel 可以持有各种类型的数据，所以需要维护元素信息。</li>
<li>lock，用来做并发互斥。</li>
<li>等待接收或等待发送的 goroutine 队列。<code>recvq</code> 和 <code>sendq</code> 都是用双向链表实现的队列，如果有 goroutine 因为读写被阻塞，就会被调度器挂起在这两个队列上。我们之前分析 Go 调度模型GMP的时候有提到，一般 G (goroutine) 和 P (proc) 挂钩，处于等待执行或者正在执行状态。如果正在执行的 G 阻塞在 channel 上，就会脱离 P，转而挂起在 channel 的<code>recvq</code> 或者 <code>sendq</code> 上，完成 channel 操作后再选择合适的 P 来继续执行。</li>
<li>closed。用来表示channel是否关闭。关闭 channel 可用用来实现广播的效果，后面会讲到。</li>
<li>sudog 代表一个goroutine</li>
</ul>
<h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>创建channel就是如何新建一个 hchan 结构的过程，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt; <span class="number">0</span> || <span class="keyword">int64</span>(<span class="keyword">uintptr</span>(size)) != size || (elem.size &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">uintptr</span>(size) &gt; (_MaxMem-hchanSize)/elem.size) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Allocate memory in one call.</span></span><br><span class="line">		<span class="comment">// Hchan does not contain pointers interesting for GC in this case:</span></span><br><span class="line">		<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">		<span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line">		<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"makechan: chan="</span>, c, <span class="string">"; elemsize="</span>, elem.size, <span class="string">"; elemalg="</span>, elem.alg, <span class="string">"; dataqsiz="</span>, size, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>元素大小不能超过64k(1&lt;&lt;16)</p>
</li>
<li><p>channel的元素个数不能为负数且不能超过一定数量</p>
</li>
<li><p>如果channel里存的是非指针的具体对象，则channel和具体存放的元素buf会一起分配，GC不会扫描这部分buf数据，因为buf相当于是channel的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Allocate memory in one call.</span></span><br><span class="line">    <span class="comment">// Hchan does not contain pointers interesting for GC in this case:</span></span><br><span class="line">    <span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">    <span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line">    <span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">    	c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">    	<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">    	c.buf = unsafe.Pointer(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>否则 buf 分开分配内存，可能会被GC 回收到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建完成后的结构，利用 gdb 调试时看到 hchan 的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">struct</span> runtime.hchan *) <span class="number">0xc420072000</span></span><br><span class="line">(gdb) p *c</span><br><span class="line">$<span class="number">2</span> = &#123;qcount = <span class="number">0</span>, dataqsiz = <span class="number">10</span>, buf = <span class="number">0xc420072060</span>, elemsize = <span class="number">8</span>, closed = <span class="number">0</span>, elemtype = <span class="number">0x1097040</span> &lt;<span class="keyword">type</span>.*+<span class="number">56064</span>&gt;, sendx = <span class="number">0</span>, recvx = <span class="number">0</span>, recvq = &#123;first = <span class="number">0x0</span>, last = <span class="number">0x0</span>&#125;, </span><br><span class="line">  sendq = &#123;first = <span class="number">0x0</span>, last = <span class="number">0x0</span>&#125;, lock = &#123;key = <span class="number">0</span>&#125;&#125;</span><br><span class="line">(gdb) p *c.elemtype</span><br><span class="line">$<span class="number">3</span> = &#123;size = <span class="number">8</span>, ptrdata = <span class="number">0</span>, hash = <span class="number">4149441018</span>, tflag = <span class="number">7</span> <span class="string">'\a'</span>, align = <span class="number">8</span> <span class="string">'\b'</span>, fieldalign = <span class="number">8</span> <span class="string">'\b'</span>, kind = <span class="number">130</span> <span class="string">'\202'</span>, alg = <span class="number">0x110bbf</span>0 &lt;runtime.algarray+<span class="number">80</span>&gt;, </span><br><span class="line">  gcdata = <span class="number">0x10bca3b</span> &lt;runtime.gcbits.*&gt; <span class="string">"\001\002\003\004\005\006\a\b\n\f\r\016\017\020\022\025\026\030\031\032\033\036\037,568&lt;ABUXr~\236\325\330\365\377\001\002\037\003%\004I\022U\001U\005U\025UUu\002y\001\224\a\230\a\230\177\330\003\340?\376\005\376!\377\377\001\016\034"</span>, str = <span class="number">955</span>, ptrToThis = <span class="number">37088</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 c 的内存地址和 buf 的内存地址是连续的。</p>
<p>如果创建的是指针类型 <code>channel</code>, <code>c</code> 的地址就和 <code>buf</code> 地址是分开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$1 = (struct runtime.hchan *) 0xc420068060</span><br><span class="line">(gdb) p *c</span><br><span class="line">$2 = &#123;qcount = 0, dataqsiz = 10, buf = 0xc420016140, elemsize = 8, closed = 0, elemtype = 0x1092500 &lt;type.*+37088&gt;, sendx = 0, recvx = 0, recvq = &#123;first = 0x0, last = 0x0&#125;, </span><br><span class="line">  sendq = &#123;first = 0x0, last = 0x0&#125;, lock = &#123;key = 0&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写channel"><a href="#写channel" class="headerlink" title="写channel"></a>写channel</h3><p>写对应的操作是 <code>ch &lt;- x</code>, 编译器编译后实际调用了以下源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry point for c &lt;- x from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chansend(t, c, elem, <span class="literal">true</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t.elem, ep, callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(ep, t.elem.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">	<span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">	<span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">	<span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">	<span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">	<span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">	<span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">	<span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">	<span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nil-channel"><a href="#nil-channel" class="headerlink" title="nil channel"></a>nil channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>nil channel</code>， 如果是非阻塞写，则会立即返回；如果是阻塞写，则当前 goroutine 会通过 <code>gopark</code>调用进入等待状态。</p>
<h5 id="closed-channel"><a href="#closed-channel" class="headerlink" title="closed channel"></a>closed channel</h5><p>写已经closed的channel会panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="recvq"><a href="#recvq" class="headerlink" title="recvq"></a>recvq</h5><p>如果 recvq 不为空，则表明有 goroutine 被挂起等待数据，此时即使是带缓冲的channel，也不会将数据存储到buf里，而是直接发给队列头的 goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">    <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">    send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据会从发送 goroutine 的栈上(ep)直接被拷贝到挂起的 sudog 的 数据域 elem 上，然后通过 goready 唤醒这个sudog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if sg.elem != nil &#123;</span><br><span class="line">    sendDirect(c.elemtype, sg, ep)</span><br><span class="line">    sg.elem = nil</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">if sg.releasetime != 0 &#123;</span><br><span class="line">	sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, 4)</span><br></pre></td></tr></table></figure>
<h5 id="buf-not-full"><a href="#buf-not-full" class="headerlink" title="buf not full"></a>buf not full</h5><p>如果没有等待接收者，且缓冲没满，则将数据拷贝到缓冲区中，这里就是简单的环形缓冲的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">    <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">    qp := chanbuf(c, c.sendx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">    c.sendx++</span><br><span class="line">    <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">        c.sendx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount++</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>chanbuf</code> 定位到具体数据 qp，然后将 ep 指向的数据拷贝到其中，同时更新游标 sendx 和 元素数量 qcount</p>
<h5 id="buf-full"><a href="#buf-full" class="headerlink" title="buf full"></a>buf full</h5><p>如果 buf 满了，对于非阻塞发送，就立即返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于阻塞发送，当前发送 goroutine 就被阻塞住挂起在等待队列里</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>待发送的数据 ep 被放置在 sudog 的 elem 上，sudog 本身入队到 sendq 中，并挂起。</p>
<h3 id="读channel"><a href="#读channel" class="headerlink" title="读channel"></a>读channel</h3><p>读对应的操作是 <code>x = &lt;- ch</code>, 编译器编译后实际调用了以下源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan receive (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">	<span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">	<span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">	<span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">	<span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">	<span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">	<span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan receive"</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ep 代表变量 x 指向的内存区，用来存储接收到的数据，如果 ep 为 nil，则读到的数据会被忽略</p>
<h5 id="nil-channel-1"><a href="#nil-channel-1" class="headerlink" title="nil channel"></a>nil channel</h5><p>对于未初始化的 channel，如果非阻塞读，则直接返回；如果是阻塞读，会通过 gopark 将当前 goroutine 转为等待状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan receive (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="closed-channel-1"><a href="#closed-channel-1" class="headerlink" title="closed channel"></a>closed channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于已经关闭的 channel，如果 buf 中没有数据了，则返回元素类型的零值 (通过 <code>typedmemclr</code> 来处理) </p>
<p>如果 buf 中还有数据，还是会继续走后续流程读取数据 (从挂起的 sender 中或者 buf 中)。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">ch &lt;- <span class="number">5</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭后，只要还有数据，会读到数据；也会返回标识告知channel是否被关闭</span></span><br><span class="line">data, isClosed := &lt;-ch</span><br><span class="line">log.Printf(<span class="string">"data:%d isClosed:%v"</span>, data, isClosed)</span><br><span class="line">log.Printf(<span class="string">"after closed data:%d %d"</span>, &lt;-ch, &lt;-ch)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    log.Printf(<span class="string">"range data:%d"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读完后，继续读取会返回零值</span></span><br><span class="line">data = &lt;- ch</span><br><span class="line">log.Printf(<span class="string">"continue read: data %d"</span>, data)</span><br></pre></td></tr></table></figure>
<p>输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:1 isClosed:true</span><br><span class="line">after closed data:2 3</span><br><span class="line">range data:4</span><br><span class="line">range data:5</span><br><span class="line">continue read: data 0</span><br></pre></td></tr></table></figure>
<h5 id="sendq"><a href="#sendq" class="headerlink" title="sendq"></a>sendq</h5><p>如果 sendq 有被挂起等待发送数据的 goroutine，则获取队头的 goroutine，调用 <code>recv</code> 进行处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>recv</code> 做的具体工作我们继续看下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racesync(c, sg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// copy data from sender</span></span><br><span class="line">        recvDirect(c.elemtype, sg, ep)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">    <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">    <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">    <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">        raceacquireg(sg.g, qp)</span><br><span class="line">        racereleaseg(sg.g, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from sender to queue</span></span><br><span class="line">    typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">    sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>如果 channel 是非缓冲的 (dataqsiz == 0)，则接收者直接从发送者手里接收数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racesync(c, sg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// copy data from sender</span></span><br><span class="line">        recvDirect(c.elemtype, sg, ep)</span><br><span class="line">    &#125; <span class="comment">// else 忽略数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 channel 是带缓冲的 (dataqsiz &gt; 0)，则表明此时 buf 已经满了，此时才会有等待发送的 goroutine 被挂起。需要做的事情就是从环形队列中读取一个元素，这时会空出一个元素的位置，之前挂起等待的队头 sudog 的数据就被写入环形队列。如果还有其他阻塞等待写的 sugog，继续挂起等待后续的读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">    <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">    <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">    <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">        raceacquireg(sg.g, qp)</span><br><span class="line">        racereleaseg(sg.g, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from sender to queue</span></span><br><span class="line">    typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完成之后，之前 sendq 中挂起的发送 goroutine 就被 <code>goready</code> 调用唤醒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">    sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h5 id="buf-not-empty"><a href="#buf-not-empty" class="headerlink" title="buf not empty"></a>buf not empty</h5><p>如果 buf 有数据，则直接将数据读出到 ep 内存处，然后将其置为零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//数据从qp读取到ep中</span></span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//置为零值</span></span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="buf-empty"><a href="#buf-empty" class="headerlink" title="buf empty"></a>buf empty</h5><p>如果 buf 中没有数据，对于非阻塞读取，立即返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于阻塞读，则当前读 goroutine 被挂起到 recvq 中等待后续数据写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan receive"</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="select-channel"><a href="#select-channel" class="headerlink" title="select channel"></a>select channel</h3><p>select 用于多个channel监听并收发消息，当任何一个case满足条件则会执行，若没有可执行的case，就会执行default，如果没有default，程序就会阻塞。select 的作用很类似于 IO多路复用。</p>
<h5 id="多-channel-select"><a href="#多-channel-select" class="headerlink" title="多 channel select"></a>多 channel select</h5><p>前面提到，典型的 select 用法是用在多个 channel 上，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">chs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;- ch:</span><br><span class="line">    fmt.Println(<span class="string">"received msg: "</span>, msg)</span><br><span class="line"><span class="keyword">case</span> msgs := &lt;- chs:</span><br><span class="line">    fmt.Println(<span class="string">"receied msgs: "</span>, msgs)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 的结构为 <code>hselect</code> ，其定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select statement header.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.</span></span><br><span class="line"><span class="keyword">type</span> hselect <span class="keyword">struct</span> &#123;</span><br><span class="line">	tcase     <span class="keyword">uint16</span>   <span class="comment">// total count of scase[]</span></span><br><span class="line">	ncase     <span class="keyword">uint16</span>   <span class="comment">// currently filled scase[]</span></span><br><span class="line">	pollorder *<span class="keyword">uint16</span>  <span class="comment">// case poll order</span></span><br><span class="line">	lockorder *<span class="keyword">uint16</span>  <span class="comment">// channel lock order</span></span><br><span class="line">	scase     [<span class="number">1</span>]scase <span class="comment">// one per case (in order of appearance)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select case descriptor.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	pc          <span class="keyword">uintptr</span>        <span class="comment">// return pc</span></span><br><span class="line">	kind        <span class="keyword">uint16</span></span><br><span class="line">	so          <span class="keyword">uint16</span> <span class="comment">// vararg of selected bool</span></span><br><span class="line">	receivedp   *<span class="keyword">bool</span>  <span class="comment">// pointer to received bool (recv2)</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其操作的具体源码实现是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectgoImpl(sel *hselect) (<span class="keyword">uintptr</span>, <span class="keyword">uint16</span>)</span><br></pre></td></tr></table></figure>
<p>select 的多个选项会被包装成多个<code>scase</code> 结构，然后依据 lockorder 来处获得所有锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">sellock(scases, lockorder)</span><br></pre></td></tr></table></figure>
<p><code>sellock</code> 是实现为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellock</span><span class="params">(scases []scase, lockorder []<span class="keyword">uint16</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		c0 := scases[o].c</span><br><span class="line">		<span class="keyword">if</span> c0 != <span class="literal">nil</span> &amp;&amp; c0 != c &#123;</span><br><span class="line">			c = c0</span><br><span class="line">			lock(&amp;c.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁会有去重判断，方式多个case 操作一个 channel 导致重复上锁问题。</p>
<p>然后依次查看所有的case是否有对应的事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sel.ncase); i++ &#123;</span><br><span class="line">    <span class="comment">//按照pollorder顺序来遍历</span></span><br><span class="line">    cas = &amp;scases[pollorder[i]]</span><br><span class="line">    c = cas.c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> caseRecv:</span><br><span class="line">        sg = c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> recv</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> bufrecv</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> rclose</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseSend:</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racereadpc(unsafe.Pointer(c), cas.pc, chansendpc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> sclose</span><br><span class="line">        &#125;</span><br><span class="line">        sg = c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> send</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">            <span class="keyword">goto</span> bufsend</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseDefault:</span><br><span class="line">        dfl = cas</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里遍历的时候并不是按照代码里 case 的顺序，而是按照 <code>pollorder</code> 来的，这个 <code>pollorder</code> 是随机出来的顺序，因此如果有多个满足条件的 case，则最终选中的 case 是哪一个是随机的。这样能避免一直选中写在前面的 case 而导致其他 case <strong>饿死</strong> 的情况。<code>pollorder</code> 通过以下代码随机洗牌而来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generate permuted order</span></span><br><span class="line">pollslice := slice&#123;unsafe.Pointer(sel.pollorder), <span class="keyword">int</span>(sel.ncase), <span class="keyword">int</span>(sel.ncase)&#125;</span><br><span class="line">pollorder := *(*[]<span class="keyword">uint16</span>)(unsafe.Pointer(&amp;pollslice))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="keyword">int</span>(sel.ncase); i++ &#123;</span><br><span class="line">    j := <span class="keyword">int</span>(fastrand()) % (i + <span class="number">1</span>)</span><br><span class="line">    pollorder[i] = pollorder[j]</span><br><span class="line">    pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果过程中遍历到的 case 有一个是非阻塞的操作，则 select 会立即返回，不会再去检查后续的 case 是否 ready；如果每个 case 对其 channel 的操作都是阻塞的且没有 default 分支，则 select 会一直阻塞，而且会挂起在涉及的所有的 channel 的 recvq 或者 sendq 上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">gp = getg()</span><br><span class="line">done = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nextp = &amp;gp.waiting</span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">    cas = &amp;scases[casei]</span><br><span class="line">    c = cas.c</span><br><span class="line">    sg := acquireSudog()</span><br><span class="line">    sg.g = gp</span><br><span class="line">    <span class="comment">// Note: selectdone is adjusted for stack copies in stack1.go:adjustsudogs</span></span><br><span class="line">    sg.selectdone = (*<span class="keyword">uint32</span>)(noescape(unsafe.Pointer(&amp;done)))</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">    <span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">    sg.elem = cas.elem</span><br><span class="line">    sg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.c = c</span><br><span class="line">    <span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">    *nextp = sg</span><br><span class="line">    nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> caseRecv:</span><br><span class="line">        c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseSend:</span><br><span class="line">        c.sendq.enqueue(sg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for someone to wake us up</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gopark(selparkcommit, <span class="literal">nil</span>, <span class="string">"select"</span>, traceEvGoBlockSelect, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="单-channel-非阻塞select"><a href="#单-channel-非阻塞select" class="headerlink" title="单 channel 非阻塞select"></a>单 channel 非阻塞select</h5><p>单 channel 的非阻塞 select 和前面多 channel 的select的实现机制不太一样，相对更简单，编译器会将其编译成 <code>chanrecv</code> 或者 <code>chansend</code> 调用</p>
<p>编译器会将以下非阻塞读取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- v:</span><br><span class="line">	... foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbsend(c, v) &#123;</span><br><span class="line">	... foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 非阻塞写的实现还是调用前面提到的 <code>chansend</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会将以下非阻塞写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;-c:</span><br><span class="line">	... foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, c) &#123;</span><br><span class="line">	... foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 非阻塞读的实现还是调用前面提到的 <code>chanrecv</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(t *chantype, elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	selected, _ = chanrecv(t, c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="close-channel"><a href="#close-channel" class="headerlink" title="close channel"></a>close channel</h3><p>close channel 的操作对应源码中的 <code>closechan</code> 调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;c))</span><br><span class="line">		racewritepc(unsafe.Pointer(c), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(unsafe.Pointer(c))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all readers</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all writers (they will panic)</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		gp := glist</span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nil-channel-2"><a href="#nil-channel-2" class="headerlink" title="nil channel"></a>nil channel</h5><p>如果关闭一个未初始化的 channel，会 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="closed-channel-2"><a href="#closed-channel-2" class="headerlink" title="closed channel"></a>closed channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭一个已经关闭的 channel 也会导致 panic。所以一般使用时，是由唯一的一个生产者来关闭 channel。</p>
<h5 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h5><p>正常关闭 channel 时，首先设置 closed 标识，然后将循环遍历，将 recvq 和 sendq 中挂起等待的 goroutine 收集到 glist 链表中等待调度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.schedlink.set(glist)</span><br><span class="line">    glist = gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.schedlink.set(glist)</span><br><span class="line">    glist = gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调度 glist 中的 goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line"><span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">    gp := glist</span><br><span class="line">    glist = glist.schedlink.ptr()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使 g 的状态切换到 Grunnable，交给调度器调度</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的：</p>
<ul>
<li>等待读的 goroutine，会将数据区 elem 置为零值 ( <code>typedmemclr(c.elemtype, sg.elem)</code> ) 然后继续执行</li>
<li>等待写的 goroutine，将会 panic</li>
</ul>
<p>参考资料</p>
<p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/" target="_blank" rel="noopener">Go Channel 源码剖析</a></p>
<p><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="noopener">Diving Deep Into The Golang Channels.</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/GUID生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/GUID生成/" itemprop="url">GUID生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-21T17:18:09+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/21/GUID生成/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/21/GUID生成/" class="cy_cmt_count" data-xid="2018/11/21/GUID生成/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MangoDB objectid</p>
<p>twitter snowflake</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/游戏服务器数据一致性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/游戏服务器数据一致性/" itemprop="url">游戏服务器数据一致性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T13:55:27+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/19/游戏服务器数据一致性/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/19/游戏服务器数据一致性/" class="cy_cmt_count" data-xid="2018/11/19/游戏服务器数据一致性/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>游戏服务器是一种很常见的分布式系统，分布式系统最大的难题是状态同步，CAP 定理是这方面的原理。</p>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p><img src="/images/image-20181119135742290.png" alt="image-20181119135742290"></p>
<ul>
<li><p>Consistency 一致性</p>
</li>
<li><p>Availability 可用性</p>
</li>
<li><p>Partition tolerance 分区容错性</p>
</li>
</ul>
<p>CAP 这三个指标不可能同时做到，最多只能满足其二。这个结论就叫做 CAP 定理。</p>
<p><strong><code>Partition tolerance</code> 分区容错</strong>，意思是分布式的各节点（也叫区）之间通信是不可靠的。一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p>
<p><strong><code>Consistency</code> 一致性</strong>，意思是从各个节点访问同一数据，其值必须都是最新的，即一致的。节点的多份数据必须通过一定的算法做同步。</p>
<p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p><img src="/images/image-20181119140749199.png" alt="image-20181119140749199"></p>
<p><img src="/images/image-20181119140847181.png" alt="image-20181119140847181"></p>
<p>此时如果有用户向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p>
<p><img src="/images/image-20181119141002062.png" alt="image-20181119141002062"></p>
<p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p>
<p><img src="/images/image-20181119141107638.png" alt="image-20181119141107638"></p>
<p>注意这里说的其实是强一致性。相对的还有弱一致性，即最终一致性。</p>
<p><strong>Availability 可用性</strong>， 意思是通过任意节点都可以拿到数据，强调服务的可用性。一般可以用 <code>服务可用时间/总服务时间</code> 去度量。比如4个9的可用性，即99.99%，换算到一年的时间内，可以反推出最长故障时间：</p>
<p><code>365 × 86400 ×（1-99.99%）秒 = 3153.6 秒 = 52.56 分钟</code></p>
<p>保证系统各个环节无单点、大部分故障可自愈是保障高可用性的关键。</p>
<p>以下为一些案例：</p>
<ol>
<li>CDN 缓存。最大可用性 + 最终一致性。各CDN节点的数据可以在运行一段时间后才趋于一致。</li>
<li>zookeeper。强一致性 + 不错的可用性。paxos/raft 一致性算法保证一致性。当出现分区(P故障)的时候，并非是完全不可用的，它提供了在大多数节点连通的情况下的可用性保证。</li>
<li>两阶段提交协议：强一致性 + 糟糕的可用性。两阶段提交协议中任意一节点与协调节点之间发生了分区，则服务完全终止。</li>
<li>Git。优先保证可用性，一般就是提交在本地。远程合并时，有一个专门的合并算法处理一致性问题，遇到无法处理的冲突（小部分情况下），把选择权交给了用户。</li>
</ol>
<h3 id="游戏中的数据一致性"><a href="#游戏中的数据一致性" class="headerlink" title="游戏中的数据一致性"></a>游戏中的数据一致性</h3><p>游戏是一种逻辑极其复杂，数据结构繁杂的系统，需要处理的问题千差万别；不同的游戏类型，其要求也是不同的，不能简单的套用理论上的CAP定理，去过分强调系统的一致性或者可用性。对于游戏中产生的数据，我们可以分为以下几大类：</p>
<ul>
<li>玩家的存档数据。这部分数据可以说是游戏中最重要的数据了，通常我们的考虑是强一致性。</li>
<li>全局重要数据，如工会数据、SLG大地图城池数据等。这也要求强一致性。</li>
<li>旁路数据，如好友列表数据。因为好友信息，如名字、等级、头像等，这些数据的更新有一定的延迟容忍度，可以做成弱一致性，保证最终的数据一致性即可。</li>
</ul>
<h3 id="多方修改"><a href="#多方修改" class="headerlink" title="多方修改"></a>多方修改</h3><p>对于玩家存档数据和全局重要数据，很可能有多方同时修改，如何保证强一致性呢？</p>
<p>方法一，某一玩家的数据读取或者修改统一指定到特定逻辑进程来操作。例如A在进程1，玩家B在进程2，如果A想读取或者修改B的数据，将修改请求统一发放到进程2处理，完成后返回进程1。这样处理有个问题，如果某一个进程挂掉，该进程上的玩家都无法得到服务。好处是简单，没有同时读写的问题。</p>
<p>方法二，所有进程对等，玩家操作不一定落在某一固定进程处理，所有进程的需要做的就是取玩家的数据，修改，然后存入数据层。一般在逻辑层做乐观锁机制，保证多进程同时修改一个玩家数据。简单的可以设置一个版本号，更新的时候去检查版本号，不一致则失败，需要做回滚。这种情况一般要求业务需求可以重试，如很多游戏里的偷菜等玩法就采用这种方式。复杂的地方在回滚怎么做。这种方式的并发性能比较高。</p>
<p>方法三，对于同时操作概率比较大的数据，如公会数据、大地图数据等，可以添加独占锁，严格保证一致性。这种方式性能会比较低，并发不高。可以做的改进是用读写锁。</p>
<p>方法二和方法三的情况，无论是操作玩家数据或者全局数据，本质上都是用的是锁（乐观锁和悲观锁），所以要注意尽量减小锁的粒度，做垂直划分：将关联度低的数据拆分成多块，分别加锁控制，减小锁冲突。</p>
<h3 id="数据软拷贝"><a href="#数据软拷贝" class="headerlink" title="数据软拷贝"></a>数据软拷贝</h3><p>所谓数据软拷贝，意思是对核心数据的冗余备份，用以提高性能和逻辑复杂度。</p>
<p>举个例子，上文提到的好友列表中的某一个玩家的数据，如名字、等级等，在该玩家存档数据中一定是准确的，这个由强一致性保证。这是不是意味着拥有该玩家为好友的所有其他玩家，其好友列表中一定要实时更新？答案是否。我们可以为所有玩家维护一份冗余的简要数据放到全局服务中；各逻辑服如果有玩家存档数据更新，只需要同时通知简要数据修改，但可能更新失败，这可以容忍。下次找个时机，如玩家登录时再使用存档数据同步一下简要数据。拉取玩家好友列表，直接取简要数据里的数据即可。</p>
<p>另一个例子，是公会相关数据。全局的公会数据需要维护公会的基本信息，以及成员的信息；同时玩家存档数据需要记录自己属于哪个公会。这里我们就需要区分数据准确性，通常认为公会数据是准确的，玩家存档里的是软拷贝。如果有一个玩家加入公会，永远以公会数据做基本判断，加入成功后再同步玩家存档数据。如果同步出错怎么办？其实问题不大，只是其他玩家看到的软拷贝是脏数据。找个时机，如玩家登录时从公会服拉取同步一下，或者公会服控制定时 push 到游戏逻辑服。</p>
<h3 id="事务数据"><a href="#事务数据" class="headerlink" title="事务数据"></a>事务数据</h3><p>分布式事务经常出现在互联网产品中，如电商后台的订单系统，就会涉及一个操作修改多份数据：下单会修改商品库存、订单、支付信息等，要求事务性。</p>
<p>游戏中类似的系统有建角，双向好友，拍卖行，特定玩法如俘虏与被俘虏等。</p>
<p>一种做法是用状态机，将事务的各个操作拆分N个原子操作，然后每一步都有其对应的回滚逻辑，如果中间失败，依次回滚。</p>
<p>另一种做法是互联网产品中经常使用的方式，利用消息队列的方式保存消息，利用消息队列的重传特性，如果中间失败，则会重传继续重试。这里要注意，对于操作要做到幂等性，即使重试多次调用接口不会多次运行逻辑。</p>
<p>不使用两阶段提交是因为，有可能多个原子步骤之间有依赖关系；并且两阶段提交整个过程是阻塞的，第一阶段prepare 会锁住资源，这是不可接受的。</p>
<p>参考资料</p>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP 定理的含义</a></p>
<p><a href="http://gad.qq.com/article/detail/15801" target="_blank" rel="noopener">有一千个程序员，就有一千种对CAP的解读</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/深度探索C-对象模型总结1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/深度探索C-对象模型总结1/" itemprop="url">深度探索C++对象模型总结1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T20:05:21+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/18/深度探索C-对象模型总结1/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/18/深度探索C-对象模型总结1/" class="cy_cmt_count" data-xid="2018/11/18/深度探索C-对象模型总结1/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++ class 相对于 C struct，支持了更多特性，如添加了类的方法，构造析构函数，继承等。一般来说 class 和 struct  效率大部分情况下是相同的，引起效率差异的地方主要在两点：</p>
<ul>
<li><p>virutal function。class需要维护一个虚函数表，并通过虚指针指向它，中间多了一道访问转换。</p>
</li>
<li><p>virutal base class。虚基类，主要是为了解决菱形继承关系，防止基类对象在子类对象布局中存在多份，因而引入了指针，这中间也多了一道访问转换。</p>
</li>
</ul>
<h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h5 id="非静态成员变量"><a href="#非静态成员变量" class="headerlink" title="非静态成员变量"></a>非静态成员变量</h5><p>非静态成员变量存放在每个object上</p>
<h5 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h5><p>静态成员变量存放在静态数据区，需要在类外单独定义。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;	<span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">1</span>;		<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><p>成员函数，包括非静态和静态成员函数，存放于代码区，也是独立于每个object之外。</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>所有的虚函数被放在类的虚函数表里，虚函数表由编译器生成；每个object有个指向虚函数表的指针，在运行时由构造函数、析构函数、赋值操作符来设置或者重置。</p>
<h5 id="TypeInfo"><a href="#TypeInfo" class="headerlink" title="TypeInfo"></a>TypeInfo</h5><p>类的类型信息，用来在运行时支持类型识别 (RTTI)，也存放在虚函数表里，通常放在虚表的第一个slot。</p>
<h5 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h5><p>未涉及继承的class对象布局，总体的示意图就类似下面这样</p>
<p><img src="/images/image-20181118203839822.png" alt="image-20181118203839822"></p>
<h2 id="C-多态语义"><a href="#C-多态语义" class="headerlink" title="C++多态语义"></a>C++多态语义</h2><p>c++多态从语法上说，需要的形式是基类指针或者引用指向子类对象，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base *bp = &amp;d;</span><br><span class="line">bp-&gt;DoSomething();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Base &amp;bi = d;</span><br><span class="line">bi.DoSomething();</span><br></pre></td></tr></table></figure>
<p>如果直接将子类对象直接赋值给基类对象，则子类对象会被截断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base b;</span><br><span class="line">Derived d;</span><br><span class="line">b = d;	<span class="comment">//截断</span></span><br><span class="line">b.DoSomething(); <span class="comment">//调用的是基类的方法</span></span><br></pre></td></tr></table></figure>
<p>因此，如果有一个基类的指针<code>*bp</code> 或者引用 <code>bi</code>，我们必然不能确定该指针或引用指向的是什么，可能是基类的对象，也可能是子类的对象，因此其调用的方法必须在运行时确定，这也是多态的具体表现。</p>
<p>但是也要注意，并不是任意一个指针或者引用就支持指针，比如下面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no polymorphism</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="comment">// no language supported polymorphism</span></span><br><span class="line"><span class="keyword">void</span> *pvi;</span><br><span class="line"><span class="comment">// ok: class x serves as a base class</span></span><br><span class="line">x *px;</span><br></pre></td></tr></table></figure>
<p>以下是多态语法形式的内存布局：</p>
<p><img src="/images/image-20181118212121033.png" alt="image-20181118212121033"></p>
<p>更复杂的形式：</p>
<p><img src="/images/image-20181118212454317.png" alt="image-20181118212454317"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/深度探索C-对象模型总结2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/深度探索C-对象模型总结2/" itemprop="url">深度探索C++对象模型总结2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T20:11:51+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/16/深度探索C-对象模型总结2/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/16/深度探索C-对象模型总结2/" class="cy_cmt_count" data-xid="2018/11/16/深度探索C-对象模型总结2/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offset of z: %p\n"</span>, &amp;A::z);       <span class="comment">//int A::*</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a: %p, &amp;a.z: %p\n"</span>, &amp;a, &amp;a.z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offset of z: 0x8</span><br><span class="line">&amp;a: 0x7ffeeea7fa20, &amp;a.z: 0x7ffeeea7fa28</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/Go研究之Interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/Go研究之Interface/" itemprop="url">Go研究之Interface</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T20:53:03+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/15/Go研究之Interface/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/15/Go研究之Interface/" class="cy_cmt_count" data-xid="2018/11/15/Go研究之Interface/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="空接口interface"><a href="#空接口interface" class="headerlink" title="空接口interface{}"></a>空接口interface{}</h2><h5 id="interface-赋值"><a href="#interface-赋值" class="headerlink" title="interface{} 赋值"></a>interface{} 赋值</h5><p><code>interface{}</code> 有点类似于 <code>C/C++</code> 里的 <code>void*</code>，<code>interface{}</code> ，在 Golang 中可以存储任何数据类型：int、string、struct、function、nil、map等等所有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span>     <span class="comment">//字面1为int类型</span></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>由于Go中所有的变量有类型信息，因此存储到 <code>interface{}</code> 里也会带上类型信息，这样才可以在运行时支持反射等特性（这也是不同于void*的地方）。而且<code>interface{}</code> 还可以通过类型assert反转换到具体类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span></span><br><span class="line">b := a.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>空接口<code>interface{}</code> 底层是通过<code>eface</code>结构来实现的，意思是<code>empty interface</code>。<code>eface</code> 本质上类似一个 <code>pair&lt;type, data&gt;</code> ，其中<code>type</code> 存储了变量的实际类型，而<code>data</code> 指向变量的值。具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span> <span class="comment">// type size 描述类型的大小</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span>  <span class="comment">// hash of type; avoids computation in hash tables</span></span><br><span class="line">    tflag      tflag   <span class="comment">// extra type information flags</span></span><br><span class="line">    align      <span class="keyword">uint8</span>   <span class="comment">// 变量对齐</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span>   <span class="comment">// 结构体对齐</span></span><br><span class="line">    kind       <span class="keyword">uint8</span>   <span class="comment">// 和反射里的kind一致，数据的大类</span></span><br><span class="line">    alg        *typeAlg  <span class="comment">//算法函数指针，存储了hash/equal/print/copy四个函数操作</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span>    <span class="comment">// garbage collection data</span></span><br><span class="line">    str       nameOff  <span class="comment">// string form</span></span><br><span class="line">    ptrToThis typeOff  <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go1.7 源码中将变量赋值给 <code>interface{}</code>是通过<code>convT2E</code> 实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E</span><span class="params">(t *_type, elem unsafe.Pointer, x unsafe.Pointer)</span> <span class="params">(e eface)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;t)), funcPC(convT2E))</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(elem, t.size)</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</span><br><span class="line">        throw(<span class="string">"direct convT2E"</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        x = newobject(t)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> We allocate a zeroed object only to overwrite it with</span></span><br><span class="line">        <span class="comment">// actual data. Figure out how to avoid zeroing. Also below in convT2I.</span></span><br><span class="line">    &#125;   </span><br><span class="line">    typedmemmove(t, x, elem)</span><br><span class="line">    e._type = t </span><br><span class="line">    e.data = x </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在运行时，通过 <code>typedmemmove</code> 进行了内存拷贝，<code>data</code> 不是简单的指向原数据区。而反射里修改数据时，如果不是指针类型，修改会失败，应该也是基于这个原因：修改的只是拷贝的数据。</p>
<p>我们可以用以下实验试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u := User&#123;1, &quot;Tom&quot;&#125;</span><br><span class="line">    var i interface&#123;&#125; = u</span><br><span class="line">    u.id = 2</span><br><span class="line">    u.name = &quot;Jack&quot;</span><br><span class="line">    fmt.Printf(&quot;u: %#v\n&quot;, u);</span><br><span class="line">    fmt.Printf(&quot;i: %#v\n&quot;, i);</span><br><span class="line">    </span><br><span class="line">    u2 := &amp;User&#123;2, &quot;Tom2&quot;&#125;</span><br><span class="line">    var i2 interface&#123;&#125; = u2</span><br><span class="line">    u2.id = 2</span><br><span class="line">    u2.name = &quot;Jack2&quot;</span><br><span class="line">    fmt.Printf(&quot;u2: %#v\n&quot;, u2);</span><br><span class="line">    fmt.Printf(&quot;i2: %#v\n&quot;, i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u: main.User&#123;id:2, name:&quot;Jack&quot;&#125;</span><br><span class="line">i: main.User&#123;id:1, name:&quot;Tom&quot;&#125;</span><br><span class="line">u2: &amp;main.User&#123;id:2, name:&quot;Jack2&quot;&#125;</span><br><span class="line">i2: &amp;main.User&#123;id:2, name:&quot;Jack2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>证明了代码里的拷贝实现。</p>
<h5 id="interface-与-nil"><a href="#interface-与-nil" class="headerlink" title="interface{} 与 nil"></a>interface{} 与 nil</h5><p>当将 nil 赋值给 interface{} 变量时，<code>type</code> 和 <code>data</code> 域都将被赋值为 <code>nil</code>, 因此其本质上是一个<code>nil</code></p>
<p>而如果是一个其他类型的 nil 值，被赋值给 <code>interface{}</code>，则其 <code>type</code>是有具体类型的，只不过<code>data</code> 是nil，因而组合而成的 <code>eface</code>结构就不是一个<code>nil</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">  </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 interface&#123;&#125; = nil   // type 和 data 都是 nil</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, i1 == nil);</span><br><span class="line"></span><br><span class="line">    var u2 *User</span><br><span class="line">    var i2 interface&#123;&#125; = u2   // type 是 *User，data是 nil</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, i2 == nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不仅是空接口<code>interface{}</code> 是这样，其他有方法的<code>interface</code> 如果被赋值为一个具体类型的<code>nil</code> 值，本质上是不等于<code>nil</code>，而只有被直接赋值为<code>nil</code>，才是真正上的<code>nil</code>。可以认为直接赋值字面上的<code>nil</code> 是类型<code>type</code>和<code>data</code> 都为<code>nil</code> 的<code>nil</code>。</p>
<h2 id="非空-interface"><a href="#非空-interface" class="headerlink" title="非空 interface"></a>非空 interface</h2><h5 id="非空interface赋值"><a href="#非空interface赋值" class="headerlink" title="非空interface赋值"></a>非空interface赋值</h5><p>非空 interface 一般用来实现类似C++的运行时的多态特性。将一个<code>struct</code> 变量赋值给非空interface时编译器会先做一次校验：看该<code>struct</code>类型是否实现了接口所需的所有方法，如果没有，则会报错。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b I = a</span><br></pre></td></tr></table></figure>
<p>编译器会给出提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use a (type int) as type I in assignment:</span><br><span class="line">    int does not implement I (missing String method)</span><br></pre></td></tr></table></figure>
<p>运行时赋值底层借助接口 <code>iface</code> 来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// layout of Itab known to compilers</span></span><br><span class="line"><span class="comment">// allocated in non-garbage-collected memory</span></span><br><span class="line"><span class="comment">// Needs to be in sync with</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    link   *itab</span><br><span class="line">    bad    <span class="keyword">int32</span></span><br><span class="line">    unused <span class="keyword">int32</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>itab</code> 结构包含了两个类型：1)该 <code>interface</code>自己的类型<code>*interfacetype</code>； 2) 其<code>data</code>所指向的具体接口实现的实际类型<code>*_type</code>。<code>interfacetype</code> 是对<code>_type</code>的封装，加上了一些<code>interface</code>才有的数据，专门来表示<code>interface</code>的具体类型。我们可以看到其<code>mhdr</code>成员表示该<code>interface</code>的方法集，但是注意这里只是函数原型<code>metadata</code>，不是具体的函数定义，具体的函数定义是由实现接口的<code>struct</code>来定义的。</p>
<p>相比于 <code>empty interface</code>，<code>non-empty interface</code> 要包含实现该 <code>interface</code>的<code>method</code> 具体定义，定义会被存放在 <code>itab.fun</code> 变量里。虽然 <code>fun</code> 数组只有一个元素，但实际赋值的时候会在内存上依次连续的存储各函数指针。</p>
<p>一个法国的bloger <a href="https://github.com/teh-cmc" target="_blank" rel="noopener">teh-cmc</a> 的 <a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals</a> 里通过汇编代码，详细说明了如何在运行时一个个填充<code>itab</code>结构的各个成员的，有兴趣的同学可以自行查看。</p>
<p>当<code>itab</code>结构被填充好了之后，运行时就可以通过调用<code>convT2I</code> 来将变量赋值给非空 <code>interface</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(elem, t.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isDirectIface(t) &#123;</span><br><span class="line">		<span class="comment">// This case is implemented directly by the compiler.</span></span><br><span class="line">		throw(<span class="string">"direct convT2I"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	x := newobject(t)</span><br><span class="line">	typedmemmove(t, x, elem)</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>x := newobject(t)</code> 会在堆上分配一个 t 类型的对象。由此可见，不管赋值给非空<code>interface</code>的变量存放在哪里，赋值操作都会在堆上重新生成一个对象，然后将对象的类型和指针存储在非空<code>interface</code>里，必要时可能会引发变量逃逸。因此该转换是比较消耗性能的，看下一个<code>benchmark</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Addifier <span class="keyword">interface</span>&#123; Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        adder.Add(<span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInterface</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Addifier(adder).Add(<span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用和通过<code>interface</code>来调用的差别很大，测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkDirect-4      	2000000000	         1.77 ns/op</span><br><span class="line">BenchmarkInterface-4   	100000000	        22.5 ns/op</span><br></pre></td></tr></table></figure>
<h5 id="非空interface动态dispatch"><a href="#非空interface动态dispatch" class="headerlink" title="非空interface动态dispatch"></a>非空interface动态dispatch</h5><p>动态dispatch实际上就类似于C++里的多态实现，C++通过虚函数表存储了各个具体实现类的函数指针，这是编译时完成的。而运行时通过构造函数来生成指向虚函数表的虚表指针，调用的时候通过指针来查找具体应该调用虚函数表里的哪个函数。</p>
<p>而Go的实现方式也有些许类似，上文提到的<code>itab.fun</code> 结构就类似于<code>虚表</code>概念，所不同的是，虚表是在运行时通过<code>go</code>的<code>runtime</code>来赋值的。一旦虚表被填充好，函数调用就简单的在虚表中查找了，主要的开销应该还是在<code>interface</code> 赋值的时候。</p>
<p>参考资料</p>
<p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html" target="_blank" rel="noopener">深入解析Go</a></p>
<p><a href="https://juejin.im/post/5a6873fd518825734501b3c5" target="_blank" rel="noopener">Golang interface接口深入理解</a></p>
<p><a href="https://ninokop.github.io/2017/10/30/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97/" target="_blank" rel="noopener">Go 反射与interface拾遗</a></p>
<p><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/随机数生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/随机数生成/" itemprop="url">随机数生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T17:24:55+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/12/随机数生成/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/12/随机数生成/" class="cy_cmt_count" data-xid="2018/11/12/随机数生成/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/Go泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/Go泛型/" itemprop="url">Go泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-17T16:06:45+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/10/17/Go泛型/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/10/17/Go泛型/" class="cy_cmt_count" data-xid="2018/10/17/Go泛型/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Go 语言本身不支持泛型 generics。我们这里主要看下怎么处理泛型的需求。</p>
<h2 id="泛型数据"><a href="#泛型数据" class="headerlink" title="泛型数据"></a>泛型数据</h2><p>如果要存储泛型数据，Go 提供了空接口 interface{}。可以将任意的数据结构存储到 interface{} 中，然后使用的时候需要做一下 cast 转换。</p>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>这种使用比较常用，意思是针对不同的数据类型，需要运行同样的一套函数化的流程或者算法。</p>
<p>目前 Go 并不支持这种传统意义上的泛型编程。<code>Jon Bodner</code> 在他的 <a href="https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5" target="_blank" rel="noopener">Closures are the Generics for Go</a> 这篇文章中提供了一种间接实现泛型函数需求的做法，就是利用回调形式的闭包。</p>
<p>简单来说，就是将需要泛型抽象的一套流程和算法封装成一个公共接口，并且提供一个回调，可以在回调时候利用闭包的特性来读取或者修改变量 T，而 T 在通常的泛型编程中是需要传给泛型函数的。</p>
<p>下面是一个C++ 中的泛型函数的使用，compare 就是一套函数化的流程或者算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs &lt; rhs) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rhs &lt; lhs) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 中如果实现类似的效果呢？方法就是回调闭包函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(fnCmp <span class="keyword">func</span>()</span> <span class="title">int</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">    ret := fnCmp()</span><br><span class="line">    <span class="keyword">return</span> ret &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">2</span>;</span><br><span class="line">    result := compare(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) &#123;<span class="keyword">return</span> <span class="number">-1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过闭包的特性，可以不需要传之前需要的泛型参数 T，就可以对变量进行读取和修改。</p>
<p>我们只需要将相同的流程抽象成一个公共接口，这里是<code>compare</code>，然后将不同的部分通过回调闭包的形式作为参数让公共接口调用即可，这里是 <code>fnCmp func() int</code> 参数。</p>
<p>另一个比较恰当的例子是数据库的批量分页拉取。针对每个业务的数据库表，都可能会需要分页拉取 table 里的所有数据，就有必要将分页拉取的操作封装成一个公共接口，拉取后通过闭包参数来让调用方自定义后续操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> records []*DBTerritoryRespawn</span><br><span class="line">batchGet(dbtbl, fields, wheres, <span class="function"><span class="keyword">func</span><span class="params">(rows [][]hqdb.TbField)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">        record := do_something_with(row)</span><br><span class="line">        records = <span class="built_in">append</span>(records, record)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每次拉取一页（batchGet 内部调用一次闭包函数），都可以修改最终的结果 <code>records</code>。</p>
<p>利用闭包，我们可以方便的抽象出一个通用的排序接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sorter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    fnSwap <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">fnLess</span> <span class="title">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(s sorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> s.<span class="built_in">len</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.fnSwap(i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.fnLess(i, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//slice排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>, fnSwap <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span>, <span class="title">fnLess</span> <span class="title">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">    sort.Sort(sorter&#123;<span class="built_in">len</span>, fnSwap, fnLess&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    Sort(<span class="built_in">len</span>(data), <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        data[i], data[j] = data[j], data[i]</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data[i] &lt; data[j]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过这里用了2个闭包函数 fnSwap 和 fnLess。</p>
<p>以上通过 closure 闭包提供的解决方式实质上使用了软件理论中的<code>side-effects</code>来实现的，意思是函数调用会影响调用方的数据。现代编程理论认为这是一种不好的方式，和其相对的是函数化编程。</p>
<p>这里仅仅是提供一个泛型的一种 <code>work around</code>，所以还是期待未来 Go 能支持真正意义上的泛型。</p>
<p>参考资料</p>
<p><a href="https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5" target="_blank" rel="noopener">Closures are the Generics for Go</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/服务器性能优化备忘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/服务器性能优化备忘/" itemprop="url">服务器性能优化备忘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T15:33:15+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/29/服务器性能优化备忘/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/29/服务器性能优化备忘/" class="cy_cmt_count" data-xid="2018/09/29/服务器性能优化备忘/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近对服务器进行了一次性能优化，这里记录一下要点以供备忘。</p>
<h2 id="Go-Profile"><a href="#Go-Profile" class="headerlink" title="Go Profile"></a>Go Profile</h2><p>golang 官方提供了一个称为 pprof 的性能调优工具。我们可以利用该工具来进行诊断。pprof 的原理是每秒钟暂停100次，然后对当前正在运行的 goroutine 堆栈进行采样并记录次数。</p>
<h5 id="pprof-开启"><a href="#pprof-开启" class="headerlink" title="pprof 开启"></a>pprof 开启</h5><p>对于服务器，一般通过 http 方式来启用 pprof，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(http.ListenAndServe(<span class="string">"0.0.0.0:6060"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h5 id="pprof-诊断热点函数"><a href="#pprof-诊断热点函数" class="headerlink" title="pprof 诊断热点函数"></a>pprof 诊断热点函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof bin/sessionsvr http://your-ip:port/debug/pprof/profile?seconds=30</span><br></pre></td></tr></table></figure>
<p>30秒后，数据采集完成，top20 可以列出 CPU 占用最高的20项，结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top20</span><br><span class="line">6300ms of 8360ms total (75.36%)</span><br><span class="line">Dropped 236 nodes (cum &lt;= 41.80ms)</span><br><span class="line">Showing top 20 nodes out of 137 (cum &gt;= 430ms)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1200ms 14.35% 14.35%     3070ms 36.72%  runtime.mapassign1</span><br><span class="line">    1000ms 11.96% 26.32%     1010ms 12.08%  runtime.mapiternext</span><br><span class="line">     750ms  8.97% 35.29%      750ms  8.97%  runtime.aeshashbody</span><br><span class="line">     430ms  5.14% 40.43%      690ms  8.25%  runtime.scanobject</span><br><span class="line">     320ms  3.83% 44.26%     4980ms 59.57%  hgame/sessionsvr/logic/territory.(*territoryMap).moveSight</span><br><span class="line">     280ms  3.35% 47.61%      430ms  5.14%  runtime.evacuate</span><br><span class="line">     260ms  3.11% 50.72%      260ms  3.11%  runtime.usleep</span><br><span class="line">     250ms  2.99% 53.71%      310ms  3.71%  syscall.Syscall</span><br><span class="line">     240ms  2.87% 56.58%      240ms  2.87%  runtime.memmove</span><br><span class="line">     210ms  2.51% 59.09%      210ms  2.51%  runtime.futex</span><br><span class="line">     190ms  2.27% 61.36%      190ms  2.27%  runtime.memclr</span><br><span class="line">     180ms  2.15% 63.52%      290ms  3.47%  runtime.mapiterinit</span><br><span class="line">     180ms  2.15% 65.67%      380ms  4.55%  runtime.typedmemmove</span><br><span class="line">     160ms  1.91% 67.58%      160ms  1.91%  sync/atomic.AddUint32</span><br><span class="line">     140ms  1.67% 69.26%      140ms  1.67%  runtime.heapBitsForObject</span><br><span class="line">     140ms  1.67% 70.93%      200ms  2.39%  runtime.strequal</span><br><span class="line">     110ms  1.32% 72.25%      450ms  5.38%  runtime.mallocgc</span><br><span class="line">     110ms  1.32% 73.56%      180ms  2.15%  runtime.mapaccess2_faststr</span><br><span class="line">      90ms  1.08% 74.64%       90ms  1.08%  runtime.heapBitsSetType</span><br><span class="line">      60ms  0.72% 75.36%      430ms  5.14%  github.com/ugorji/go/codec.encFnInfo.kStruct</span><br></pre></td></tr></table></figure>
<p>其中前两列 flat 表示该函数调用的时间和百分比，后两列 cum 表示该函数处于堆栈中的时间和百分比，包含正在被调用或者等待其他子函数返回的情况。 sum 表示前面 N 行到当前行函数累计的时间百分比。</p>
<p>从上面的结果可以知道 cum% 为 59.57% 的 moveSight 函数长时间处于栈列表中，是正在运行或者等待该函数里面其他函数调用返回。而其很可能主要等待前面几个 map 的操作完成。</p>
<p>运行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top mapassign1</span><br><span class="line">2590ms of 7720ms total (33.55%)</span><br><span class="line">Dropped 9 nodes (cum &lt;= 38.60ms)</span><br><span class="line">Showing top 10 nodes out of 42 (cum &gt;= 30ms)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    1020ms 13.21% 13.21%     2710ms 35.10%  runtime.mapassign1</span><br><span class="line">     550ms  7.12% 20.34%      550ms  7.12%  runtime.aeshashbody</span><br><span class="line">     240ms  3.11% 23.45%      240ms  3.11%  runtime.memmove</span><br><span class="line">     240ms  3.11% 26.55%      540ms  6.99%  runtime.typedmemmove</span><br><span class="line">     210ms  2.72% 29.27%      240ms  3.11%  runtime.strequal</span><br><span class="line">     130ms  1.68% 30.96%      370ms  4.79%  runtime.evacuate</span><br><span class="line">     100ms  1.30% 32.25%      100ms  1.30%  runtime.memclr</span><br><span class="line">      40ms  0.52% 32.77%       60ms  0.78%  runtime.heapBitsBulkBarrier</span><br><span class="line">      30ms  0.39% 33.16%       30ms  0.39%  runtime.aeshash32</span><br><span class="line">      30ms  0.39% 33.55%       30ms  0.39%  runtime.aeshashstr</span><br><span class="line">      </span><br><span class="line">(pprof) svg mapassign1</span><br><span class="line">Generating report in cpu.svg</span><br></pre></td></tr></table></figure>
<p>用浏览器打开 生成的结果 <code>cpu.svg</code> 可以看到</p>
<p><img src="/images/image-20180930144018771.png" alt="image-20180930144018771"></p>
<p>从图中可以证实，确实是 moveSight 导致的 map 操作占用 CPU 时间较多。</p>
<p>利用 list 命令查看具体是那一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list moveSight</span><br></pre></td></tr></table></figure>
<p>找到具体数据结构后，就可以有针对性的修改。一般来说 map 的优化主要是 key 要使用比较简单的类型，这样计算 hash 的时候也比较快。通常来说 int 类型 key 比 string 类型的 key 要快。此外由于 map 的内存增长是指数级的，新插入的时候如果发现空间不足，需要重新分配空间 hashGrow 和进行内存 typedmemmove，很耗性能，所以如果能预估 map 的大小，最好一开始就分配足够大的空间，以空间换时间。</p>
<h2 id="机器人策略"><a href="#机器人策略" class="headerlink" title="机器人策略"></a>机器人策略</h2><h2 id="Lua-Profile"><a href="#Lua-Profile" class="headerlink" title="Lua Profile"></a>Lua Profile</h2><ul>
<li>数据库数据的分批拉取、存储。Mysql 一次 update 多条记录会比多次 update 快。(有网络开销，获取锁开销等)</li>
<li>配置数据的加载，预处理。</li>
<li>map 或者 slice 预分配空间大小，减少频繁扩容及数据拷贝代价。</li>
<li>注意共享资源锁的粒度。</li>
<li>数据更新量。大且频繁的数据使用版本号做增量通知。</li>
<li>算法优化：KDtree 查找距离最近，KNN 算法；模糊查找算法。</li>
<li>广播裁剪</li>
<li>包大小优化，序列化方法，压缩</li>
<li>登录模块，预分配 user 池</li>
<li>增加 metrics 统计项，及早发现问题</li>
<li>snap 快照对比，找出 lua 内存泄露</li>
<li>lua 有性能问题的地方改用 c 或者 go 实现（加解密、time、socket、json 等序列化、随机数发生器、位操作）</li>
<li>gettimeofday</li>
<li>避免密集操作，如避免定点发放物品，分批发放</li>
<li>利用 goroutine 多核并行执行</li>
<li>空间换时间</li>
<li>消峰：均摊思想。例如哈希表的扩容时候，不是一次做完数据迁移。</li>
<li>用 SSD 硬盘。</li>
<li>数据库分表分库，读写分离</li>
</ul>
<h5 id="算法调优"><a href="#算法调优" class="headerlink" title="算法调优"></a>算法调优</h5><h5 id="代码调优"><a href="#代码调优" class="headerlink" title="代码调优"></a>代码调优</h5><ul>
<li>尽量用整形取代字符串（例如用整形 flags 来表示多个状态，利用位操作来查询设置状态；数据库用整形做 key）</li>
<li>单线程中，不要用带锁相关的数据结构，很多 stl 的线程安全的容器或者智能指针 AutoPtr 都是加锁的，很耗性能；多线程环境下，尽量用无锁编程，乐观锁，读写锁等来替代互斥锁、悲观锁；最后，尽量用单线程</li>
<li>池化技术：内存池、对象池、连接池、线程池</li>
<li>缓存技术：LRU 缓存</li>
<li>将同步操作转换为异步操作，提高 throughout</li>
</ul>
<h5 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h5><ul>
<li>及时关闭空闲连接，避免资源耗尽。客户端服务器心跳 keepalive 机制。</li>
<li>TIMEWAIT 状态的处理。</li>
<li>TCP buff 的选择。理论上的RWIN应该设置成：吞吐量  * 回路时间。Sender端的buffer应该和RWIN有一样的大小，因为Sender端发送完数据后要等Receiver端确认，如果网络延时很大，buffer过小了，确认的次数就会多，于是性能就不高，对网络的利用率也就不高了。也就是说，对于延迟大的网络，我们需要大的buffer，这样可以少一点ack，多一些数据，对于响应快一点的网络，可以少一些buffer。因为，如果有丢包（没有收到ack），buffer过大可能会有问题，因为这会让TCP重传所有的数据，反而影响网络性能。</li>
<li>对于一个UDP的包，我们要尽量地让他大到MTU的最大尺寸再往网络上传，这样可以最大化带宽利用率。对于这个MTU，以太网是1500字节，光纤是4352字节，802.11无线网是7981。</li>
<li>Epoll 的使用。</li>
<li>DNS lookup。gethostbyaddr/gethostbyname 这个函数可能会相当的费时，因为其要到网络上去找域名，因为DNS的递归查询，会导致严重超时，而又不能通过设置什么参数来设置time out，对此你可以通过配置hosts文件来加快速度，或是自己在内存中管理对应表，在程序启动时查好，而不要在运行时每次都查。</li>
</ul>
<h5 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h5><ul>
<li>选对引擎</li>
<li>索引</li>
<li>数据类型选择</li>
<li>分表分库</li>
<li>读写分离</li>
</ul>
<ul>
<li><p>实现层优化：vtune 等工具查找热点，针对性优化。</p>
</li>
<li><p>实现层优化：空间换时间，为高频不善变计算建立缓存。</p>
</li>
<li>业务层优化：柔性可用，设立资源消耗配额(定时重置)，每次请求消费一个配额，控制总体。</li>
<li>业务层优化：有损服务，对业务需求进行必要裁剪。</li>
</ul>
<p>参考资料</p>
<p><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go Programs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/MySQL-Cheat-Sheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/MySQL-Cheat-Sheet/" itemprop="url">MySQL Cheat Sheet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T09:33:08+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/09/13/MySQL-Cheat-Sheet/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/09/13/MySQL-Cheat-Sheet/" class="cy_cmt_count" data-xid="2018/09/13/MySQL-Cheat-Sheet/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h5 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h5><p>关于 mysql 的版本选择，可以参考 <a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">如何选择 MySQL 版本</a> 这篇文章。我们选择社区版的 5.6 版本。</p>
<h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><p>为了方便用户安装，MySQl 官方提供了单独的 repository，对于Linux 发行版，有专门的 yum 源和 apt 源。将源添加好后，就可以很方便的通过 linux 的 yum 或者 apt 工具进行安装。这里我们以 yum 为例来讲述 MySQL 社区版本的安装过程。</p>
<ul>
<li>首先下载  MySQL yum 源，页面位于 <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">Download MySQL Yum Repository</a> </li>
</ul>
<blockquote>
<p>注意下载的文件名虽然统一叫做 <code>mysql80-community-release-&lt;platform-and-version&gt;.noarch.rpm</code>，但是里面包含了 8.0，5.7，5.6，5.5 等各个版本以及工具。</p>
</blockquote>
<ul>
<li><p>本地安装下载的源，我们以 centos7为例，下载的文件为 <code>mysql80-community-release-el7-1.noarch.rpm</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">$ rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看启用的版本，默认是启用 8.0 版本</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum repolist enabled | grep mysql</span><br><span class="line">mysql-connectors-community/x86_64 MySQL Connectors Community                  65</span><br><span class="line">mysql-tools-community/x86_64      MySQL Tools Community                       69</span><br><span class="line">mysql80-community/x86_64          MySQL 8.0 Community Server                 412</span><br></pre></td></tr></table></figure>
<ul>
<li>修改启用版本为 5.6</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">disable</span> mysql80-community</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> mysql56-community</span><br></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install mysql-community-server</span><br><span class="line">$ mysql --version</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果安装时下载有问题，可以考虑修改 /etc/yum.conf 里的 proxy 代理配置为你的 http 代理地址 <a href="http://your_proxy_ip:port" target="_blank" rel="noopener">http://your_proxy_ip:port</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>默认安装路径是 <code>/var/lib/mysql</code>, 可以自定义数据文件路径。一般来说云主机的 data 盘较大，可以将数据库的数据存放于此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">socket=/data/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">socket=/data/mysql/mysql.sock   # 供 mysql client 连接用</span><br></pre></td></tr></table></figure>
<p>这里自定义的<code>/data/mysql</code> 路径需要设置为 mysql 用户拥有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R mysql:mysql /data/mysql</span><br></pre></td></tr></table></figure>
<p>开启慢查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=1 # 1s</span><br><span class="line">slow_query_log_file=/data/mysql/mysqld-slow.log</span><br></pre></td></tr></table></figure>
<p>开启 binlog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br></pre></td></tr></table></figure>
<p>设置字符集(character)及校对规则(collation，字符串比较规则)，字符集默认是 latin1，我们设置为 utf8</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>配置完成后，启动 mysqld 服务器进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysqld start</span><br></pre></td></tr></table></figure>
<h2 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h2><p>运行 <code>mysql_secure_installation</code> 命令，来对新安装的 mysql 进行安全性设置，这包括 root 密码设置、限制 root 只能本机登录、删除 test 库、删除匿名用户等。对于生产环境，强烈建议设置一下。</p>
<blockquote>
<p>注意 5.7 及以上版本已经不需要运行该命令</p>
</blockquote>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>使用 sysbench 工具来对 MySQL 进行测试(这里我们只测试 select primary key)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua <span class="built_in">help</span></span><br><span class="line">sysbench 1.0.9 (using system LuaJIT 2.0.4)</span><br><span class="line"></span><br><span class="line">oltp_read_only.lua options:</span><br><span class="line">  --distinct_ranges=N           Number of SELECT DISTINCT queries per transaction [1]</span><br><span class="line">  --sum_ranges=N                Number of SELECT SUM() queries per transaction [1]</span><br><span class="line">  --skip_trx[=on|off]           Don<span class="string">'t start explicit transactions and execute all queries in the AUTOCOMMIT mode [off]</span></span><br><span class="line"><span class="string">  --secondary[=on|off]          Use a secondary index in place of the PRIMARY KEY [off]</span></span><br><span class="line"><span class="string">  --create_secondary[=on|off]   Create a secondary index in addition to the PRIMARY KEY [on]</span></span><br><span class="line"><span class="string">  --index_updates=N             Number of UPDATE index queries per transaction [1]</span></span><br><span class="line"><span class="string">  --range_size=N                Range size for range SELECT queries [100]</span></span><br><span class="line"><span class="string">  --auto_inc[=on|off]           Use AUTO_INCREMENT column as Primary Key (for MySQL), or its alternatives in other DBMS. When disabled, use client-generated IDs [on]</span></span><br><span class="line"><span class="string">  --delete_inserts=N            Number of DELETE/INSERT combination per transaction [1]</span></span><br><span class="line"><span class="string">  --tables=N                    Number of tables [1]</span></span><br><span class="line"><span class="string">  --mysql_storage_engine=STRING Storage engine, if MySQL is used [innodb]</span></span><br><span class="line"><span class="string">  --non_index_updates=N         Number of UPDATE non-index queries per transaction [1]</span></span><br><span class="line"><span class="string">  --table_size=N                Number of rows per table [10000]</span></span><br><span class="line"><span class="string">  --pgsql_variant=STRING        Use this PostgreSQL variant when running with the PostgreSQL driver. The only currently supported variant is '</span>redshift<span class="string">'. When enabled, create_secondary is automatically disabled, and delete_inserts is set to 0</span></span><br><span class="line"><span class="string">  --simple_ranges=N             Number of simple range SELECT queries per transaction [1]</span></span><br><span class="line"><span class="string">  --order_ranges=N              Number of SELECT ORDER BY queries per transaction [1]</span></span><br><span class="line"><span class="string">  --range_selects[=on|off]      Enable/disable all range SELECT queries [on]</span></span><br><span class="line"><span class="string">  --point_selects=N             Number of point SELECT queries per transaction [10]</span></span><br></pre></td></tr></table></figure>
<p>准备数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua --threads=4  --mysql-user=root --mysql-password=xxxxx --mysql-db=db_test --db-driver=mysql --tables=10 --table_size=1000000 prepare</span><br><span class="line"></span><br><span class="line">sysbench 1.0.9 (using system LuaJIT 2.0.4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creating table <span class="string">'sbtest3'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest4'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest1'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest2'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest3'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest2'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest4'</span></span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest1'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest4'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest2'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest1'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest3'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest8'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest8'</span></span><br><span class="line">Creating table <span class="string">'sbtest6'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest6'</span></span><br><span class="line">Creating table <span class="string">'sbtest5'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest5'</span></span><br><span class="line">Creating table <span class="string">'sbtest7'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest7'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest8'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest6'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest5'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest7'</span>...</span><br><span class="line">Creating table <span class="string">'sbtest10'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest10'</span></span><br><span class="line">Creating table <span class="string">'sbtest9'</span>...</span><br><span class="line">Inserting 1000000 records into <span class="string">'sbtest9'</span></span><br><span class="line">Creating a secondary index on <span class="string">'sbtest10'</span>...</span><br><span class="line">Creating a secondary index on <span class="string">'sbtest9'</span>...</span><br></pre></td></tr></table></figure>
<p>数据准备好之后，开始运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench /usr/share/sysbench/oltp_read_only.lua --threads=16 --events=0 --time=300 --mysql-db=db_test --mysql-user=root --mysql-password=xxxxx --db-driver=mysql --table_size=1000000 --range_selects=off --db-ps-mode=<span class="built_in">disable</span> --report-interval=1 --histogram run</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[ 298s ] thds: 16 tps: 4907.59 qps: 58910.03 (r/w/o: 49095.86/0.00/9814.17) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line">[ 299s ] thds: 16 tps: 4915.22 qps: 58992.64 (r/w/o: 49161.20/0.00/9831.44) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line">[ 300s ] thds: 16 tps: 4909.87 qps: 58891.44 (r/w/o: 49070.70/0.00/9820.74) lat (ms,95%): 4.03 err/s: 0.00 reconn/s: 0.00</span><br><span class="line"></span><br><span class="line">SQL statistics:</span><br><span class="line">    queries performed:</span><br><span class="line">        <span class="built_in">read</span>:                            14678040</span><br><span class="line">        write:                           0</span><br><span class="line">        other:                           2935608</span><br><span class="line">        total:                           17613648</span><br><span class="line">    transactions:                        1467804 (4892.54 per sec.)</span><br><span class="line">    queries:                             17613648 (58710.46 per sec.)</span><br><span class="line">    ignored errors:                      0      (0.00 per sec.)</span><br><span class="line">    reconnects:                          0      (0.00 per sec.)</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          300.0070s</span><br><span class="line">    total number of events:              1467804</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                  0.80</span><br><span class="line">         avg:                                  3.27</span><br><span class="line">         max:                                114.77</span><br><span class="line">         95th percentile:                      3.96</span><br><span class="line">         sum:                            4797566.33</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           91737.7500/481.98</span><br><span class="line">    execution time (avg/stddev):   299.8479/0.00</span><br></pre></td></tr></table></figure>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>通过 <code>mysql_secure_installation</code> 脚本设置好 root 密码后，就可以登录了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h [host] -u [user] -p</span><br><span class="line">Enter password: ********</span><br></pre></td></tr></table></figure>
<p>登录并使用某一数据库(例子中密码前面不能有空格)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h [host] -u [user] -p[passwd] [DB_NAME]</span><br></pre></td></tr></table></figure>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>创建用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &apos;user&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP USER &apos;user&apos;@&apos;host&apos;;</span><br></pre></td></tr></table></figure>
<p>赋权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT SELECT, INSERT, DELETE ON base.* TO &apos;user&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;;</span><br><span class="line">mysql&gt; GRANT SELECT ON `db\_oss\_%`.* TO &apos;query&apos;@&apos;172.31.%&apos; IDENTIFIED BY &apos;123&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>更新密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;user&apos;@&apos;host&apos; = PASSWORD(&apos;new_pass&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看当前正在 use 的库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| mysql      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看建表语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t_xxx;</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from table t_xxx;</span><br></pre></td></tr></table></figure>
<p>查看字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;character_set_%&apos;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;collation%&apos;;</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| Variable_name        | Value           |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| collation_connection | utf8_general_ci |</span><br><span class="line">| collation_database   | utf8_general_ci |</span><br><span class="line">| collation_server     | utf8_general_ci |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure>
<p>设置连接编码为 utf8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET NAMES &apos;utf8&apos;;</span><br></pre></td></tr></table></figure>
<p>修改表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE [table] ADD COLUMN [column] VARCHAR(120);</span><br><span class="line">mysql&gt; ALTER TABLE [table] DROP COLUMN [column];</span><br></pre></td></tr></table></figure>
<p>插入一条记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO [table] ([column], [column]) VALUES (&apos;[value]&apos;, &apos;[value]&apos;);</span><br></pre></td></tr></table></figure>
<p>解释执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM [table] WHERE [column] LIKE &apos;%[value]%&apos;;</span><br></pre></td></tr></table></figure>
<p>更新数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE [table] SET [column] = &apos;[updated-value]&apos; WHERE [column] = [value];</span><br></pre></td></tr></table></figure>
<p>为一列或者多列添加命名索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE table ADD INDEX [index_name](column, ...);</span><br><span class="line">mysql&gt; CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table (column,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p>使用 group by 和 having 来获取特定组数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table GROUP BY column_1 HAVING condition;</span><br></pre></td></tr></table></figure>
<p>设置所有 row 的某一列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE table SET column_1 = value_1, ...;</span><br></pre></td></tr></table></figure>
<h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><h5 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h5><p>物理备份是拷贝数据库的文件，比较快，适用于数据迁移等场景。</p>
<h5 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h5><p>逻辑备份可以无视版本和架构对数据进行备份，比如进行 mysql 升级就可以使用逻辑备份来备份数据。逻辑备份通常结合全量备份和增量备份。</p>
<p>在 mysql 服务器本地，使用 mysqldump 进行全量备份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump --single-transaction --all-databases --flush-logs -u [username] -p &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>如果要备份特定的库和表，可以这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump --single-transaction --flush-logs -u [username] -p [db_name] &lt;table_name&gt; &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>如果不需要导出建库，使用–no-create–db选项，不需要建表语句，使用 –no-create-info 选项；导出特定条件的行，使用 –where 选项。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -h 10.137.213.82 -udbuser -ppassword --no-create-info db_hgame_1020 t_user --<span class="built_in">where</span>=<span class="string">"accid=776085"</span> &gt; /tmp/776085.sql</span><br></pre></td></tr></table></figure>
<p>导入备份的 sql 语句</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sql</span><br></pre></td></tr></table></figure>
<p>或者使用 mysql 的 source 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source backup.sql;</span><br></pre></td></tr></table></figure>
<p>如果备份的数据比较大，可以压缩一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -u [username] -p --default-character-set=utf8 [db_name] | gzip &gt; backup.sql.gz</span><br><span class="line">$ gunzip -c backup.sql.gz | mysql -u [username] -p [db_name] 1&gt; load.log 2&gt;err.log</span><br></pre></td></tr></table></figure>
<p>如果想将一台服务器的数据直接导入另外一台机器，可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -u root -p database_name | mysql -h other-host database_name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mysqldump 需要 SELECT 权限，对于没有指定 –single-transaction 选项的还需要 LOCK TABLES 权限。</p>
</blockquote>
<p>对于增量备份，可以使用 binlog。</p>
<p>查看所有的 binlog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       120 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看当前正在写的 binlog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      120 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>导出特定时间的 binlog 以便根据 pos 来进行具体恢复(binlog 是二进制格式，利用 mysqlbinlog 工具导出成 sql)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog --start-datetime=<span class="string">"2018-05-20 9:58:00"</span> --stop-datetime=<span class="string">"2018-05-20 10:01:00"</span> /data/mysql/mysql-bin.000001 &gt; /tmp/mysql_restore.sql</span><br></pre></td></tr></table></figure>
<p>通过 mysql_restore.sql 我们发现只需要恢复到 log_pos 为368312 的位置，则执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog --stop-position=368312 /data/mysql/mysql-bin.000001 | mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>先查询安装了哪些 mysql 的文件，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | grep mysql</span><br><span class="line">mysql-community-libs-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-devel-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-client-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-server-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-common-5.7.21-1.el7.x86_64</span><br><span class="line">mysql-community-libs-compat-5.7.21-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>yum remove</code> 命令卸载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove mysql</span><br><span class="line">$ sudo yum remove mysql-community-common</span><br><span class="line">$ sudo yum -y remove mysql-libs</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果已知旧密码，需要修改 root 密码为新密码，可以这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysqladmin</span><br><span class="line">/usr/bin/mysqladmin</span><br><span class="line">$ /usr/bin/mysqladmin -u root -p password <span class="string">'new-password'</span></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>
<p>如果忘记密码，在 my.cnf [mysqld] 部分最后添加  skip-grant-tables 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>
<p>重启 mysqld</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mysqld restart</span><br></pre></td></tr></table></figure>
<p>使用 root 无需密码登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot</span><br></pre></td></tr></table></figure>
<p>更新密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET password=password(&apos;new-password&apos;) WHERE user = &apos;root&apos; ;</span><br><span class="line">mysql&gt; flush privileges ;</span><br></pre></td></tr></table></figure>
<p>退出，删除 skip-grant-tables 选项并重启 mysqld 即可</p>
<p>参考资料</p>
<p><a href="http://www.ywnds.com/?p=9806" target="_blank" rel="noopener">如何选择 MySQL 版本</a></p>
<p><a href="https://severalnines.com/blog/how-benchmark-performance-mysql-mariadb-using-sysbench" target="_blank" rel="noopener">How to Benchmark Performance of MySQL &amp; MariaDB using SysBench</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">philipyao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/philipyao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sjtutrume@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">philipyao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div style="text-align:center;width:100%;height:50">
   备案号：沪ICP备17048801号
<div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytDLaiT8"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
