<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="PHILIP x BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PHILIP x BLOG">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHILIP x BLOG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>PHILIP x BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PHILIP x BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心有猛虎，细嗅蔷薇</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/30/linux下服务器端口冲突/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/30/linux下服务器端口冲突/" itemprop="url">linux下服务器端口冲突</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-30T16:52:04+08:00">
                2018-08-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/30/linux下服务器端口冲突/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/30/linux下服务器端口冲突/" class="cy_cmt_count" data-xid="2018/08/30/linux下服务器端口冲突/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在生产环境部署服务器集群的时候，由于服务器进程众多，需要监听的端口也非常多，通常我们会通过一定规则为每个进行指定特定的端口来绑定，这没什么问题。</p>
<p>但是由于服务器之间需要通信，因此服务器进程之间会建立大量的 TCP 连接。在主动连接的一方，我们不必类似于监听一样手动 bind 固定的端口，操作系统会为我们随机选择一个端口，来与目的端口进行通信。当连接数量很多时，这种随机选择的端口会和我们指定的端口冲突。（注意 UDP 虽然没有连接的概念，也是要占用端口的）</p>
<p>一种典型的情况是</p>
<ul>
<li><p>进程 A 和 B 启动完成，B 建立了一条连接到 A，本地端口选择为10000</p>
</li>
<li><p>进程 C 恰好监听在端口10000，于是 C 进程启动时就会因为端口被占用而启动失败</p>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决这个问题，我们通常分别约定监听端口和随机选择端口的范围。</p>
<p>例如，在指定监听端口的时候，我们可以指定 5000 - 15000 是可用的监听范围。而本地随机选择的端口范围设置为 15000 - 65000。这样就可以有效避免冲突。</p>
<p>在 linux 下有内核选项可以设置本地端口的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/ip_local_port_range </span><br><span class="line">4000	65000</span><br></pre></td></tr></table></figure>
<p>关于 <code>ip_local_port_range</code> 的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The /proc/sys/net/ipv4/ip_local_port_range defines the local port range that is used by TCP and UDP traffic to choose the local port. </span><br><span class="line">You will see in the parameters of this file two numbers: The first number is the first local port allowed for TCP and UDP traffic on the server, the second is the last local port number. </span><br><span class="line">For high-usage systems you may change its default parameters to 32768-61000 -first-last.</span><br></pre></td></tr></table></figure>
<p>我们利用 <code>sysctl</code> 命令修改其值为<code>15000 65000</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.ip_local_port_range=<span class="string">"15000 65000"</span></span><br></pre></td></tr></table></figure>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p>还有一个很常见的影响端口使用的是连接 TIME_WAIT 状态。</p>
<p>在 TCP 连接关闭时，需要经历四次挥手的过程，而主动发起关闭的一方，发送完最后一个 ACK (最后一步) 后，进入  TIME_WAIT 状态，且需要等待 <code>2MSL</code> 的时间。等待时间过去后，连接关闭。</p>
<p>示意图如下</p>
<p><img src="/images/D0D404D6-3813-412A-B5C5-4333E7F20F5D.png" alt="D0D404D6-3813-412A-B5C5-4333E7F20F5D"></p>
<p><code>MSL(Maximum Segment Lifetime)</code>：报文最大生存时间，用于限制 TCP 包在网络中最大留存时间，超过这个时间，包将被丢弃。IP 层有个类似的 TTL 跳数来决定 IP 报文的去留，MSL 和 TTL 共同限制了 TCP 包的生存时间。由此可知，当网络拥塞时，超过 TCP 生存时间的包会被丢弃，导致丢包。RFC 建议 MSL 为 2 分钟，而 Linux 下为 30 秒。</p>
<p>TIME_WAIT 等待的时间 2MSL 是常量 <code>TCP_TIMEWAIT_LEN</code>（linux 下就是1分钟）定义的，除非重新编译内核，否则不能修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT</span><br><span class="line">                                  * state, about 60 seconds     */</span><br></pre></td></tr></table></figure>
<p>那为什么需要等待 <code>2MSL</code> 的时间呢？</p>
<p><strong>第一个原因</strong>，是为了正常终止通信的一半通道(我方已关闭一半，确保对方也正确关闭另一半)。由于 TCP 是全双工，连接终止时需要双方分别关闭对应的通道。在收到进入 TIME_WAIT 时，肯定一方已经关闭了一半通道且本方收到了关闭另一半通道的 FIN 包，剩下的就是本方发出 FIN 包的 ACK，然后等待接收，完成后整个 TCP 连接就关闭了。</p>
<p>也就是说，进入 TIME_WAIT 状态之后，唯一的步骤就是对方收到 ACK 包之后关闭 TCP。这里的问题就在于万一 ACK 包由于网络拥塞没有及时被对方收到，那一段时间之后，对方会认为是之前发的 FIN 包没有被收到造成的，采取的措施就是重发 FIN 包到本方，那之前丢的那个 ACK 包的最大存活时间是 MSL，重发的 FIN 包也是在 MSL 时间内存活，加起来就是 2MSL 的时间。只要在 2MSL 时间内，其状态一直是 TIME_WAIT，那么就能处理这种丢包的情况。处理完了，就能关闭了（仁至义尽，如果再丢包，那就不管了）。</p>
<p>可以想像一下，如果没有这个 TIME_WAIT 状态而直接关闭呢？如果最后一个 ACK 丢失，那对方会处于 LAST_ACK 状态。这种情况下，如果主动关闭的一方再次发起一次连接到对方，且双方端口也一样，那该条连接相当于被复用，对方在该连接收到新的三次握手的 SYN 包 (并且序列号满足要求) 后，会直接返回 RST，认为包非法。</p>
<p><strong>还有一个原因</strong>，就是让被关闭的连接上所有的包都消逝掉，防止新建的连接误收了之前连接的包。这种情况可能发生吗？</p>
<p>我们假设进入 TIME_WAIT 状态之后只等很短的时间就关闭连接，释放资源，在这里就是之前连接的本方端口可以再次被使用了。如果是客户端主动关闭的，那可以复用的就是之前随机分配的本地端口（客户端 connect 服务器的时候，操作系统随机选择一个本地端口与服务器的固定端口建立连接）；如果是服务器主动关闭的，可以复用的就是之前监听的固定端口。</p>
<p>如果端口被复用后，连接的五元组（双方 IP，双方端口，协议类型）都一样，那么这条连接建立后就很可能接收到之前被关闭的同样五元组的连接的残余包了。（其实我在想，用五元组标识连接有隐患，为啥不再搞个序列号加以区分）。</p>
<p>残余包很可能是比较危险的，例如上面提到的如果本方发出的最后一个 ACK 包没有收到，那对方重发的 FIN 包被新建的连接收到了，那就麻烦了。此外，还可能有延迟收到的普通包。</p>
<p>有了持续 2MSL 时间的 TIME_WAIT 状态，就可以处理延迟包的情况了：收到重发的 FIN 包，再回一个 ACK；收到其他包，直接丢弃。</p>
<p>了解了 TIME_WAIT 状态的原理，我们再来说下其造成的端口冲突情况。</p>
<p>TIME_WAIT 状态，如果是客户端主动断开连接，影响并不大，主要是之前随机选择的本地端口 2MSL 时间内不可用，再建立连接时选一个其他的就可以了。但是如果是服务器主动断开连接呢？我们经常遇到的一种情况就是服务器临时关闭然后重启，此时服务器会主动关闭所有监听端口上已经建立的连接，然后重新启动监听在同一端口。</p>
<p>前面我们也分析了，如果是服务器主动断开的连接，本方端口，也就是监听的端口，在 2MSL 时间内不能再被使用，这造成了我们重启启动进程并监听时，提示『端口已被使用』，启动失败。</p>
<blockquote>
<p>除了 TIME_WAIT，其他状态如 CLOSE_WAIT、ESTABLISHED 状态的连接对应的本方端口也是不可用的</p>
</blockquote>
<p>为了解决这个问题，通常服务器的做法是在设置监听 socket 启用 <code>SO_REUSEADDR</code> 选项重用处于 2MSL 时间内的连接资源。</p>
<p>具体使用可以这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuseaddr = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上 SO_REUSEADDR 选项不仅能重用端口，还能重用 IP 资源。例如一个进程在监听在地址 0.0.0.0:80，而另一个进程可以监听地址 10.1.164.1:80。</p>
</blockquote>
<p>另一种方式是修改 linux 的内核参数 <code>net.ipv4.tcp_tw_reuse</code>，缺省是 0 不开启重用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><br></pre></td></tr></table></figure>
<p>从名字可以想到，这个选项是允许重用处于 TIME_WAIT 状态的 socket 连接。<code>man 7 tcp</code> 的文档中有如下解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_tw_reuse (Boolean; default: disabled; since Linux 2.4.19/2.6)</span><br><span class="line">	Allow  to reuse TIME_WAIT sockets for new connections when it is safe from protocol 	viewpoint.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然选项设置里名字里是 ipv4，对 ipv6 也是适用的。</p>
</blockquote>
<p>其重用原理可能是根据 tcp 的时间戳来区分新老连接的包，具体可以查看 <a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>而另外一个选项 <code>net.ipv4.tcp_tw_recycle</code>意思是开启 TIME_WAIT 状态 sockets 的快速回收。之前 2MSL 时间才回收的连接，很可能很快就被回收（一种说法回收时间是连接的 RTT）。启用之后，对于涉及 NAT 的网络情况会产生一些问题，因此<strong>不建议使用</strong>。似乎该选项在新版的 linux 内核中已经被废弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp_tw_recycle (Boolean; default: disabled; since Linux 2.4)</span><br><span class="line">	Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not recommended 	 since this causes problems when working with NAT  (Network Address Translation).</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<p><a href="https://zhuanlan.zhihu.com/p/20365900" target="_blank" rel="noopener">网络编程（六）：端口那些事儿</a></p>
<p><a href="http://wudaijun.com/2015/10/tcp-notes-2/" target="_blank" rel="noopener">TCP服务器参见问题和参数设置</a></p>
<p><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/Go调度模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/Go调度模型/" itemprop="url">Go调度模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T19:55:54+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/21/Go调度模型/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/21/Go调度模型/" class="cy_cmt_count" data-xid="2018/08/21/Go调度模型/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-的-Runtime"><a href="#Go-的-Runtime" class="headerlink" title="Go 的 Runtime"></a>Go 的 Runtime</h2><p>下面这张图说明了 Go 程序在执行时与操作系统的大致交互原理。</p>
<p><img src="/images/image-20180822155050672.png" alt="image-20180822155050672"></p>
<p>我们编写的 Go 程序除了运行自己的逻辑之外，还会涉及到与操作系统的交互，例如分配内存、创建 goroutine、通过channel与其他 goroutine 进行交互等。那么程序代码和操作系统之间是怎么交互的呢？这就用到了 go 里的 runtime 库。runtime 库主要的功能包含垃圾回收、调度、goroutine 管理等。</p>
<p>上图中程序代码和 runtime 库一起运行在用户空间，并在必要时(例如触发系统调用) 时与操作系统进行交互。</p>
<p>本文我们将只讲述 Runtime 库的调度器，其他不做涉及。</p>
<h2 id="Runtime-Scheduler"><a href="#Runtime-Scheduler" class="headerlink" title="Runtime Scheduler"></a>Runtime Scheduler</h2><h3 id="调度器的必要性"><a href="#调度器的必要性" class="headerlink" title="调度器的必要性"></a>调度器的必要性</h3><p>既然操作系统可以帮助我们来调度线程，那么为什么Go 还要实现一个用户空间级别的调度器呢？</p>
<p>Posix 的线程 API 本质上是对 Unix 进程模型的逻辑扩展，所以有很多类似于进程的控制机制，例如线程有自己的信号掩码，可以被指定到固定的 CPU 上执行，可以被放入 cgroups等等，这些控制机制使得线程运行时有很大的开销(overhead)。想想一下如果随着 goroutine 的增加，你的进程里有100,000个线程的情景。其实对于 goroutine，这些开销并不那么必要。</p>
<p>另外一个问题是垃圾回收时，调度会发生在任意时间点，需要所有线程停止执行，直到待回收的 memory 处于一致性的状态，中间只能等待。而有了 go 的调度器，它只会在线程内存处于一致性的时候进行垃圾回收，也就是说只需要等待那些正在 CPU 上运行的线程(等待他们的内存趋于一致性)。</p>
<h3 id="调度模型"><a href="#调度模型" class="headerlink" title="调度模型"></a>调度模型</h3><p>通常有三种线程调度模型：</p>
<ul>
<li>N:1模型。N 个用户级的线程运行在一个 OS 线程上。由于是多个用户级线程，因此上下文切换很快；但是不能利用到CPU 的多核特性。</li>
<li>1:1模型。本质上是 N:N 的模型，每个用户线程唯一对应了一个 OS 线程，好处是利用了所有的核心，但是线程间上下文切换非常慢，因为要跨越 OS。</li>
<li>M:N 模型。这是 go使用的调度模型。它将任意多个 goroutine 运行在任意数量的 OS 线程上(通常 goroutine 数量要远多于OS线程数量)，既充分利用了多核，又能很快的调度(goroutine 调度)。</li>
</ul>
<h3 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h3><p>为了完成 goroutine 的调度，go 给出了三个概念M、P、G</p>
<p><img src="/images/image-20180822171005278.png" alt="image-20180822171005278"></p>
<p>G 就是我们的 goroutine，是用户级别的调度单位。它有自己的栈、指令指针(IP)及调度器需要的信息、状态等。</p>
<p>M 代表 OS 线程，由操作系统负责管理。M 用来实际执行 G。</p>
<p>P 是一个抽象概念。在 G 被 M 实际执行前，P 负责管理多个待执行的 G。如果 M 中的 G 执行完毕，则会从 P 中 顺序取出另一个待执行的 G 来执行。</p>
<p>通过多个 P 可以将 N:1的调度模型转为 M:N 的模型。每个 P 对应了一个 M 来实际执行 G。</p>
<p>大致的调度示意图如下</p>
<p><img src="/images/image-20180822173934726.png" alt="image-20180822173934726"></p>
<p>图中一共有6个 goroutine，被放入 3 个队列 P1、P2、P3 来调度。其中有 3 个 G 已经在对应的 M 中运行，另外 3 个在队列中等待执行。</p>
<p>那么程序启动后如何选择 P 的数量呢？默认情况下，它等于 CPU 的逻辑核心数。例如我的 Mac 是单 CPU 双核四线程的，则 P 的数量就是4。这个数量也可以通过 <code>GOMAXPROCS</code> 环境变量或者 <code>runtime.GOMAXPROCS()</code> 函数来进行设置，一般来说使用默认的即可。</p>
<p>下面我们分别来看看以下几种场景，调度器如何工作：</p>
<h5 id="场景1：创建-goroutine"><a href="#场景1：创建-goroutine" class="headerlink" title="场景1：创建 goroutine"></a>场景1：创建 <code>goroutine</code></h5><p>goroutine 的创建通过 <code>go func()</code>语句来触发，实际调用的是 <code>runtime.newproc</code> 函数 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用<code>newproc1</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()  <span class="comment">// 获取当前运行的 goroutine G	</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    _p_ := _g_.m.p.ptr()   <span class="comment">// 找到当前 G 所在工作线程 M 所关联的 P </span></span><br><span class="line">	newg := gfget(_p_)     <span class="comment">// 如果 P 有之前创建并回收了的空闲的 G，则复用</span></span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;       <span class="comment">// 没有则新建一个</span></span><br><span class="line">        newg = malg(_StackMin) <span class="comment">// new 一个栈大小为_StackMin(2k)的 G </span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg)</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)	<span class="comment">//新 G 放入 P 的待执行队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可知，新的 goroutine 会被放入到特定 P 的本地执行队列中，如果 P 的本地队列已满，则会放入一个称为『全局队列』的队列，通常全局队列很少用到，大部分操作在本地队列中。</p>
<h5 id="场景2：队列调度"><a href="#场景2：队列调度" class="headerlink" title="场景2：队列调度"></a>场景2：队列调度</h5><p>队列的调度循环主要是<code>schedule</code>函数。</p>
<p>M 执行 G 的时候，需要关联一个 P。当 M 执行完某个 G 时，它会从 P 的等待队列中 pop 出一个新的 G 来执行。注意 P 的待执行本地队列是一个无锁队列，存取都是比较高效。而全局队列会被很多 P 访问，因此加入了锁保证安全性。选择可以执行的 G 通过函数<code>findrunnable()</code>来完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>findrunnable()</code>中，并不总是从本地队列里取，否则全局队列里的 G 将被『饿死』，永远无法执行。为了公平起见，每61次调度检查一下全局队列。此外， go 的网络操作也是整合到 runtime 中的，<code>findrunnable</code> 也会从 network 从寻找阻塞的 G 来执行。</p>
<p>如果以上所有都没有可供执行的 G 呢？我们不能让该工作线程 M 处于空闲状态，必须充分利用。为此，就用到了一种被称为<code>Work-Stealing</code> 的调度算法，当前 P 会尝试从其他的 P 随机选择一个，从中『偷取』一半的 G 放入本队列，于是当前 P 又可以继续调度了。<code>Work-Stealing</code> 保证了整个调度系统内队列的平衡。示意图如下</p>
<p><img src="/images/image-20180822194002035.png" alt="image-20180822194002035"></p>
<h5 id="场景3：执行中断"><a href="#场景3：执行中断" class="headerlink" title="场景3：执行中断"></a>场景3：执行中断</h5><p>我们知道，当一个 G 在 M 中执行时，队列中的其他 G 会处于等待状态，那么如果这个 G 中的代码是个长时间执行的代码，那其他 G 会一直等待，直到 G 执行完成吗？我们通过一段代码来看看。简单起见，我们设置 P 的数量为1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char := ‘a’; char &lt; ‘a’+<span class="number">26</span>; char++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./runtime2 </span><br><span class="line">Starting Go Routines</span><br><span class="line">Waiting To Finish</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 </span><br><span class="line">Terminating Program</span><br></pre></td></tr></table></figure>
<p>可见，前一个 goroutine 执行完成之后才会执行下一个 goroutine。</p>
<blockquote>
<p>这里注意，goroutine 的执行顺序和代码里的顺序正好相反，是因为最新创建的 goroutine 被放入了优先执行队列 runnext 里。所以后创建的 goroutine 反而最优先执行。</p>
</blockquote>
<p>有没有可能是前一个 G 执行太快导致后一个G 没来得及执行？为此我们将后一个 goroutine 改为死循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果显示，打印数字的 goroutine 永远得不到执行。</p>
<p>那 goroutine 可能被中断执行吗？答案是 yes。正在运行的 goroutine 中如果有以下操作，将会导致其被中断执行</p>
<ul>
<li>系统调用 (例如打开一个文件)</li>
<li>time.Sleep</li>
<li>channel 读写操作</li>
<li>sync 包中的锁操作</li>
<li>网络 IO </li>
<li>主动调用 runtime.Sched()</li>
</ul>
<p>中断执行的 M 及其 G，会从对应的 P 上 detach，进入阻塞状态，等待系统调用或者其他操作的完成。而 P 会尝试寻找另一个可用的 M，使其可以继续调度后续的 G 来执行。一般可以从空闲的 M 中选择一个，如果没有空闲的 M，则新创建一个 M（OS 线程）来 attach 到 P 上，如下图所示</p>
<p><img src="/images/image-20180822205943304.png" alt="image-20180822205943304"></p>
<p>我们看到</p>
<ul>
<li>线程 M0 放弃了它关联的 P，开始等待阻塞的 OS 调用的完成；</li>
<li>P 找到了一个线程 M1(空闲的或者新建的) 继续调度；</li>
<li>当 M0上的 OS 调用完成后，它需要找到一个可用的 P 来继续执行返回的 G 上的代码</li>
<li>如果没有找到可用的 P，则 M0 会将其上的 G 放到全局队列，自身进入空闲状态，被动等待其他 P 调用</li>
</ul>
<p>这里我们利用一段代码来实验下这个特性。现在在死循环过程中周期性的插入系统调用代码。常用的 fmt.Printf 打印信息到标准输出，就包含一个典型的系统调用 syscall.Write (syscall 包里还有很多其他系统调用)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            a++</span><br><span class="line">            <span class="keyword">if</span> a % <span class="number">1e9</span> == <span class="number">0</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"\nperiodly syscall."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./runtime6</span><br><span class="line">Starting Go Routines</span><br><span class="line">Waiting To Finish</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 </span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">periodly syscall.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>显然另一个 goroutine 也得到了调度运行。</p>
<p>而如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到一个 wait 队列中，这个队列会是 channel 的发送或接收队列或者网络 IO 的等待队列；而 M 会尝试运行下一个 runnable 的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，在 wait 队列中的 G 会被唤醒，标记为runnable，放入到某P的队列中，绑定一个 M 继续执行。</p>
<p>这里我们使用 http 包来拉取百度首页为例来测试网络 IO 的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%v start\n"</span>, idx)</span><br><span class="line">            _, err := http.Get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%v error %v\n"</span>, idx, err)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%v end\n"</span>, idx)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Terminating Go Routines"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go run runtime6.go </span><br><span class="line">Starting Go Routines</span><br><span class="line">0 start</span><br><span class="line">1 start</span><br><span class="line">2 start</span><br><span class="line">3 start</span><br><span class="line">4 start</span><br><span class="line">2 end</span><br><span class="line">1 end</span><br><span class="line">0 end</span><br><span class="line">3 end</span><br><span class="line">4 end</span><br><span class="line">Terminating Go Routines</span><br></pre></td></tr></table></figure>
<p>可见网络 IO 确实触发了 goroutine 的执行中断。</p>
<p>综上可以知道：</p>
<p><strong>即使设置 GOMAXPROCS 为1，程序仍然可能会执行在多个OS线程上，即实际上的并发执行(非并行执行)</strong></p>
<h5 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h5><p>G-P-M模型的实现算是Go scheduler的一大进步，但Scheduler仍然有一个头疼的问题，那就是不支持抢占式调度，导致一旦某个G中出现死循环或永久循环的代码逻辑，也没有导致中断执行的调用，那么G将永久占用分配给它的P和M，位于同一个P中的其他G将得不到调度，出现『<strong>饿死</strong>』的情况。更为严重的是，当只有一个P时(GOMAXPROCS=1)时，整个Go程序中的其他G都将“饿死”。于是Dmitry Vyukov又提出了《<a href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#!" target="_blank" rel="noopener">Go Preemptive Scheduler Design</a>》并在<a href="https://blog.golang.org/go12" target="_blank" rel="noopener">Go 1.2</a>中实现了『抢占式』调度。</p>
<p>这个抢占式调度的原理则是在每个函数或方法的入口，加上一段额外的代码 (morestack调用)，让runtime有机会检查是否需要执行抢占调度。这种解决方案只能说局部解决了“饿死”问题，对于没有函数调用，纯算法循环计算的G，scheduler依然无法抢占。为此，我们利用下面这段代码看看抢占式的调用是否起效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfn</span><span class="params">(ptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ptr != <span class="literal">nil</span> &#123;</span><br><span class="line">        (*ptr)++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dummy</span><span class="params">(ptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    myfn(ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Starting Go Routines"</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number := <span class="number">1</span>; number &lt; <span class="number">27</span>; number++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d "</span>, number)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        a := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            dummy(&amp;a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序是对前面一段死循环赋值程序的改写，使用了函数调用。需要注意的是，在编译时候需要禁用编译器优化，否则简单函数将被内联优化掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=<span class="string">"-N -l"</span> runtime5.go</span><br></pre></td></tr></table></figure>
<p>另外，为什么不直接调用 <code>myfn</code> 函数，而是中间再插入一个<code>dummy</code>函数呢？那是因为 <code>myfn</code> 函数位于调用树的leaf（叶子）位置，compiler可以确保其不再有新栈帧生成，不会导致栈分裂或超出现有栈边界，于是就不再插入morestack 来检查是否需要进行抢占式调度。具体实验过程可以参考 TonyBai 的 <a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="调度追踪"><a href="#调度追踪" class="headerlink" title="调度追踪"></a>调度追踪</h2><p>golang 的 runtime 库提供了 GODEBUG 来输出调试信息，通过 schedtrace=X 选项可以使调度器每隔一定时间向标准错误输出调度状态。我们利用该选项追踪一下下面这段代码的调度过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    wg.Add(num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> work(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait to see the global run queue deplete.</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e10</span>; i++ &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 GODEBUG 来观察调度器的执行情况 (使用默认的 GOMAXPROCS = 4) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./runtime4</span><br><span class="line">SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=2 spinningthreads=0 idlethreads=0 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 3008ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 4012ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 5018ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 6026ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br><span class="line">SCHED 7035ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=3 [2 0 1 0]</span><br><span class="line">SCHED 8041ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 9046ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 10055ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 11055ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 12056ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br><span class="line">SCHED 13064ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 14072ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 15074ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 16083ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 17087ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 18095ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br><span class="line">SCHED 19097ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>首先看下 1000ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>此时，4个工作线程 M 刚刚被创建，对应 4 个 P，并处于 idle 状态；另有 2 个线程被 runtime 使用，一共是 6 个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [2 1 2 1]</span><br></pre></td></tr></table></figure>
<p>在 2006ms，idleprocs 为 0，表示 4 个 procs 均处于工作状态，各持有一个 G，剩余的 6 个 G 分别放置在4个 P 对应的本地队列中 （ 2 + 1 + 2 + 1），全局队列中有 0 个 G</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 7035ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=3 [2 0 1 0]</span><br></pre></td></tr></table></figure>
<p>在 7035ms，有 3 个 G 执行完成，放入全局队列中等待结束，再从 3 个 P 中取出 3 个 G 放入 M 中执行，因此全局队列和本地队列数量分别是 <code>runqueue=3 [2 0 1 0]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 8041ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=4 [1 0 1 0]</span><br></pre></td></tr></table></figure>
<p>在 8041ms，又有一个 G 执行完成，放入全局队列中，再从其关联的 P 中取出一个 G 放入 M 中执行，因此全局队列和本地队列数量分别是 <code>runqueue=4 [1 0 1 0]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 13064ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>在 13064ms，此时没有待执行的 G 了，只有 4 个正在执行的 G，其余 6 个都已经执行完毕并退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 17087ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]</span><br></pre></td></tr></table></figure>
<p>在17087ms，所有 G 执行完毕，<code>idleprocs=4</code>，所有 proc 处于空闲状态</p>
<p>更详细的关于追踪的情况，可以参考 William Kennedy 写的博客 [ Scheduler Tracing In Go]<a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html</a></p>
<p>参考资料</p>
<p><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener"> Scheduler Tracing In Go</a></p>
<p><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">The Go scheduler</a></p>
<p><a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="noopener">Analysis of the Go runtime scheduler</a></p>
<p><a href="https://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener">Golang源码探索(二) 协程的实现原理</a></p>
<p><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">也谈goroutine调度器</a></p>
<p><a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="noopener">Goroutine调度实例简要分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/c-c-编译过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/c-c-编译过程/" itemprop="url">c/c++编译过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T14:35:40+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/21/c-c-编译过程/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/21/c-c-编译过程/" class="cy_cmt_count" data-xid="2018/08/21/c-c-编译过程/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C/C++ 是高级编译型语言，执行的时候需要将容易阅读的源码编译成机器可以识别的机器指令，交由 CPU 执行。这篇文章我们来研究一下编译是怎样一个过程。</p>
<p>绝大多数编译器并不是一个单一的庞大程序，它通常由六七个稍小的程序组成，这些程序由一个叫做『编译器驱动器』(compiler driver) 的控制程序来调度。整个编译过程大致可以分为四个主要阶段：</p>
<ul>
<li>预编译</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ul>
<p>我们以一个简单的 c 程序来举例，c 代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(a, b) (a + b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// here is comment</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"DEBUG defined\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> DEBUG not defined!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addition is: %d\n"</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 centos 环境利用 gcc 进行编译，添加选项 <code>-save-temps</code> 我们可以获取编译过程每个阶段产生的临时文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -save-temps -DDEBUG filename.c -o filename</span><br></pre></td></tr></table></figure>
<p>可以看到分别生成了以下文件</p>
<p><img src="/images/image-20180821150535977.png" alt="image-20180821150535977"></p>
<p>其中</p>
<p><code>filename.c</code> 源码文件 </p>
<p><code>filename.i</code> 预编译后文件</p>
<p><code>filename.s</code> 汇编文件</p>
<p><code>filename.o</code> 编译目标文件</p>
<p><code>filename</code> 链接后的可执行文件</p>
<p>下面我们分别看看每个阶段具体在进行哪些操作。</p>
<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译阶段，编译器驱动调动预编译器处理 <strong>预编译指令</strong> ，所谓预编译指令是指以 <code>#</code> 开头的指令，主要有注释、宏、头文件包含、条件编译等，因此这个阶段包括以下几个操作</p>
<ul>
<li>去除注释</li>
<li>展开宏定义</li>
<li>展开头文件包含</li>
<li>条件编译<code>#ifdef</code>、<code>#ifndef</code> 处理</li>
<li>error 抛出错误信息</li>
</ul>
<p>我们打开预编译后的 <code>filename.i</code> 文件可以看到：注释被去除了，参数宏 <code>add(a, b)</code> 也被 <code>(a + b)</code> 替换，包含的头文件 <code>&lt;stdio.h&gt;</code> 中的内容被拷贝到源文件 <code>filename.c</code> 中；此外编译时候有没有指定 <code>-DDEBUG</code> 得到的结果 (是否有<code>myfunc</code>) 也不一样。</p>
<blockquote>
<p>其他的预编译指令还包括 pragma、 line 等，这里就不详细说明了</p>
</blockquote>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译阶段，主要将扩展的源码文件如<code>filename.i</code> 编译成汇编文件<code>filename.s</code>，该文件包含了很多汇编指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  1     .file   &quot;filename.c&quot;</span><br><span class="line">  2     .section    .rodata</span><br><span class="line">  3 .LC0:</span><br><span class="line">  4     .string &quot;DEBUG defined&quot;</span><br><span class="line">  5     .text</span><br><span class="line">  6 .globl myfunc</span><br><span class="line">  7     .type   myfunc, @function</span><br><span class="line">  8 myfunc:</span><br><span class="line">  9 .LFB0:</span><br><span class="line"> 10     .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16 </span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    call    puts</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret </span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   myfunc, .-myfunc</span><br><span class="line">    .section    .rodata</span><br><span class="line">.LC1:</span><br><span class="line">    .string &quot;addition is: %d\n&quot;</span><br><span class="line">    .text</span><br><span class="line">.globl main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16 </span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    movl    $5, -8(%rbp)</span><br><span class="line">    movl    $4, -4(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    -8(%rbp), %edx</span><br><span class="line">    addl    %eax, %edx</span><br><span class="line">    movl    $.LC1, %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret </span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  &quot;GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-17)&quot;</span><br><span class="line">    .section    .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>整个编译过程包含词法与语义分析，源代码优化，目标代码生成、目标代码优化等阶段。</p>
<h2 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(<strong>Assembly</strong>)</h2><p>该过程通过调度汇编器(as)来完成，将汇编指令文件<code>filename.s</code> 翻译成与处理器结构有关的机器指令文件<code>filename.o</code>，这是一个二进制文件，不能直接查看，用 <code>file</code> 命令查看可知</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file filename.o </span><br><span class="line">filename.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure>
<p>这一个64位 <code>ELF</code> 文件，可以使用 <code>objdump -x</code> 命令来查看所有文件头，包含符号表和重定位信息等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -x filename.o</span><br><span class="line"></span><br><span class="line">filename.o:     file format elf64-x86-64</span><br><span class="line">filename.o</span><br><span class="line">architecture: i386:x86-64, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x0000000000000000</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000049  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       0000001f  0000000000000000  0000000000000000  0000008c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002e  0000000000000000  0000000000000000  000000ab  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d9  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000e0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*	0000000000000000 filename.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     F .text	0000000000000010 myfunc</span><br><span class="line">0000000000000000         *UND*	0000000000000000 puts</span><br><span class="line">0000000000000010 g     F .text	0000000000000039 main</span><br><span class="line">0000000000000000         *UND*	0000000000000000 <span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line">000000000000002f R_X86_64_32       .rodata+0x000000000000000e</span><br><span class="line">000000000000003e R_X86_64_PC32     <span class="built_in">printf</span>-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br><span class="line">0000000000000040 R_X86_64_PC32     .text+0x0000000000000010</span><br></pre></td></tr></table></figure>
<p>上面符号表里的 <code>text</code> 表示在代码段找到了定义，而有 <code>UND</code> 标识的 <code>puts</code>函数和<code>printf</code>函数因为属于库函数，尚未链接进来，因此属于未定义。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>该阶段由编译器驱动程序驱动链接器(ld)来完成。ld 将生成目标文件所需要的所有<code>.o</code> 文件和需要链接的库文件(动态链接库或者静态库) 一起链接成目标文件，主要包含：地址和空间分配（<code>Address and Storage Allocation</code>），符号决议（<code>Symbol Resolution</code>），重定位（<code>Relocation</code>）等。</p>
<p>链接主要分为动态连接和静态链接。对于静态链接，ld 会将静态库的代码直接加到可执行文件中，因此文件大小比较大。而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。</p>
<p>GCC 默认使用动态链接方式链接库文件。对比目标文件<code>filename.o</code> 和我们链接完成的可执行文件 <code>filename</code>大小可知，<code>text</code> 部分增加的大小为必要的描述信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ size filename.o</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">    192	      0	      0	    192	     c0	filename.o</span><br><span class="line">$ size filename</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">   1319	    500	     16	   1835	    72b	filename</span><br></pre></td></tr></table></figure>
<p>再看<code>file</code>命令的输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file filename</span><br><span class="line">filename: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.18, not stripped</span><br></pre></td></tr></table></figure>
<p>可见与上面的<code>filename.o</code>不同的是该文件已经链接(GCC 默认动态连接 Linux 的 c 运行时库 libc.so.6，即 glibc )</p>
<p>此外，利用 ldd 命令可以看到可执行程序依赖的动态链接库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ldd -v filename</span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007fff36f24000)</span><br><span class="line">	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8f61001000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f8f613a0000)</span><br><span class="line"></span><br><span class="line">	Version information:</span><br><span class="line">	./filename:</span><br><span class="line">		libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6</span><br><span class="line">	/lib64/libc.so.6:</span><br><span class="line">		ld-linux-x86-64.so.2 (GLIBC_PRIVATE) =&gt; /lib64/ld-linux-x86-64.so.2</span><br><span class="line">		ld-linux-x86-64.so.2 (GLIBC_2.3) =&gt; /lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用一个图来表示整个编译的过程如下</p>
<p><img src="/images/image-20180821172053123.png" alt="image-20180821172053123"></p>
<p>参考资料</p>
<p>&lt;C专家编程&gt;</p>
<p><a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/" target="_blank" rel="noopener">Compiling a C program:- Behind the Scenes</a></p>
<p><a href="http://smilejay.com/2012/01/c_compilation_stages/" target="_blank" rel="noopener">C程序编译过程浅析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/GCC分支预测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/GCC分支预测/" itemprop="url">分支预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T18:01:28+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/20/GCC分支预测/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/20/GCC分支预测/" class="cy_cmt_count" data-xid="2018/08/20/GCC分支预测/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GCC-扩展-builtin-expect"><a href="#GCC-扩展-builtin-expect" class="headerlink" title="GCC 扩展 __builtin_expect"></a>GCC 扩展 __builtin_expect</h2><p>C 语言的标准从最开始的 K&amp;R C演变到目前的 ANSI C，在各操作系统平台已经有很多编译器支持了，如 MSVC、GCC、CLANG 等。而 linux 平台的 GCC 除了支持ANSI C 标准之外，还有自己的编译器扩展特性。</p>
<p>其中一个特性就是GCC 支持的编译器分支预测 __builtin_expect 宏，作为编译分支时候的暗示。这个特性在 linux 的内核代码中很常用，用来提升代码执行速度。</p>
<p>具体的，是有 likely 和 unlikely 这两个宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>
<p>实际使用时，我们可以在很大可能执行的分支前面加上 likely。例如下例中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (likely(a))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hula!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Woo~\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，如果 likely 所在的分支如果有非常大可能执行，则程序运行效率要比普通的分支判断高。具体原因是什么呢？这就涉及到 CPU 流水线作业的相关知识。</p>
<h2 id="CPU-流水线"><a href="#CPU-流水线" class="headerlink" title="CPU 流水线"></a>CPU 流水线</h2><p>这里我们以 Intel 发明的 X86结构的 CPU 为例来大致讲述下 CPU 流水线技术的演进。</p>
<p>CPU 在执行程序的时候依赖于很多寄存器，例如通用寄存器、段寄存器、索引寄存器等。此外还有一个很重要的寄存器：指令指针(IP)。指令指针寄存器是一个拥有特殊功能的指针。指令指针的功能是指向将要运行的下一条指令。</p>
<p>所有的X86处理器都按照相同的模式运行。首先，根据指令指针指向的地址取得下一条即将运行的指令并解析该指令（译码）。在译码完成后，会有一个指令的执行阶段。有些指令用来从内存读取数据或者向内存写数据，有些指令用来执行计算或者比较等工作。当指令执行完成后，这条指令会通过退出(retire)阶段并将指令指针修改为下一条指令。</p>
<p>译码，执行和退出的分阶段模式组成了X86处理器指令执行的基本模式。从最初的8086处理器到新的酷睿i7处理器都基本遵循了这样的过程。</p>
<p>1989年 i486引入了五级流水线模式，分别是：取指(Fetch)，译码(D1, main decode)，转址(D2, translate)，执行(EX, execute)，写回(WB)。之前的三级模式，并不是流水线，每一条指令必须等待前一条指令执行完退出之后才能继续执行。而这种新引入的五级流水线模式，可以同时运行多条指令，每一级流水线在同一时刻都运行着不同的指令。这个设计使得i486比同频率的386处理器性能提升了不止一倍。五级流水线中的取指阶段(F)将指令从指令缓存中取出；第二级为译码阶段(D1)，将取出的指令翻译为具体的功能操作；第三级为转址阶段(D2)，用来将内存地址和偏移进行转换；第四级为执行阶段(EX)，指令在该阶段真正执行运算；第五级为退出阶段(WB)，运算的结果被写回寄存器或者内存。由于处理器同时运行了多条指令，大大提升了程序运行的性能。 </p>
<p><img src="/images/image-20180820190943347.png" alt="image-20180820190943347"></p>
<p>流水线化通过同时执行一系列操作增加了吞吐量(throughput)，但是她并没有减少延迟，即并没有减少一条指令从执行开始到执行结束的时间，仍要等到这一系列指令完成。实际上,流水线化由于将一条指令拆分成了几个步骤从而可能会增加延迟。</p>
<h2 id="CPU-分支猜测"><a href="#CPU-分支猜测" class="headerlink" title="CPU 分支猜测"></a>CPU 分支猜测</h2><p>流水线技术的主要目的就是通过重叠连续指令的步骤来提高吞吐量从而获得性能，要做到这一点，就必须能够实现确定要执行指令的序列和先后顺序，这样才能使流水线中充满了待执行的指令。当处理器遇到分支条件跳转时，通常不能确定执行那个分支，因此处理器采用分支预测器来猜测每条跳转指令是否会执行。如果猜测比较可靠，那么流水线中就会充满指令。但是，如果对跳转的指令猜测错误，那么就要要求处理器丢掉它这个跳转指令后的所有已做的操作，然后再开始用从正确位置处起始的指令去填充流水线，可以看到这种预测错误会导致很严重的性能惩罚，会导致大约20-40个时钟周期的浪费，从而导致性能的严重下降。</p>
<p>一个很直观的说明 CPU 的分支预测器的例子是 stackoverflow 上的提问： <a href="http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array" target="_blank" rel="noopener">Why is processing a sorted array faster than an unsorted array?</a> </p>
<p>一段排序和未排序过的代码执行速度差别很大，具体代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// generate data</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> arraySize = <span class="number">32768</span>;</span><br><span class="line">    <span class="keyword">int</span> data[arraySize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">        data[c] = <span class="built_in">std</span>::rand() % <span class="number">256</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序这行不注释掉下面的for循环会快得多</span></span><br><span class="line">    <span class="built_in">std</span>::sort(data, data + arraySize); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// primary loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">                sum += data[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> elapsedTime = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(clock() - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elapsedTime &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在我的 Mac 上运行的结果分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 未排序</span><br><span class="line">21.3109</span><br><span class="line">sum = 312426300000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 排序后</span><br><span class="line">6.30532</span><br><span class="line">sum = 312426300000</span><br></pre></td></tr></table></figure>
<p>这里影响代码执行的主要片段是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">    sum += data[c];</span><br></pre></td></tr></table></figure>
<p>对于这段分支代码的执行，CPU 会启用分支预测(branch prediction)，排序和未排序的不同正是分支预测是否有大概率命中。对于命中的情况，CPU 指令可以一路顺畅的执行；而对于预测失败的情况，处理器要flush掉pipelines，回滚到之前的分支，然后重新热启动，选择另一条路径，这里的性能损失非常大。</p>
<p>那么一般怎么做分支预测呢？答案就是根据历史结果来做决定。对于排序的情况，很容易根据历史结果做出决策:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T = branch taken</span><br><span class="line">N = branch not taken</span><br><span class="line"></span><br><span class="line">data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...</span><br><span class="line">branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...</span><br><span class="line"></span><br><span class="line">       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)</span><br></pre></td></tr></table></figure>
<p>而如果未排序的数组，则其取到的结果完全随机，分支预测基本无效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...</span><br><span class="line">branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...</span><br><span class="line"></span><br><span class="line">       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)</span><br></pre></td></tr></table></figure>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面说的 CPU 分支预测是属于硬件层面，其实从上层的软件或者程序员角度也是可以协助做好分支预测的。还是回到我们最开始提到的__builtin_expect 宏，示例代码反汇编得到的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.LC1:</span><br><span class="line">    .string &quot;Hula!&quot;</span><br><span class="line">.LC2:</span><br><span class="line">    .string &quot;Woo~&quot;</span><br><span class="line"> </span><br><span class="line">    call    __isoc99_scanf</span><br><span class="line">    movl    28(%esp), %eax</span><br><span class="line">    testl   %eax, %eax</span><br><span class="line">    je  .L2</span><br><span class="line">    movl    $.LC1, (%esp)</span><br><span class="line">    call    puts</span><br><span class="line">.L3:</span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line">.L2:</span><br><span class="line">    movl    $.LC2, (%esp)</span><br><span class="line">    call    puts</span><br><span class="line">    jmp .L3</span><br></pre></td></tr></table></figure>
<p>对于使用了 likely 的分支，其指令将更靠近 <code>testl</code> 分支判断，CPU 在执行分支判断指令的同时，将预先取出后续指令进行执行，而另一个分支指令则需要进行跳转(<code>je .L2</code>)。其本质是优化 CPU 的指令顺序，提高流水线的执行效率。</p>
<p>此外，编写代码时，我们也要注意分支的先后顺序，尽量将概率大的分支放在前面，尽量合并分支，尽量使用排序后的数据来判断，适当使用 goto 和 do while 来优化代码组织等。</p>
<p>参考资料</p>
<p><a href="http://blog.jobbole.com/40844/" target="_blank" rel="noopener">CPU流水线的探秘之旅</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22469702" target="_blank" rel="noopener">深入理解CPU的分支预测(Branch Prediction)模型</a></p>
<p><a href="https://www.zhihu.com/question/27650017" target="_blank" rel="noopener">如何在 C++ 代码中提示编译器某个分支的执行概率高？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/无锁队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/无锁队列/" itemprop="url">无锁队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T12:51:37+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/14/无锁队列/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/14/无锁队列/" class="cy_cmt_count" data-xid="2018/08/14/无锁队列/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>无锁队列是一种广泛使用的数据结构</p>
<h2 id="单读单写"><a href="#单读单写" class="headerlink" title="单读单写"></a>单读单写</h2><p>我们先看下最简单的一种情况，就是一个生产者负责写，一个消费者负责读的情况。</p>
<p>这种情况通常是利用环形缓冲区 RingBuffer （有时候也称为 circular queue）来实现，那首先看看 RingBuffer 是怎么实现读写的。</p>
<p><img src="../../../../../../image-20180830113817331.png" alt="image-20180830113817331"></p>
<h5 id="RingBuffer-实现"><a href="#RingBuffer-实现" class="headerlink" title="RingBuffer 实现"></a>RingBuffer 实现</h5><p>一个数组buff，大小是 SIZE，两个指针变量 head 和 tail 来表示队列的头和尾。写的时候，控制 tail 加1；读的时候，控制 head 加1。</p>
<ul>
<li>初始状态，数组为空，tail 和 head 都为 0</li>
<li>写入元素时，tail 加1向后更新</li>
<li>读取元素时，head 加1向后更新</li>
<li>由于数组大小size有限，tail 或者 head指针不能永远向后增加，当到达数组尾部（指向<code>size-1</code>）的时候，需要绕回到数组开头，实现的时候使用 <code>val = (val + 1) % size</code> 取余即可</li>
<li>绕回的机制正是环形缓冲的特色，因此 head 和 tail 的前后关系可能会一直变化</li>
<li>队列为空时，读取失败，此时 head 和 tail 相等</li>
<li>队列满时，写入失败，规定如果 tail + 1后，做可能的回绕，然后检查 tail 和head 是否相等，如果相等则满。这种约定浪费了一个元素的位置不让写入，从而保证写满时，head 和 tail差一个元素而不是相等，和队列为空的情况区分开来。此时的情况是可能是<ol>
<li>tail 在前，head 在后且为 0， tail - head = size - 1 ，此时队列里除最后一个元素外全满，tail + 1 回绕后和head 都为 0</li>
<li>head 在前，tail 在后，且 head - tail = 1，tail 加1后和 head 相等</li>
</ol>
</li>
</ul>
<p>PUSH</p>
<p><img src="/images/image-20180830140357796.png" alt="image-20180830140357796"></p>
<p>POP</p>
<p><img src="/images/image-20180830140426815.png" alt="image-20180830140426815"></p>
<p>EMPTY</p>
<p><img src="/images/image-20180830140237745.png" alt="image-20180830140237745"></p>
<p>FULL</p>
<p><img src="/images/image-20180830140102099.png" alt="image-20180830140102099"></p>
<p>下面看下实现代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_RING_BUFFER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_RING_BUFFER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingBuffer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    RingBuffer() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RingBuffer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(_tail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[_tail] = item;</span><br><span class="line">        _tail = nextTail;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[_head];</span><br><span class="line">        _head = increment(_head);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _tail;</span><br><span class="line">    <span class="keyword">int</span> _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_RING_BUFFER_H_</span></span></span><br></pre></td></tr></table></figure>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>现在回到初始的单读单写的情况，生产者调用 push() 来唯一控制 tail 的更新，而消费者调用 pop() 来唯一控制 head 的更新。<br>实际实现时，通常分步，写入（或读取）缓冲区内容，更新指针。我们要保证：</p>
<ul>
<li>对 tail 和 head 指针的更新必须是原子的</li>
<li>读的时候，先读取缓冲区内容，再更新 head</li>
<li>写的时候，先写入内容到缓冲区，再更新 tail</li>
</ul>
<p>关于 int 类型赋值的原子性，C++ 标准是没有定义的，依赖于编译器的实现和系统架构的内存对齐策略等。</p>
<p>根据 <a href="https://www.codeproject.com/script/Membership/View.aspx?mid=4385931" target="_blank" rel="noopener">KjellKod.cc</a> 的文章的说法，大部分现代处理器上，对于自然对齐的基础类型的读写是原子的，不会出现读一半或者写一半的情况。对于 x86 和 x64 平台，长度大于8的类型，其读写不保证是原子的。而对于我们的 head 和 tail，在 32 位处理器和 64 位处理器上大小分别是 4 和 8 (注：int 的大小和平台和编译器实现有关，这里说法不准) ，因此可以保证是原子的。其英文原话是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">On almost all modern processors, reads and writes of naturally aligned native types are atomic. This means that as long as the memory bus is at least as wide as the type being read or written the CPU reads and writes will happen in a single bus transaction. This makes it impossible for other threads to see them half-completed.</span><br><span class="line"></span><br><span class="line">For x86 and x64 platforms, types larger than 8 bytes are not guaranteed to be atomic. But in our example the head and tail indexes are integers of size 32bits (4 bytes) on 32-bit processor or 64bits (8bytes) on a 64-bit processor, thus making reading and writing them atomic.</span><br><span class="line"></span><br><span class="line">// Example of integers</span><br><span class="line">counter++;                // 1. not atomic operation, but three operations</span><br><span class="line">counter = 0;              // 2. this write is atomic</span><br><span class="line">other_variable = counter; // 3. this read is atomic</span><br><span class="line"></span><br><span class="line">For fun, you can compile the operations above to assembly language or use the debugger to view the disassembly. You should then see that the actual store only takes one instruction.</span><br><span class="line"></span><br><span class="line">On multiple core CPUs, this is also true. A word in memory must be coherent between all cores when it is written (using one CPU instruction). It is simply not allowed or even possible to split a 4 byte writing (I use a 32-bit example) between cores, since a word (4 bytes) is written as a single instruction.</span><br><span class="line"></span><br><span class="line">In short. Reads and writes of tail and head are atomic. First is still OK.</span><br></pre></td></tr></table></figure>
<p>保险的措施是使用c++11中的 <code>std::atomic</code> 来保证原子性。我们修改下 head 和 tail 定义后的 ssqueue 结构(single producer &amp; single consumer queue) 如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    SSQueue() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~SSQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currTail = _tail.load();</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(currTail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head.load()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[currTail] = item;</span><br><span class="line">        _tail.store(nextTail);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currHead = _head.load();</span><br><span class="line">        <span class="keyword">if</span> (currHead == _tail.load()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[currHead];</span><br><span class="line">        _head.store(increment(currHead));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _tail;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_SSQUEUE_H_</span></span></span><br></pre></td></tr></table></figure>
<h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><p>由于都是分步执行，中间有可能被打断。但是只要保证了读写缓冲区的和更新指针的顺序，就能保证无锁的安全性。</p>
<p>现在来分析一下打断的情况：<br>假如读的时候，消费者先读取了缓冲区内容，而未来得及更新 head，执行权就被生产者抢占，于是生产者读的 head 就是老的，类似快照数据。但这并没有太大影响，顶多是极端情况下由于没有更新head 导致生产者认为队列满而写入失败，下次继续写就可以了；如果队列没满，写入不受影响。<br>同样的道理，假如写的时候，生产者先写入内容到缓冲区(也可能是写一部分)，而未来得及更新 tail，执行权就被消费者抢占，于是消费者读到的 tail 也是老的。这也没有多大影响，顶多是极端情况下由于没有更新tail导致消费者认为队列空而读取失败，下次继续读就读到数据了；如果队列非空，读取不受影响。</p>
<p>这里特别注意的是，head 和 tail 指针永远只由一方来更新，且是单方向更新。</p>
<p>那是不是代码里先写缓冲区操作，再写更新指针操作就可以了呢？答案是否。</p>
<p>编译器优化我们的代码时，可能会改变代码的执行顺序，反应在汇编指令的前后顺序调整。这是编译时乱序。</p>
<p>上面提到的利用 volatile 修饰的 int 变量，vs 和 gcc 编译器似乎都能保证其汇编指令顺序，但是没有得到权威的资料证明 (<a href="https://blog.csdn.net/xtlisk/article/details/39098981" target="_blank" rel="noopener">查看</a>)</p>
<p>此外，由于现代CPU普遍采用了多级流水线技术，一条指令的执行是多级流水线协同完成。为了提高执行效率，可以同时执行多条指令；而且随着分支预测和乱序执行的引入，互不依赖的两条指令在执行时是不保证先后顺序的，这是运行时乱序。</p>
<p>编译器开发者和cpu厂商都遵守着内存乱序的基本原则，简单归纳如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能改变单线程程序的行为</span><br></pre></td></tr></table></figure>
<p>在单线程环境，我们不必关心内存乱序的影响。而此时，我们关注的恰恰是多线程执行的情况，如何保证我们代码的顺序执行就是需要解决的关键问题。</p>
<p>一种方式是依赖 <code>volatile int</code> 的一种实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>这里特别指出，volatile 关键字语义上只是提示编译器不要优化该变量，本质上和顺序执行没有任何关系。有说法是 volatile 的使用保证读写变量时其汇编指令顺序不会变更，但是没有可靠依据。</p>
<p>而对于执行乱序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU Reordering Summary for x86 and x64 Platforms</span><br><span class="line"></span><br><span class="line">1. Reads moving ahead of other reads: No</span><br><span class="line">2. Writes moving ahead of other writes: No</span><br><span class="line">3. Writes moving ahead of reads: No</span><br><span class="line">4. Reads moving ahead of writes: Yes</span><br></pre></td></tr></table></figure>
<p>由 2、3 两条保证了写的顺序不被置于读之前，且写之间顺序不乱。</p>
<p>同样，保险的方式还是使用平台无关的机制：c++11提供的内存屏障。</p>
<h5 id="Acquire-Release-内存屏障代码"><a href="#Acquire-Release-内存屏障代码" class="headerlink" title="Acquire-Release 内存屏障代码"></a>Acquire-Release 内存屏障代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKIT_SSQUEUE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; Capacity = Size+<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    SSQueue() : _tail(<span class="number">0</span>), _head(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~SSQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currTail = _tail.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">auto</span> nextTail = increment(currTail);</span><br><span class="line">        <span class="keyword">if</span> (nextTail == _head.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//full</span></span><br><span class="line">        &#125;</span><br><span class="line">        _array[currTail] = item;</span><br><span class="line">        _tail.store(nextTail, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T* item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> currHead = _head.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (currHead == _tail.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//empty</span></span><br><span class="line">        &#125;</span><br><span class="line">        *item = _array[currHead];</span><br><span class="line">        _head.store(increment(currHead), <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (idx + <span class="number">1</span>) % Capacity;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _tail;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; _head;</span><br><span class="line">    T   _array[Capacity];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PKIT_SSQUEUE_H_</span></span></span><br></pre></td></tr></table></figure>
<p><a href="http://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/" target="_blank" rel="noopener">http://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/</a></p>
<p>参考资料</p>
<p><a href="https://sites.google.com/site/kjellhedstrom2/threadsafecircularqueue" target="_blank" rel="noopener">Lock-Free Single Producer - Single Consumer Circular Queue 1</a></p>
<p><a href="https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular" target="_blank" rel="noopener">Lock-Free Single-Producer - Single Consumer Circular Queue 2</a></p>
<p><a href="https://blog.csdn.net/xtlisk/article/details/39098981" target="_blank" rel="noopener">无锁环形队列，volatile和乱序执行</a></p>
<p><a href="http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484" target="_blank" rel="noopener">volatile vs. volatile</a></p>
<p><a href="https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword-in-c" target="_blank" rel="noopener">Why do we use volatile keyword in C++?</a></p>
<p><a href="http://lday.me/2017/12/02/0018_cpp_atomic_summary/" target="_blank" rel="noopener">C++内存屏障（内存顺序）总结</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/tcp-ip备忘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/tcp-ip备忘/" itemprop="url">tcp/ip备忘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T13:11:03+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/13/tcp-ip备忘/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/13/tcp-ip备忘/" class="cy_cmt_count" data-xid="2018/08/13/tcp-ip备忘/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/匹配系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/匹配系统设计/" itemprop="url">匹配系统设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-12T14:03:05+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/12/匹配系统设计/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/12/匹配系统设计/" class="cy_cmt_count" data-xid="2018/08/12/匹配系统设计/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/帧同步实现实时对战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/帧同步实现实时对战/" itemprop="url">帧同步实现实时对战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T23:26:55+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/11/帧同步实现实时对战/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/11/帧同步实现实时对战/" class="cy_cmt_count" data-xid="2018/08/11/帧同步实现实时对战/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/日志组件实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/日志组件实现/" itemprop="url">日志组件实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T23:24:08+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/11/日志组件实现/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/11/日志组件实现/" class="cy_cmt_count" data-xid="2018/08/11/日志组件实现/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/定时器实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/定时器实现/" itemprop="url">定时器实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T15:03:01+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/11/定时器实现/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/08/11/定时器实现/" class="cy_cmt_count" data-xid="2018/08/11/定时器实现/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>定时器是游戏开发中常用的基础组件，本文介绍几种定时器组件的实现方法。</p>
<h2 id="Linux-内核定时器实现"><a href="#Linux-内核定时器实现" class="headerlink" title="Linux 内核定时器实现"></a>Linux 内核定时器实现</h2><p>Linux 内核的定时器从1997年之后基本没有修改过，最终版本是使用时间轮算法的定时器。定时器的最大设置超时范围是 2^32 个jiffies。设置 jiffie 为毫秒级或者秒级，就可以控制定时器的精度。例如 jiffie 设置为100ms，即1秒相当于10个jiffie，则定时器的最大范围是</p>
<p>2^32 / 10 / 86400 = 4971 天</p>
<p>该实现主要提供了以下接口添加或者删除定时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer = add_timer(expire)</span><br><span class="line">del_timer(timer)</span><br></pre></td></tr></table></figure>
<p>定时器的超时 <code>expire</code> 被定义位 n 个 jiffies</p>
<p>如果定时器超时，则调用注册的回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer-&gt;fn(timer-&gt;data)</span><br></pre></td></tr></table></figure>
<p>最初始定时器的实现采用的是最简单的方式，就是将所有的定时器串成一个有序的双向链表。</p>
<p>这种方式添加定时器的方式就是从前往后遍历顺序链表，找到合适的位置插入，时间复杂度是 o(n)；删除定时器则非常简单，是 o(1)复杂度；超时复杂度也是 o(1)。这种定时器的实现方式缺点在与管理大量定时器时，效率不高。</p>
<p>另一种能想到的定时器实现方式，是使用二叉排序树。左子树的超时时间比右子树的超时时间小，于是每次添加定时器时只需要二分查找，因此复杂度是 o(log(N))；删除和超时则是 o(1)；</p>
<p>还有一种方式，就是申请 2^32个桶，然后每个桶中维护一个 list 用来存放定时器，而每个 jiffie 对应一个桶，定时器的插入操作就是简单的索引到桶，然后执行 list_add() 操作，时间复杂度变为 o(1)；同样的，删除和超时都是 o(1) 操作。其实这就是最初版本的基于时间轮的算法，如下图所示</p>
<p><img src="/images/image-20180811184344832.png" alt="image-20180811184344832"></p>
<p>这种方式时间复杂度是最低的，但是其需要的内存空间巨大，尤其是在定时器数量不多的时候，是个很大的浪费。</p>
<p>那么，有没有一种方式是对这种桶方式的改进，能同时满足时间复杂度和空间复杂度呢？这就是目前采用的多精度时间轮算法。多精度有种很形象的比喻，就是平时看到的水表</p>
<p><img src="/images/image-20180811170405558.png" alt="image-20180811170405558"></p>
<p>在上面的水表中，为了表示度量范围，分成了不同的单位，比如 1000，100，10 等等，相似的，表示一个 32bits 的范围，也不需要 2^32 个元素的数组。</p>
<p>具体实施时，将所有的 jiffie 分成5组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1..256, 257..16384, 16385..1048576, 1048577..67108864, 67108865..4294967295</span><br></pre></td></tr></table></figure>
<p>第一组，就是即将到期的256个jiffie，为每个 jiffie 分配一个桶(bucket)，一共是256个桶。 这里每个桶里定时器的到期时间都是相同的，精度为1jiffie。</p>
<p>第二组，我们分为64个桶，每个桶里存放接下来到期的256个 jiffie 对应的定时器。在这里，可以看到桶里定时器的到期时间是不同的，也就是精度是256 jiffies。</p>
<p>第三组，还是分为64个桶，于是每个桶的精度就是 256 * 64  = 16384 jiffies。</p>
<p>第四组，还是分为64个桶，每个桶的精度是 256 <em> 64 </em> 64 =  1048576 jiffies。</p>
<p>最后一组，依旧分为64个桶，每个桶的精度是 256 <em> 64 </em> 64 * 64 = 67108864 jiffies。</p>
<p>最终我们用到的桶的数量是 256+64+64+64+64 = 512 buckets。也就是说我们通过控制桶的精度，将2^32个 jiffies (32 bits) 分成了 8 + 6 + 6 + 6 + 6 bits 。可能有人问了，为什么这么分呢，为什么不是  8 + 8 + 8 + 8 ? 从作者的回复来看，主要是  256 + 256 + 256 + 256 = 1024个桶，这比512个桶空间占用多。</p>
<p>那么如何插入定时器呢？首先根据定时器的 expire 来定位到放到哪一组中，然后再定位到具体的桶 index。注意，除了第一组之外其他组的桶中，定时器的到期时间都可能是不同的。例如到期时间分别是 260 jiffies 和 265 jiffies 的定时器都会被放入第二组的第一个桶中( 257 jiffies ~ 512jiffies 都在这个桶中)。这表示这些桶中的定时器是『部分排序的』，本质上是对他们的高位进行排序。插入定时器的操作只是定位到具体的桶 index，然后执行 list_add() 操作(链表本身不需要排序)，时间复杂度是 o(1)；而删除也是一样定位组和桶 index，时间复杂度 o(1)。</p>
<p>问题是怎么执行定时器的超时呢？第一组里的256个桶没有问题，我们只需要在时间轮的指针逐次增加1并指向对应的 jiffies 时，执行其对应桶里的所有定时器即可。那如果指针指向第 257 jiffie 呢？从前面的分析我们可以知道，第 257 jiffie 指向的桶里可能包含 257 jiffies ~ 512 jiffies 这 256个 jiffies 的定时器，它们是非顺序地存储在桶的链表内，不能直接执行。执行前，需要做的就是将这个桶里的所有定时器全部重新映射到第一组的256个桶里，即将粗精度的定时器重新进行细精度的划分/排序。由于时间指针已经指向第257 jiffies，那么第二组第一个桶里的所有定时器的相对超时时间必定都减少了256 jiffies，因为重新添加时，会落到第一组的细精度桶区间内。同样的过程，我们在指针指向第三组 (16385jiffies ~ 1048576jiffies) 的定时器时，将这组里各桶的定时器重新添加映射到前面两组的桶内。后面各组的执行也类似。</p>
<p>重新添加/映射完成之后，每次我们只用执行相对于定时器指针相差 256个 jiffies 的定时器(也就是总是执行第一组里的定时器)，如果超过256则再继续执行重新添加/映射，再执行映射后的第一组，如此循环。</p>
<p>本质上，这种策略称为一种『延迟排序』，即定时器在很久到期时，我们对其进行粗粒度的排序，即只排序高位，就是定位放入哪个桶即可，从而提高效率。而当快要执行时，才将其进行细粒度排序及定位。这带来一个很明显的好处是，如果定时器不执行(即到期前就被删除)，由于添加和删除的时间复杂度都是 o(1)，其效率将非常高。</p>
<p>在定时器的实际使用时，很多确实是没有到期即被删除。可以想像下大量防止网络超时的定时器。</p>
<h2 id="最小堆定时器"><a href="#最小堆定时器" class="headerlink" title="最小堆定时器"></a>最小堆定时器</h2><p>最小堆也是实现定时器的一种常用方式，例如 libevent 库的定时器就是使用的最小堆优先级队列。Golang 官方库中的 timer 也是使用的最小堆原理。</p>
<p>所谓最小堆，其实是一颗特殊的二叉树，其所有节点的值都比左右子节点的值要小。因此整个二叉树的最小值就在 root 元素。每次检查定时器是否到期时，我们检查 root 元素是否到期即可。同时，这棵二叉树又是一个完全二叉树。如果一棵二叉树除了最右边位置上一个或者几个叶结点缺少外其它是填满的，那么这样的二叉树就是完全二叉树。严格的定义是：若设二叉树的高度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，就是完全二叉树。下面这几颗二叉树都是完全二叉树</p>
<p><img src="/images/image-20180811231451262.png" alt="image-20180811231451262"></p>
<p>其基本类似于下面这个形状：</p>
<p><img src="/images/image-20180811222313955.png" alt="image-20180811222313955"></p>
<p>那如何表示一颗完全二叉树呢？只需要一个数组即可。首先将完全二叉树进行从上到下，从左到右编号：</p>
<p><img src="/images/image-20180811222554940.png" alt="image-20180811222554940"></p>
<p>通过上图我们发现如果完全二叉树的一个父结点编号为 k，那么它左儿子的编号就是 2<em>k，右儿子的编号就是 2</em>k+1。如果已知儿子（左儿子或右儿子）的编号是 x，那么它父结点的编号就是 x/2，注意这里只取商的整数部分。在 C 语言中如果除号‘/’两边都是整数的话，那么商也只有整数部分（即自动向下取整），即 4/2 和 5/2 都是 2。另外如果一棵完全二叉树有 N 个结点，那么这个完全二叉树的高度为 log2 N 简写为 log N，即最多有 log N 层结点。</p>
<p>如果我们现在想添加一个定时器，也就是新增一个节点(例如值为3)，该如何操作呢？只需要直接将新元素插入到末尾，再根据情况判断新元素是否需要上移，直到满足堆的特性为止。如果堆的大小为 N（即有 N 个元素），那么插入一个新元素所需要的时间也是 O(logN)。</p>
<p><img src="/images/image-20180811223611152.png" alt="image-20180811223611152"></p>
<p>先将 3 与它的父结点 25 比较，发现比父结点小，为了维护最小堆的特性，需要与父结点的值进行交换。交换之后发现还是要比它此时的父结点 5 小，因此需要再次与父结点交换。至此又重新满足了最小堆的特性。</p>
<p>向上调整的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftup</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//传入一个需要向上调整的结点编号i</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>; <span class="comment">//用来标记是否需要继续向上调整</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)  <span class="keyword">return</span>; <span class="comment">//如果是堆顶，就返回，不需要调整了    </span></span><br><span class="line">    <span class="comment">//不在堆顶 并且 当前结点i的值比父结点小的时候继续向上调整 </span></span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; flag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否比父结点的小 </span></span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;h[i/<span class="number">2</span>])</span><br><span class="line">            swap(i,i/<span class="number">2</span>);<span class="comment">//交换他和他爸爸的位置 </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag=<span class="number">1</span>;<span class="comment">//表示已经不需要调整了，当前结点的值比父结点的值要大 </span></span><br><span class="line">        i=i/<span class="number">2</span>; <span class="comment">//这句话很重要，更新编号i为它父结点的编号，从而便于下一次继续向上调整 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器到期又是如何处理呢？根据最小堆的特性，先到期的就是 root 节点，因此执行定时器函数后，我们将 root 元素删除，同时将堆的最后一个节点移动到 root 位置，然后看是不是需要执行向下调整，以保持最小堆的特性。</p>
<p>向下调整的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftdown</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,flag=<span class="number">0</span>;<span class="comment">//flag用来标记是否需要继续向下调整 </span></span><br><span class="line">    <span class="comment">//当i结点有儿子的时候（其实是至少有左儿子的情况下）并且有需要继续调整的时候循环窒执行</span></span><br><span class="line">    <span class="keyword">while</span>( i*<span class="number">2</span>&lt;=n &amp;&amp; flag==<span class="number">0</span> )</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">//首先判断他和他左儿子的关系，并用t记录值较小的结点编号 </span></span><br><span class="line">        <span class="keyword">if</span>( h[i] &gt; h[i*<span class="number">2</span>] )</span><br><span class="line">            t=i*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t=i; </span><br><span class="line">        <span class="comment">//如果他有右儿子的情况下，再对右儿子进行讨论 </span></span><br><span class="line">        <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span> &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果右儿子的值更小，更新较小的结点编号  </span></span><br><span class="line">            <span class="keyword">if</span>(h[t] &gt; h[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">                t=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的  </span></span><br><span class="line">        <span class="keyword">if</span>(t!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(t,i);<span class="comment">//交换它们，注意swap函数需要自己来写</span></span><br><span class="line">            i=t;<span class="comment">//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag=<span class="number">1</span>;<span class="comment">//则否说明当前的父结点已经比两个子结点都要小了，不需要在进行调整了 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果要在定时器到期之前删除它，就类似于删除最小堆的任一节点。方式是将最后一个节点放置到该删除的节点，然后从该节点开始执行向下调整，直到整个堆又满足最小堆的特性，本质上和定时器到期时删除 root 节点的思路是一致的。时间复杂度也是 O(logN)。</p>
<p>参考资料</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-timers/index.html" target="_blank" rel="noopener">Linux 下定时器的实现方式分析</a></p>
<p><a href="https://lwn.net/Articles/156329/" target="_blank" rel="noopener">kernel timer design</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/binary-tree.html" target="_blank" rel="noopener">极客时间：二叉树</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">philipyao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/philipyao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sjtutrume@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">philipyao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div style="text-align:center;width:100%;height:50">
   备案号：沪ICP备17048801号
<div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytDLaiT8"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
