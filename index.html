<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="PHILIP x BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PHILIP x BLOG">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHILIP x BLOG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>PHILIP x BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PHILIP x BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心有猛虎，细嗅蔷薇</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/Go研究之内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/Go研究之内存管理/" itemprop="url">Go研究之内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-30T22:05:15+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/12/30/Go研究之内存管理/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/12/30/Go研究之内存管理/" class="cy_cmt_count" data-xid="2018/12/30/Go研究之内存管理/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考资料</p>
<p><a href="https://povilasv.me/go-memory-management/" target="_blank" rel="noopener">Go Memory Management</a></p>
<p><a href="https://andrestc.com/post/go-memory-allocation-pt1/" target="_blank" rel="noopener">Go’s Memory Allocator - Overview</a></p>
<p><a href="https://juejin.im/post/5c137f35f265da616f6fda3a" target="_blank" rel="noopener">技术分享：内存管理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/818虚拟内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/818虚拟内存/" itemprop="url">818虚拟内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:16:58+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/12/21/818虚拟内存/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/12/21/818虚拟内存/" class="cy_cmt_count" data-xid="2018/12/21/818虚拟内存/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说明：本文大部分内容参考了 &lt;深入理解计算机系统&gt; 一书中关于虚拟内存的讲解，综合了自己的一些理解及其他资料，可以认为是一篇读书笔记。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>现代处理器为了更加有效的管理物理内存并减少出错，提出了 “虚拟内存” 的概念，英文是 Virual Memory (VM)。虚拟内存是对内存空间的一种抽象表示，为每个进程提供一个大的、一致的和私有的地址表示。它有以下特性：</p>
<ul>
<li>将物理内存看成一个存储在磁盘上的地址空间的高速缓存，该缓存只保存进程内的活动区域，并根据需要在磁盘和内存之间来回交换数据。</li>
<li>每个进程有自己私有的独立的虚拟内存空间，对内存的操作都是通过虚拟内存间接进行的，保证了每个进程的内存不被其他进程破坏。</li>
<li>虚拟内存空间和物理内存空间有特有的映射关系，访问内存时，会将虚拟地址翻译为物理地址。</li>
</ul>
<h2 id="虚拟内存的工作机制"><a href="#虚拟内存的工作机制" class="headerlink" title="虚拟内存的工作机制"></a>虚拟内存的工作机制</h2><h3 id="物理寻址和虚拟寻址"><a href="#物理寻址和虚拟寻址" class="headerlink" title="物理寻址和虚拟寻址"></a>物理寻址和虚拟寻址</h3><p>计算机的内存被组织成一个由 M 个连续的字节大小的单元组成的数组，每个字节都有唯一的物理地址 (Physical Address, PA)。早期的 CPU 在寻址时采用直接访问物理地址的方式，称为物理寻址。现代CPU都普遍采用一种称为虚拟寻址的方式来寻址，如下图所示：</p>
<p><img src="/images/image-20181221175910154.png" alt="image-20181221175910154"></p>
<p>使用虚拟寻址，CPU 通过虚拟地址 (Virtual Address, VA) 来访问内存，这个虚拟地址在被送到内存之前先转换成物理地址，这个转换过程是通过 CPU 芯片上的内存管理单元 (Memory Management Unit, MMU) 来完成的。</p>
<h3 id="地址空间与虚拟内存状态"><a href="#地址空间与虚拟内存状态" class="headerlink" title="地址空间与虚拟内存状态"></a>地址空间与虚拟内存状态</h3><h5 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h5><p>不管是物理内存还是虚拟内存，都是有大小限制的，也因此对应了一段特定大小的地址空间。</p>
<p>现代系统通常支持 32 位 或 64 位 地址空间，也就是可以表示的最大地址为 <code>1 &lt;&lt; 32 (即4G)</code> 或者 <code>1 &lt;&lt; 64</code> 。 对于 64 位的情况，目前实际可支持的空间还没有这么大。例如 <code>Intel Core i7</code> 处理器，支持 48 位 (256T) 虚拟地址空间和 52 位 (4PB) 物理地址空间，还有一个兼容模式，支持 32 位 (4GB) 的虚拟和物理地址空间。</p>
<h5 id="页面-Page"><a href="#页面-Page" class="headerlink" title="页面 Page"></a>页面 Page</h5><p>概念上，虚拟内存被组织为一个由存放在磁盘上的 N 个连续字节组成的数组。每个字节都有一个唯一的地址，作为数组的索引。但实际工作时，并不是直接通过这个索引来定位内存。VM 系统通过将虚拟内存分割为虚拟页 (Virtual Page, VP) ，这是一种大小固定的内存块，在 X86 上，这个页的大小通常为 4K 个字节；类似的，物理内存也被同样大小的物理页 (Physical Page, PP)。在定位一个具体的内存地址时，是通过页号加页内偏移量来进行的。如果是一个 4G 大小的内存，就可能被分为 <code>4G / 4K = 1024</code> 个页面。</p>
<h5 id="虚拟页状态"><a href="#虚拟页状态" class="headerlink" title="虚拟页状态"></a>虚拟页状态</h5><p>任意时刻，虚拟内存的页面 (VP, Virtual Page) 都是下面三种状态中的一种</p>
<ul>
<li>还未被分配</li>
<li>已分配，缓存在物理内存中</li>
<li>已分配，未缓存，在磁盘中</li>
</ul>
<p>虚拟内存在生成时，默认就是未分配的状态；当程序运行时第一次访问到该地址时，才会去实际分配内存。分配时，如果物理内存足够，则直接将地址内容缓存在物理内存中；而当物理内存不足时，则需要将物理内存中暂时不用的部分给交换出去，写在磁盘上。空出来的部分就可以被分配了。如果要访问的虚拟内存页面已经被分配，但是未缓存在物理内存上，则同样会触发内存和磁盘之间的交换，将暂时不同的内容换出到磁盘，而将要访问的内容从磁盘上换入到物理内存中。</p>
<p>下图是一个这三种状态的简单展示</p>
<p><img src="/images/image-20181221180023209.png" alt="image-20181221180023209"></p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>同任何缓存系统一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在物理内存的某个地方。如果是，系统还必须确定这个虚拟页存放在物理内存的哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个暂时不用的页，并将虚拟页的内容从磁盘复制到物理内存中，替换掉该暂时不用的页。</p>
<p>这些功能是由软硬件联合提供的，包括系统内核、CPU芯片中MMU中的地址翻译硬件和一个存放在物理内存中叫做页表 (Page Table) 的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件需要将虚拟地址转换为物理地址时，都会读取页表。系统内核负责维护页表的内容，以及在磁盘和物理内存之间交换页。下图展示了一个页表的基本组织结构：</p>
<p><img src="/images/image-20181221180104513.png" alt="image-20181221180104513"></p>
<p>页表是由一个个页表条目 (Page Table Entry, PTE) 组成的数组。虚拟地址空间中的每个页通过一定的换算规则，在页表中一个固定偏移量处都对应一个 PTE。可以假设 PTE 由一个有效位和一个 n 位的地址字段组成。有效位表明了该虚拟页当前是否被缓存在物理内存中。如果设置了有效位，那地址字段就表示物理内存中相应物理页的起始位置，这个物理页中缓存了该虚拟页。如果未设置有效位，那么一个空地址表示虚拟页还未分配。否则对于非空地址，地址字段就指向虚拟页在磁盘上的起始位置。</p>
<h5 id="寻址情形"><a href="#寻址情形" class="headerlink" title="寻址情形"></a>寻址情形</h5><p>下面根据上文提到的页表，我们来分析一下寻址时涉及的几种情形。</p>
<h6 id="页分配"><a href="#页分配" class="headerlink" title="页分配"></a>页分配</h6><p>虚拟内存页的分配过程，是在磁盘上创建空间并且更新页表中的对应 PTE 条目。下图中 VP5 的分配就是创建磁盘空间后将 PTE5 的地址指向该空间地址。注意，这里并不立即在物理内存里缓存该页，而是等分配好的页被实际访问时才会实际分配物理内存。</p>
<p><img src="/images/image-20181222195635912.png" alt="image-20181222195635912"></p>
<h6 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h6><p>当 CPU 需要访问一个虚拟地址时，地址翻译硬件会将根据虚拟地址计算出一个索引，根据索引定位到页表上的某个 PTE。页命中就是指该 PTE 的有效位为1，表示要访问的内容已经缓存在物理内存中了，因此直接命中。根据 PTE 中地址字段中保存的物理内存的位置，直接去物理内存中找到内容。</p>
<p>例如下图中，根据虚拟地址定位出 PTE 在 PTE2 的位置，其地址字段保存的内容指向了物理内存的 PP1，直接命中。</p>
<p><img src="/images/image-20181222200529760.png" alt="image-20181222200529760"></p>
<h6 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h6><p>缺页 (Page Fault) 简单说就是未命中。当 CPU 需要访问一个虚拟地址时，地址翻译硬件会将根据虚拟地址计算出一个索引，根据索引定位到页表上的某个 PTE。缺页就是指该 PTE 的有效位为0，表示未缓存在物理内存中，此时 PTE 中地址字段中保存的是虚拟页对应的磁盘位置。缺页时会触发一个缺页异常，缺页异常会调用内核中的缺页异常处理程序，该程序会在物理内存中选择一个暂时不用的页，准备将其交换出去。如果该页已经被修改多，则会被复制到磁盘。该选中的页会被待访问的磁盘页覆盖，从而实现了换入换出。</p>
<p>下图描述了缺页的大致处理流程图。页表由内核维护在内存中。</p>
<p><img src="/images/image-20181223135120553.png" alt="image-20181223135120553"></p>
<p>下图的例子中，由于 PTE3 对应的是磁盘中 VP3 地址，而此时物理内存不足，我们选择将 PP3 中的 VP4 换出，而将 VP3 存入其中，并更新 PTE3，最后返回给 CPU。</p>
<p><img src="/images/image-20181222202459967.png" alt="image-20181222202459967"></p>
<h5 id="交换区"><a href="#交换区" class="headerlink" title="交换区"></a>交换区</h5><p>前面我们说了，一个进程的虚拟空间的页面，可能缓存在物理内存中，也可能被换出到磁盘中。这部分磁盘空间就称为交换分区。在 Linux 上安装系统时往往需要指定 swap 分区，就是交换区，Windows 上也有类似概念，不过不用手动指定。</p>
<h5 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h5><p>每次 CPU 访问虚拟地址，MMU就必须去内存中的页表查询一个 PTE，以便将虚拟地址翻译为物理地址。查询一次内存的开销是几十到几百个 CPU 周期。为了消除这样的开销，在 MMU 中设计了一个关于 PTE 的小的缓存，称为<strong>翻译后备缓冲器</strong> (Translation Lookaside Buffer, TLB)。TLB 中的每一行都保存着一个由单个 PTE 组成的块。</p>
<h2 id="CPU寻址流程"><a href="#CPU寻址流程" class="headerlink" title="CPU寻址流程"></a>CPU寻址流程</h2><p>CPU 寻址的大致的流程如下：</p>
<ul>
<li>CPU 拿到虚拟地址后，将其传给 MMU </li>
<li>MMU 查询自己维护的 TLB 缓存，看能否直接找到对应的 PTE。如果找到，则直接获取到物理地址并将其发送到内存，内存将数据返回给 CPU 从而完成寻址流程</li>
<li>TLB 未命中时，则会去查询内存中页表，找到 PTE。(注意，在查询页表前，也可能会去查询内存的高速缓存)。一般都会使用具有层次结构的多级页表，以节省页表空间大小。</li>
<li>根据 PTE 中的有效位字段，如果为 1，则页命中，根据 PTE 地址字段中的物理地址信息构造出物理地址，然后将其发送到内存，内存将数据返回给 CPU 完成寻址流程</li>
<li>如果 PTE 中表明未缓存，即缺页，则触发缺页异常，磁盘页和物理内存页进行交换。完成后更新 PTE 中的内容，并继续访问内存，获取数据之后完成 CPU 寻址</li>
</ul>
<p><img src="/images/image-20181223153246985.png" alt="image-20181223153246985"></p>
<h3 id="TLB-查询"><a href="#TLB-查询" class="headerlink" title="TLB 查询"></a>TLB 查询</h3><p>下图是 TLB 查询的过程。</p>
<p><img src="/images/image-20181223150834055.png" alt="image-20181223150834055"></p>
<p>上图可见，查询 TLB 是通过虚拟地址的高位部分：虚拟页 VPN 来进行的。查询时，VPN 被分解为 TLB 标记和 TBL 索引。</p>
<p><img src="/images/image-20181223151736508.png" alt="image-20181223151736508"></p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>CPU 寻址时，在 MMU 中的 TLB 未命中的情况下，需要根据页表找到物理地址，这个过程称为地址翻译。一个虚拟地址，分为虚拟页号 (VPN) 和 虚拟页偏移量 (VPO) 。类似的，物理地址也可以分为物理页号 (PPN) 和 物理页偏移量 (PPO)。由于虚拟页和物理页大小一般是一致的 (Linux 中是 4K)，因此在做地址翻译时，可以保持偏移量不变，只翻译页号。VPN 作为页表索引找到页表中的 PTE，如果命中，PTE 中的地址字段就是物理页号 PPN。最终的物理地址就是由 PPN 和偏移量组合而成。</p>
<p>下面的图很形象的表示了这个过程：</p>
<p><img src="/images/image-20181222205519279.png" alt="image-20181222205519279"></p>
<p>对于多级页表，VPN 实际是被拆分成多个，以对应多级页表项。情况如下：</p>
<p><img src="/images/image-20181223150037292.png" alt="image-20181223150037292"></p>
<p>下面是 <code>Intel Core i7</code> CPU 的寻址示意图：</p>
<p><img src="/images/259AC393-20C2-41C0-8A27-0E2910A3503E.png" alt="259AC393-20C2-41C0-8A27-0E2910A3503E"></p>
<h2 id="多进程内存管理"><a href="#多进程内存管理" class="headerlink" title="多进程内存管理"></a>多进程内存管理</h2><p>虚拟内存的设计，给了内存管理极大的灵活性和便利性。由于每个进程都有自己独立的虚拟地址和页表映射，这保证了各进程之间内存的独立，也有利于多进程之间的内存共享和保护。</p>
<h3 id="内存隔离与共享"><a href="#内存隔离与共享" class="headerlink" title="内存隔离与共享"></a>内存隔离与共享</h3><p>每个进程都有自己独立的虚拟内存，和自己的页表(由系统内核代码维护)，也就是每个进程都有自己的虚拟内存空间，这保证了各进程之间的寻址互不影响。由系统维护的寻址过程能杜绝各进程之间内存的非法访问。如果进程之间想共享内存，也是可以利用进程共享机制来实现（例如 Linux 的 mmap 系统调用）。下图中进程 i 和进程 j 就共享了同一物理页面 <code>PP7</code>，而虚拟页面不同：进程 i 的<code>VP2</code> 和进程 j 的 <code>VP1</code>。</p>
<p><img src="/images/image-20181221162312505.png" alt="image-20181221162312505"></p>
<p>独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不用管代码和数据实际存放在物理内存的何处。</p>
<ul>
<li><p>相同的内存排布。 对于 64 位地址空间的 Linux 进程，虚拟地址总是从 0x400000 开始，分成多个段来存放不同部分，且增长方向一样。这样的一致性，极大简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件独立于物理内存中代码和数据的最终位置。</p>
</li>
<li><p>程序的加载。对于程序的加载，使用虚拟内存也很方便。可执行文件中的 <code>.text</code> 代码段和 <code>.data</code> 数据段，在被 load 进进程内存时，会被分配虚拟内存页，然后在页表中把他们标记为 <strong>已分配未缓存</strong> 状态，页表中的地址则指向可执行文件中的磁盘位置。只有当程序实际运行时，对应的虚拟地址被访问，才触发缺页，执行换入换出，将实际内容页面从磁盘加载到内存中并引用。</p>
</li>
<li>物理内存共享。进程之间经常要共享代码和数据，这能显著节约内存使用。例如，进程需要调用相同的操作系统内核代码，调用相同的库函数 (例如 C 库函数 printf )，我们不用每个进程都维护一份副本，共享就可以了。</li>
<li>简化内存分配。如果进程需要分配一段连续的内存，可能包含了 N 个虚拟页，由于虚拟内存的映射是各个页分别映射的，所以分配出来的物理内存就可以不是连续的，因此分配操作起来更灵活，这可以显著提高物理内存利用率和分配效率。</li>
</ul>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>利用页表中的控制选项，可以控制对特定内存的保护，杜绝非法访问。哪些访问属于非法访问呢？例如程序不能修改只读的代码指令，否则问题就大了；此外，用户进程也不能直接读或者修改内核段的代码和数据，用户空间对内核空间的操作唯一的入口应该是系统调用。</p>
<p><img src="/images/image-20181221162414432.png" alt="image-20181221162414432"></p>
<h2 id="Linux的虚拟内存"><a href="#Linux的虚拟内存" class="headerlink" title="Linux的虚拟内存"></a>Linux的虚拟内存</h2><h3 id="进程内存排布"><a href="#进程内存排布" class="headerlink" title="进程内存排布"></a>进程内存排布</h3><p>基本所有使用虚拟内存的系统，会为每个进程维护了一个单独的虚拟地址空间。整个空间大致分为了内核地址空间和用户地址空间。</p>
<p>下图是 Linux 和 Windows 平台的空间划分示意：</p>
<p><img src="/images/image-20181226212413439.png" alt="image-20181226212413439"></p>
<p>简单起见，我们主要介绍 Linux的虚拟内存。</p>
<p>内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存中的某些区域被映射到所有共享进程的物理页面。内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<p>用户地址空间被组织成一些区域 (也叫做段) 的集合。例如，代码段、数据段、堆、共享库段以及用户栈。</p>
<p><img src="/images/image-20181221163637036.png" alt="image-20181221163637036"></p>
<p>下图记录了一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的结构 (task_struct)   。</p>
<p><img src="/images/image-20181223160605710.png" alt="image-20181223160605710"></p>
<p>一个段的结构就如下：</p>
<ul>
<li><p>vm_start: 指向这个段的起始处</p>
</li>
<li><p>vm_end: 指向这个段的结束处</p>
</li>
<li><p>vm_prot: 描述这个段内包含的所有页的读写许可权限</p>
</li>
<li><p>vm_flags: 描述这个段内的页面是与其他进程共享的，还是这个进程私有的</p>
</li>
<li><p>vm_next: 指向链表中下一个段结构</p>
</li>
</ul>
<h3 id="Linux-缺页异常处理"><a href="#Linux-缺页异常处理" class="headerlink" title="Linux 缺页异常处理"></a>Linux 缺页异常处理</h3><p>前面我们讲过，页表中发生缺页时，会触发缺页异常，调用系统内核的异常调度程序来处理。那 Linux 的缺页是如何调度的呢？</p>
<p>1）首先，检查虚拟地址是否合法？是落入某个段的区域中吗？为了回答这个问题，缺页处理程序依次搜索段结构的链表，检查其 vm_start 和 vm_end。如果地址非法，则触发段错误，并终止程序。</p>
<p>2）其次，试图进行的内存访问是否合法？即进程是否有读、写或者执行这个段内页面的权限？例如，试图对代码段中的只读页面进行写操作？或者是用户进程的代码试图访问内核空间的代码或数据？如果是，则触发异常，并终止程序。</p>
<p>3）如果是正常缺页，则选择一个牺牲页，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。</p>
<p><img src="/images/image-20181223162633760.png" alt="image-20181223162633760"></p>
<h2 id="虚拟内存使用"><a href="#虚拟内存使用" class="headerlink" title="虚拟内存使用"></a>虚拟内存使用</h2><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内核将虚拟内存和一个磁盘上的对象关联起来，以初始化这个虚拟内存的内容，这个过程称为内存映射 (<code>memory mapping</code>)。文件的内容直接映射到内存中，操作内存相当于直接直接操作文件。映射时文件被分成页大小的片，每一片包含一个虚拟页的初始内容。由于按需页面调度的策略，这些虚拟页面没有实际交换进入物理内存，直到CPU开始访问这些虚拟地址时才触发缺页，从而将页面内容从磁盘文件中换入物理内存。</p>
<p>被映射的文件可以是</p>
<ul>
<li><p>磁盘普通文件。程序可执行文件就是一个典型例子。程序开始执行时，系统会将可执行文件的 <code>.text</code> 和 <code>.data</code> 部分直接映射到进程虚拟内存的 <code>Text</code> 段和 <code>Data</code> 段；程序链接的动态链接库，如常用的标准 C 库 <code>libc.so</code> 在加载时是映射到进程的虚拟内存内，由于动态链接库没有必要每个进程都维护一份私有的，所以会将其映射到共享区域内；</p>
</li>
<li><p>匿名文件。匿名文件是由内核创建，全部设置为二进制零，然后映射到虚拟内存中。进程的 <code>BSS</code> 段、堆、栈段就是映射到匿名文件的；</p>
</li>
</ul>
<p>下面是上述各种映射的示意图：</p>
<p><img src="/images/image-20181227171515705.png" alt="image-20181227171515705"></p>
<p>除了以上的系统的自动映射，用户程序还可以调用系统 API 来进行手动的内存映射。例如，Linux 上的 <code>mmap()</code> 系统调用，Windows 上的API <code>CreateFileMapping()/MapViewOfFile()</code> 都可以操作映射文件。类似的，可以指定映射的是普通文件还是匿名文件。如果是普通文件，就相当于通过内存来读写文件，效率很高；如果是匿名文件，相当于申请一块全部清零的内存空间。C 语言的库函数 malloc 在申请内存的时候通常会在堆区分配，当申请的内存较大 (缺省的大于128K) 时，会转而使用 <code>mmap</code> 在内存映射区分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileMappingA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE                hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 flProtect,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwMaximumSizeHigh,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwMaximumSizeLow,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">OpenFileMappingA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL   bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存映射根据文件可以分为匿名和非匿名的；而根据映射方式，又可以分为私有映射和共享映射。上面系统自动映射时，我们也说了，动态链接库是通过共享方式映射的，其他都是各进程的私有映射。Linux 上使用 <code>mmap</code> 时，可以设置 flags 参数为 <code>MAP_SHARED</code> 或 <code>MAP_PRIVATE</code> 来指定映射是私有的还是共享的；在 Windows 上 <code>CreateFileMappingA</code> 可以创建映射，而 <code>OpenFileMappingA</code> 则根据映射的名字来实现共享。</p>
<p>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。相对的，对一个映射到私有对象的区域的任何写操作，对于其他进程来说是不可见的。一个映射到共享对象的虚拟内存区域叫做共享区域，类似地，也有私有区域。</p>
<p>下图显示了进程间共享内存映射一个文件的情况</p>
<p><img src="/images/image-20181228104507208.png" alt="image-20181228104507208"></p>
<p>如果对于一个文件，有多个进程映射，且是私有的，在 Linux 上通常会使用一种称为写时复制 (<code>Copy-On-Write, COW</code>) 的技术来实现（这是一种未写时共享，有写时才分开的懒拷贝模式）。为了节约内存，私有对象开始的生命周期与共享对象基本上是一致的（在物理内存中只保存私有对象的一份副本），并使用写时复制的技术来应对多个进程的写冲突。如下图所示</p>
<p><img src="/images/image-20181229100438749.png" alt="image-20181229100438749"></p>
<p>还有一个典型的例子就是<code>fork()</code>函数，该函数用于创建子进程。当<code>fork()</code>函数被当前进程调用时，内核会为新进程创建各种必要的数据结构，并分配给它一个唯一的PID。为了给新进程创建虚拟内存，它复制了当前进程的<code>mm_struct</code>、<code>vm_area_struct</code>和页表的原样副本。并将两个进程的每个页面都标为只读，两个进程中的每个区域都标记为私有区域（写时复制）。这样，父进程和子进程的虚拟内存空间完全一致，只有当这两个进程中的任一个进行写操作时，再使用写时复制来保证每个进程的虚拟地址空间私有的抽象概念。</p>
<p>此外，Linux 平台的 <code>glibc</code> 库在实现线程时，会使用 <code>mmap</code> (设置参数 flags 为 <code>MAP_STACK</code>) 匿名映射来创建线程栈，从而实现线程栈的独立。</p>
<h3 id="内存分配类型"><a href="#内存分配类型" class="headerlink" title="内存分配类型"></a>内存分配类型</h3><p>从程序角度看，我们的内存分配分为以下几种</p>
<ul>
<li>静态分配。是指程序中的全局变量和静态变量。这种内存大小往往在编译期就可以确定，大小是固定的。内存只分配一次，就是在程序开始时，在程序结束时由系统回收。</li>
<li>自动变量分配。这是指由栈内存管理的变量，程序运行时自动分配和释放。</li>
<li>动态内存分配。指程序运行时动态分配的内存，主要在堆上。一些程序如 C/C++ 中由程序员用 malloc 或者 new 显示的分配；在 Go 中，编译器通过逃逸分析，也可能在堆上维护内存变量。</li>
</ul>
<p>下面几小结分别讲解这些内存管理的机制。</p>
<h3 id="栈内存管理"><a href="#栈内存管理" class="headerlink" title="栈内存管理"></a>栈内存管理</h3><p>程序开始执行，完成内存映射后，栈内存和堆内存就会使用各自独有的机制来实行管理了。我们先看栈内存的管理。</p>
<p>栈内存如下图 (Linux 平台下) 所示，处于用户空间的一端，向下增长</p>
<p><img src="/images/image-20181228150319032.png" alt="image-20181228150319032"></p>
<p>栈空间主要用来存储程序运行过程中函数调用的信息。这些信息数据在分配和回收时，遵循 <code>last-in-first-out(LIFO)</code> 的后进先出方式。</p>
<p>当一个函数被调用时，它的状态数据就被添加到栈顶；而当函数退出时，这些状态数据就又从栈上被移除。需要存入栈空间的状态数据包括：函数参数、对象实例指针(如 C++ 中的 this 指针)、返回地址、函数内局部变量。每一次的函数调用，状态数据形成的结构叫做栈帧 (<code>stack frame</code>)，多个栈帧通过 LIFO 的方式入栈出栈，就构成了栈空间管理的基本机制。</p>
<p>这个基于栈的内存分配和回收操作通常很快，往往只需要移动栈顶指针即可，效率很高。在大部分高级语言中，栈内存的分配和回收都是透明的、自动完成的，不需要程序员参与，很多处理器的指令集提供了栈操作的特殊指令。</p>
<blockquote>
<p>在函数调用中，函数参数除了使用栈内存空间传输，有时候也会通过 CPU 寄存器存储。通常是在参数较少的时候。</p>
</blockquote>
<p>例如，<code>DrawSquare</code> 调用了 <code>DrawLine</code> , 则其可能的栈结构 (该例子是栈顶在上，向上增长) 如下：</p>
<p><img src="/images/image-20181226111249595.png" alt="image-20181226111249595"></p>
<p>注意栈顶可能在上，也可能在下，要看栈的增长方向 。从前面Linux进程段排布的图我们看到，Linux上栈空间是从高地址往低地址增长的，其他系统未必如此。但不管如何，当前正在执行的函数是位于栈顶的位置。</p>
<p>如果函数调用的层次很多，即使用的栈帧很多，栈空间就会很快被消耗。栈空间大小一般是在程序执行时候就分配好，当分配的栈空间被消耗完毕后，则经典的 <strong><code>stack overflow</code></strong> 错误将出现，往往会导致程序崩溃。常见的错误就是函数的无限递归或者分配了很大的局部变量，导致栈溢出。这里提一下在 Linux 中栈大小初始值由操作系统设定(ulimit)，且有动态增长的机制，只要其大小不大于 <code>RLIMIT_STACK</code>，则空间不足时会自动增长，不会出现栈溢出的错误。但如果栈已经到达最大值 <code>RLIMIT_STACK</code>，则栈溢出就会出现。而 Windows的栈大小通常是固定的，没有动态增长的机制。其大小可以由编译器 (如 Visual Studio) 设置，并被记录在可执行文件中。</p>
<p>栈的结构，可以用来调试程序。如 GDB 调试的时候，就可以看到程序执行的完整栈结构，打印栈帧数据等；另外，对于很多程序性能 profile 工具，往往通过定时采样程序执行的栈帧结构，从而统计程序执行的各种信息，定位哪些函数是性能热点。</p>
<p>最后，</p>
<ul>
<li>程序中的每个 task 对应一个栈</li>
<li>一个进程本身只有一个栈 (进程是一个task)，称为进程栈</li>
<li>对于在进程中开启的线程，其栈空间和进程栈是分开的，每个线程 (也是一个task) 在创建时，线程栈通过操作系统来分配</li>
<li>Golang 的每个协程拥有自己的栈</li>
</ul>
<h3 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h3><p>堆内存，也称为动态内存。程序需要用到动态内存分配的原因，是经常直到程序实际执行时，才知道某些数据结构的大小，不能提前分配内存。堆区域紧接在未初始化的数据段后开始，并向特定方向增长 (下图还是 Linux 系统上的情况，不代表所有)。对于每个进程，内核维护着一个变量 <strong>break</strong>，它指向堆的顶部。</p>
<p><img src="/images/image-20181228151912039.png" alt="image-20181228151912039"></p>
<p>那如何管理这部分的堆内存呢？很多语言维护了 <strong>动态内存分配器</strong> 来进行管理。动态分配器将堆视为一组不同大小的块 (block) 的集合来维护。每个块就是一个连续的虚拟内存片 (chunk)，要么是已分配的，要么是空闲的。最开始的时候，没有空闲块，我们的内存申请是要向内核直接申请内存 (在 Linux 上是移动<a href="http://man7.org/linux/man-pages/man2/brk.2.html" target="_blank" rel="noopener"> <code>brk</code></a> 指针，Windows 上 调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/HeapApi/nf-heapapi-heapalloc" target="_blank" rel="noopener"><code>HeapAlloc</code></a> )。释放的时候，没有必要立即将内存归还给系统，而是作为空闲块维护起来，下次分配的时候就可以优先利用被释放的空闲块了。如下图：</p>
<p><img src="/images/image-20181229102552027.png" alt="image-20181229102552027"></p>
<p>维护这些分配块和空闲块的算法需要精心设计，以满足分配效率及内存利用率的最大化。在很多编程语言中，都提供了动态分配内存的方法，例如 C/C++ 中 malloc 库函数就是在堆中分配内存；Go 中 new 一个对象也可能由于逃逸分析，导致变量被分配在堆区中。</p>
<p>常用的分配器有两种风格。这两种风格都需要应用显示的分配内存块。它们不同的地方在于由谁来负责释放已分配的块。</p>
<ul>
<li>显式分配器，要求应用自身显式的释放任何已分配的块。例如，C 标准库提供 malloc 来分配内存块，并通过free 来显式释放该内存块。C++ 中的 new 和 delete 也是类似。C++ 类的析构函数本质上提供了内存释放的机会 (delete 操作符触发)。智能指针也是一种自动内存管理的机制。</li>
<li>隐式分配器，要求分配器检测不被程序继续使用的内存块，并释放这些它们。这个过程常称为 <strong>垃圾收集(Garbage Collection, GC)</strong> ，高级语言如 Java、Go、JavaScript 等拥有自己的垃圾收集机制，程序员无需自己释放申请的内存。</li>
</ul>
<h5 id="显式分配器的机制"><a href="#显式分配器的机制" class="headerlink" title="显式分配器的机制"></a>显式分配器的机制</h5><p>显式分配器的机制，典型的如如何实现 <code>malloc</code> 和 <code>free</code> 。我们考虑以下几点：</p>
<ul>
<li><p>使用堆内存</p>
</li>
<li><p>分配时指定内存 size，返回内存地址</p>
</li>
<li>显式释放时只需要指定内存地址，分配器本身需要记录该内存对应的大小</li>
<li>分配的内存要做对齐，最大化访问效率</li>
</ul>
<p>一种方式是使用块维护内存。各个内存块，不管是已分配还是空闲的，一起连接起来</p>
<p><img src="/images/image-20181228172930734.png" alt="image-20181228172930734"></p>
<p>单个内存块的数据格式如下</p>
<p><img src="/images/image-20181228173029000.png" alt="image-20181228173029000"></p>
<p>这里不详细展开显示分配的具体细节 (例如类似 malloc 的实现原理)，有兴趣的可以查看 <a href="https://medium.com/@andrestc/implementing-malloc-and-free-ba7e7704a473" target="_blank" rel="noopener">Implementing malloc and free</a> 和 <a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="noopener">如何实现一个malloc</a></p>
<h5 id="垃圾收集的机制"><a href="#垃圾收集的机制" class="headerlink" title="垃圾收集的机制"></a>垃圾收集的机制</h5><ul>
<li><p>追踪。这是最常用的垃圾收集机制，主要思想是从根节点进行追踪，所有未被引用的对象就被认为是垃圾，可以进行收集。它主要研究的是引用对象的可达性。如下图的引用关系</p>
<p><img src="/images/image-20181224115827314.png" alt="image-20181224115827314"></p>
<p>从 root set 追踪不可达，则会被垃圾收集器认为是垃圾，可以回收。那具体的，对象的可达性是怎么样呢？主要分两种：</p>
<ul>
<li><p>根元素。这包括程序的所有全局变量、当前调用栈对象 (如所有栈内局部变量、当前调用的函数参数)</p>
</li>
<li><p>引用元素。所有根元素引用链上的对象</p>
</li>
</ul>
<p>追踪的主要机制是如何维护对象之间的引用关系。对于 Java、Go 这些有标记内存变量类型的语言来说比较简单：有变量类型信息从而很简单的知道是否包含其他对象；而对于 C/C++ 语言，不会用类型信息来标记内存位置。因此，像 int、float 这类变量和对象的指针变量没有可区分的手段，很难说一个结构体的某个内存到底是引用其他结构体的指针还是一个 int/float 变量。如果 C/C++ 要设计垃圾收集器，必须保守的将所有 <strong>像指针</strong> 的内存视为可达的，尽管事实上它可能是不可达的。C/C++ 垃圾收集库的一个实现是 <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener">Boehm GC</a></p>
<p>比较知名的追踪算法有 标记-清扫算法、三色标记算法等。详细的这里不展开，有兴趣的可以查看 <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">这里</a></p>
</li>
</ul>
<ul>
<li><p>引用计数</p>
<p>引用计数机制，简单说就是为每个变量维护一个计数，有引用时累加计数，删除引用时则减计数。如果计数归零，则可以立即回收。但是因为引用计数有一些缺点，如</p>
<ul>
<li>环形引用。如果有两个变量互相引用，但是和其他变量没有引用关系，则是环形引用，因为引用计数不为0，得不到回收</li>
<li>空间和时间消耗。每个变量维护一个计数，空间消耗不小。另外，对计数的增减，对程序执行效率也有影响</li>
<li>要保证原子性。如果涉及并发，计数的修改需要保证原子性</li>
</ul>
<p>这些缺点让引用计数机制逊于追踪机制，在垃圾收集实现方面没有得到广泛应用。</p>
</li>
</ul>
<h3 id="Bss-段、Data-段-与-Text-段"><a href="#Bss-段、Data-段-与-Text-段" class="headerlink" title="Bss 段、Data 段 与 Text 段"></a>Bss 段、Data 段 与 Text 段</h3><p>Bss 段和 Data 都是用来存储程序的全局变量和静态变量的。不同的是，Bss 段是匿名映射的全零区域，用来存储代码中没有初始化的全局变量和静态变量 (包括文件内静态变量，函数内静态局部变量，类静态成员变量)，如 <code>static int cntActiveUsers</code>；Data 段是通过可执行文件的 <code>.data</code> 映射来的，里面存储的是已经初始化 (且非0) 的 <strong>全局变量或静态变量的值</strong>，例如 <code>static int cntWorkerBees = 10</code> 会将将静态变量的值 <code>10</code> 存储到 Data 段。需要注意，Data 段的映射是私有映射，运行时对变量的修改并不会反馈到可执行文件里，否则可执行文件都被修改了，那是不合理的。</p>
<p>Text 段就是代码段，是从可执行文件的 <code>.text</code> 部分映射过来。除了代码指令，还存储了常量字符串。这部分内存是可读可执行的，但是不能写，因此无论是修改代码指令，还是修改常量字符串，都会导致程序 crash。</p>
<p><code>static const char* gonzo = &quot;God&#39;s own prototype&quot;;</code> 已初始化的静态变量 <code>gonzo</code> 是个指针，存储在 Data 段，其内容是一个地址 <code>0x080484f0</code>，指向字符串的地址，而字符串在 Text 段。</p>
<p><img src="/images/image-20181229105756277.png" alt="image-20181229105756277"></p>
<p>参考资料</p>
<p>&lt;深入理解计算机系统V3&gt;</p>
<p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science" target="_blank" rel="noopener">GarbageCollection WiKi</a>)</p>
<p><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">CallStack WiKI</a></p>
<p><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></p>
<p><a href="https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/" target="_blank" rel="noopener">虚拟内存的那点事儿</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/desktop/Memory/virtual-address-space" target="_blank" rel="noopener">Windows Virtual Address Space</a></p>
<p><a href="https://povilasv.me/go-memory-management/" target="_blank" rel="noopener">Go Memory Management</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/Go研究之channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/Go研究之channel/" itemprop="url">Go研究之channel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-13T20:43:35+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/12/13/Go研究之channel/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/12/13/Go研究之channel/" class="cy_cmt_count" data-xid="2018/12/13/Go研究之channel/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h2><p>CSP，全称 <code>Communicating sequential processes</code> 是指并发系统中的一种模式。简单来说，CSP 模型由并发执行的实体（线程或者进程或其他）所组成，实体之间通过消息进行通信。Go语言的并发特性正是基于CSP模型发展而来，具体来说，goroutine 就是并发执行的实体，而 goroutine 之前通信就是借助了 channel 来进行消息传递。Go语言有一种哲学叫做</p>
<p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p>
<p>意思是尽量通过通信来共享内存，而不是通过共享内存来通信。由此可见 channel 在 Go 中的重要地位。</p>
<h2 id="Go的channel"><a href="#Go的channel" class="headerlink" title="Go的channel"></a>Go的channel</h2><p>通常的线程模型，一个很重要的问题就是各线程之前的同步。我们通常采用条件变量或者信号量来做同步操作，如果需要传递消息，经常要自己实现一个带锁的线程安全的消息队列。</p>
<p>而在Go中，为了方便 goroutine 之前的通信，原生支持了一种称为 channel 的数据结构，用来做同步和消息传递。它的常用操作如下：</p>
<p>创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unBufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// 无缓冲</span></span><br><span class="line">bufferChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, N) <span class="comment">// 带缓冲</span></span><br></pre></td></tr></table></figure>
<p>读写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞读操作</span></span><br><span class="line">x := &lt;- ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞写操作</span></span><br><span class="line">ch &lt;- x</span><br></pre></td></tr></table></figure>
<p>关闭</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>select (类似IO多路复用)，只要其中一个满足，则执行后续操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上操作都是阻塞的，同时 channel 也支持非阻塞的读写操作，类似于 IO 操作中如果没有满足条件的则返回 EAGAIN 或者 EWOULDBLOCK。这需要借助 select 的 default 分支来实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e := &lt;-ch:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的非阻塞操作，如果 ch 中没有读取到数据，也不会阻塞，而是进入default分支。类似的还有非阻塞写，这里就不具体说明了。</p>
<h2 id="Channel的实现原理"><a href="#Channel的实现原理" class="headerlink" title="Channel的实现原理"></a>Channel的实现原理</h2><p>下面以 Go1.8 的源码为例来研究下 channel 各个操作的实现原理。</p>
<h3 id="channel-结构"><a href="#channel-结构" class="headerlink" title="channel 结构"></a>channel 结构</h3><p>hchan 结构用来表示一个channel，具体信息如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog represents a g in a wait list, such as for sending/receiving</span></span><br><span class="line"><span class="comment">// on a channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudog is necessary because the g ↔ synchronization object relation</span></span><br><span class="line"><span class="comment">// is many-to-many. A g can be on many wait lists, so there may be</span></span><br><span class="line"><span class="comment">// many sudogs for one g; and many gs may be waiting on the same</span></span><br><span class="line"><span class="comment">// synchronization object, so there may be many sudogs for one object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sudogs are allocated from a special pool. Use acquireSudog and</span></span><br><span class="line"><span class="comment">// releaseSudog to allocate and free them.</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this.</span></span><br><span class="line"></span><br><span class="line">	g          *g</span><br><span class="line">	selectdone *<span class="keyword">uint32</span> <span class="comment">// CAS to 1 to win select race (may point to stack)</span></span><br><span class="line">	next       *sudog</span><br><span class="line">	prev       *sudog</span><br><span class="line">	elem       unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// waitlink is only accessed by g.</span></span><br><span class="line"></span><br><span class="line">	acquiretime <span class="keyword">int64</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">	ticket      <span class="keyword">uint32</span></span><br><span class="line">	waitlink    *sudog <span class="comment">// g.waiting list</span></span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，hchan主要包含</p>
<ul>
<li><p>环形队列，用来存放消息(只针对带缓冲channel)。涉及的字段有</p>
<ul>
<li><p><code>qcount</code> 当前队列中的消息数量</p>
</li>
<li><p><code>dataqsiz</code> 队列大小</p>
</li>
<li><p><code>buf</code> 队列具体数据buf</p>
</li>
<li><p><code>sendx</code>、<code>recvx</code> 环形队列的发送和接收游标</p>
</li>
</ul>
</li>
<li>元素信息 <code>elemtype</code> 、<code>elemsize</code>。其中<code>elemtype</code> 的类型 <code>_type</code> 是 Go 中表示变量类型的基础结构，在反射和interface 的实现中很常用。因为 channel 可以持有各种类型的数据，所以需要维护元素信息。</li>
<li>lock，用来做并发互斥。</li>
<li>等待接收或等待发送的 goroutine 队列。<code>recvq</code> 和 <code>sendq</code> 都是用双向链表实现的队列，如果有 goroutine 因为读写被阻塞，就会被调度器挂起在这两个队列上。我们之前分析 Go 调度模型GMP的时候有提到，一般 G (goroutine) 和 P (proc) 挂钩，处于等待执行或者正在执行状态。如果正在执行的 G 阻塞在 channel 上，就会脱离 P，转而挂起在 channel 的<code>recvq</code> 或者 <code>sendq</code> 上，完成 channel 操作后再选择合适的 P 来继续执行。</li>
<li>closed。用来表示channel是否关闭。关闭 channel 可用用来实现广播的效果，后面会讲到。</li>
<li>sudog 代表一个goroutine</li>
</ul>
<h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>创建channel就是如何新建一个 hchan 结构的过程，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt; <span class="number">0</span> || <span class="keyword">int64</span>(<span class="keyword">uintptr</span>(size)) != size || (elem.size &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">uintptr</span>(size) &gt; (_MaxMem-hchanSize)/elem.size) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Allocate memory in one call.</span></span><br><span class="line">		<span class="comment">// Hchan does not contain pointers interesting for GC in this case:</span></span><br><span class="line">		<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">		<span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line">		<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">			<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">			c.buf = unsafe.Pointer(c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">	&#125;</span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"makechan: chan="</span>, c, <span class="string">"; elemsize="</span>, elem.size, <span class="string">"; elemalg="</span>, elem.alg, <span class="string">"; dataqsiz="</span>, size, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>元素大小不能超过64k(1&lt;&lt;16)</p>
</li>
<li><p>channel的元素个数不能为负数且不能超过一定数量</p>
</li>
<li><p>如果channel里存的是非指针的具体对象，则channel和具体存放的元素buf会一起分配，GC不会扫描这部分buf数据，因为buf相当于是channel的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Allocate memory in one call.</span></span><br><span class="line">    <span class="comment">// Hchan does not contain pointers interesting for GC in this case:</span></span><br><span class="line">    <span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">    <span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line">    <span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">    	c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line">    	<span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line">    	c.buf = unsafe.Pointer(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>否则 buf 分开分配内存，可能会被GC 回收到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建完成后的结构，利用 gdb 调试时看到 hchan 的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">struct</span> runtime.hchan *) <span class="number">0xc420072000</span></span><br><span class="line">(gdb) p *c</span><br><span class="line">$<span class="number">2</span> = &#123;qcount = <span class="number">0</span>, dataqsiz = <span class="number">10</span>, buf = <span class="number">0xc420072060</span>, elemsize = <span class="number">8</span>, closed = <span class="number">0</span>, elemtype = <span class="number">0x1097040</span> &lt;<span class="keyword">type</span>.*+<span class="number">56064</span>&gt;, sendx = <span class="number">0</span>, recvx = <span class="number">0</span>, recvq = &#123;first = <span class="number">0x0</span>, last = <span class="number">0x0</span>&#125;, </span><br><span class="line">  sendq = &#123;first = <span class="number">0x0</span>, last = <span class="number">0x0</span>&#125;, lock = &#123;key = <span class="number">0</span>&#125;&#125;</span><br><span class="line">(gdb) p *c.elemtype</span><br><span class="line">$<span class="number">3</span> = &#123;size = <span class="number">8</span>, ptrdata = <span class="number">0</span>, hash = <span class="number">4149441018</span>, tflag = <span class="number">7</span> <span class="string">'\a'</span>, align = <span class="number">8</span> <span class="string">'\b'</span>, fieldalign = <span class="number">8</span> <span class="string">'\b'</span>, kind = <span class="number">130</span> <span class="string">'\202'</span>, alg = <span class="number">0x110bbf</span>0 &lt;runtime.algarray+<span class="number">80</span>&gt;, </span><br><span class="line">  gcdata = <span class="number">0x10bca3b</span> &lt;runtime.gcbits.*&gt; <span class="string">"\001\002\003\004\005\006\a\b\n\f\r\016\017\020\022\025\026\030\031\032\033\036\037,568&lt;ABUXr~\236\325\330\365\377\001\002\037\003%\004I\022U\001U\005U\025UUu\002y\001\224\a\230\a\230\177\330\003\340?\376\005\376!\377\377\001\016\034"</span>, str = <span class="number">955</span>, ptrToThis = <span class="number">37088</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 c 的内存地址和 buf 的内存地址是连续的。</p>
<p>如果创建的是指针类型 <code>channel</code>, <code>c</code> 的地址就和 <code>buf</code> 地址是分开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line">$1 = (struct runtime.hchan *) 0xc420068060</span><br><span class="line">(gdb) p *c</span><br><span class="line">$2 = &#123;qcount = 0, dataqsiz = 10, buf = 0xc420016140, elemsize = 8, closed = 0, elemtype = 0x1092500 &lt;type.*+37088&gt;, sendx = 0, recvx = 0, recvq = &#123;first = 0x0, last = 0x0&#125;, </span><br><span class="line">  sendq = &#123;first = 0x0, last = 0x0&#125;, lock = &#123;key = 0&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写channel"><a href="#写channel" class="headerlink" title="写channel"></a>写channel</h3><p>写对应的操作是 <code>ch &lt;- x</code>, 编译器编译后实际调用了以下源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry point for c &lt;- x from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	chansend(t, c, elem, <span class="literal">true</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we'll see that it's now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t.elem, ep, callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(ep, t.elem.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">	<span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">	<span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">	<span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">	<span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">	<span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">	<span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">	<span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">	<span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nil-channel"><a href="#nil-channel" class="headerlink" title="nil channel"></a>nil channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>nil channel</code>， 如果是非阻塞写，则会立即返回；如果是阻塞写，则当前 goroutine 会通过 <code>gopark</code>调用进入等待状态。</p>
<h5 id="closed-channel"><a href="#closed-channel" class="headerlink" title="closed channel"></a>closed channel</h5><p>写已经closed的channel会panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="recvq"><a href="#recvq" class="headerlink" title="recvq"></a>recvq</h5><p>如果 recvq 不为空，则表明有 goroutine 被挂起等待数据，此时即使是带缓冲的channel，也不会将数据存储到buf里，而是直接发给队列头的 goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">    <span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">    send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据会从发送 goroutine 的栈上(ep)直接被拷贝到挂起的 sudog 的 数据域 elem 上，然后通过 goready 唤醒这个sudog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if sg.elem != nil &#123;</span><br><span class="line">    sendDirect(c.elemtype, sg, ep)</span><br><span class="line">    sg.elem = nil</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">if sg.releasetime != 0 &#123;</span><br><span class="line">	sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, 4)</span><br></pre></td></tr></table></figure>
<h5 id="buf-not-full"><a href="#buf-not-full" class="headerlink" title="buf not full"></a>buf not full</h5><p>如果没有等待接收者，且缓冲没满，则将数据拷贝到缓冲区中，这里就是简单的环形缓冲的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">    <span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">    qp := chanbuf(c, c.sendx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">    c.sendx++</span><br><span class="line">    <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">        c.sendx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount++</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>chanbuf</code> 定位到具体数据 qp，然后将 ep 指向的数据拷贝到其中，同时更新游标 sendx 和 元素数量 qcount</p>
<h5 id="buf-full"><a href="#buf-full" class="headerlink" title="buf full"></a>buf full</h5><p>如果 buf 满了，对于非阻塞发送，就立即返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于阻塞发送，当前发送 goroutine 就被阻塞住挂起在等待队列里</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>待发送的数据 ep 被放置在 sudog 的 elem 上，sudog 本身入队到 sendq 中，并挂起。</p>
<h3 id="读channel"><a href="#读channel" class="headerlink" title="读channel"></a>读channel</h3><p>读对应的操作是 <code>x = &lt;- ch</code>, 编译器编译后实际调用了以下源码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan receive (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">	<span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">	<span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">	<span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">	<span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">	<span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">	<span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, <span class="string">"chan receive"</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ep 代表变量 x 指向的内存区，用来存储接收到的数据，如果 ep 为 nil，则读到的数据会被忽略</p>
<h5 id="nil-channel-1"><a href="#nil-channel-1" class="headerlink" title="nil channel"></a>nil channel</h5><p>对于未初始化的 channel，如果非阻塞读，则直接返回；如果是阻塞读，会通过 gopark 将当前 goroutine 转为等待状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan receive (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="closed-channel-1"><a href="#closed-channel-1" class="headerlink" title="closed channel"></a>closed channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, ep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于已经关闭的 channel，如果 buf 中没有数据了，则返回元素类型的零值 (通过 <code>typedmemclr</code> 来处理) </p>
<p>如果 buf 中还有数据，还是会继续走后续流程读取数据 (从挂起的 sender 中或者 buf 中)。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">ch &lt;- <span class="number">5</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭后，只要还有数据，会读到数据；也会返回标识告知channel是否被关闭</span></span><br><span class="line">data, isClosed := &lt;-ch</span><br><span class="line">log.Printf(<span class="string">"data:%d isClosed:%v"</span>, data, isClosed)</span><br><span class="line">log.Printf(<span class="string">"after closed data:%d %d"</span>, &lt;-ch, &lt;-ch)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    log.Printf(<span class="string">"range data:%d"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读完后，继续读取会返回零值</span></span><br><span class="line">data = &lt;- ch</span><br><span class="line">log.Printf(<span class="string">"continue read: data %d"</span>, data)</span><br></pre></td></tr></table></figure>
<p>输出以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:1 isClosed:true</span><br><span class="line">after closed data:2 3</span><br><span class="line">range data:4</span><br><span class="line">range data:5</span><br><span class="line">continue read: data 0</span><br></pre></td></tr></table></figure>
<h5 id="sendq"><a href="#sendq" class="headerlink" title="sendq"></a>sendq</h5><p>如果 sendq 有被挂起等待发送数据的 goroutine，则获取队头的 goroutine，调用 <code>recv</code> 进行处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">    <span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">    <span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">    <span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>recv</code> 做的具体工作我们继续看下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racesync(c, sg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// copy data from sender</span></span><br><span class="line">        recvDirect(c.elemtype, sg, ep)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">    <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">    <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">    <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">        raceacquireg(sg.g, qp)</span><br><span class="line">        racereleaseg(sg.g, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from sender to queue</span></span><br><span class="line">    typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">    sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>如果 channel 是非缓冲的 (dataqsiz == 0)，则接收者直接从发送者手里接收数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racesync(c, sg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// copy data from sender</span></span><br><span class="line">        recvDirect(c.elemtype, sg, ep)</span><br><span class="line">    &#125; <span class="comment">// else 忽略数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 channel 是带缓冲的 (dataqsiz &gt; 0)，则表明此时 buf 已经满了，此时才会有等待发送的 goroutine 被挂起。需要做的事情就是从环形队列中读取一个元素，这时会空出一个元素的位置，之前挂起等待的队头 sudog 的数据就被写入环形队列。如果还有其他阻塞等待写的 sugog，继续挂起等待后续的读。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">    <span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">    <span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">    <span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">        raceacquireg(sg.g, qp)</span><br><span class="line">        racereleaseg(sg.g, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from queue to receiver</span></span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy data from sender to queue</span></span><br><span class="line">    typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完成之后，之前 sendq 中挂起的发送 goroutine 就被 <code>goready</code> 调用唤醒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">    sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h5 id="buf-not-empty"><a href="#buf-not-empty" class="headerlink" title="buf not empty"></a>buf not empty</h5><p>如果 buf 有数据，则直接将数据读出到 ep 内存处，然后将其置为零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Receive directly from queue</span></span><br><span class="line">    qp := chanbuf(c, c.recvx)</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquire(qp)</span><br><span class="line">        racerelease(qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//数据从qp读取到ep中</span></span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//置为零值</span></span><br><span class="line">    typedmemclr(c.elemtype, qp)</span><br><span class="line">    c.recvx++</span><br><span class="line">    <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">        c.recvx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.qcount--</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="buf-empty"><a href="#buf-empty" class="headerlink" title="buf empty"></a>buf empty</h5><p>如果 buf 中没有数据，对于非阻塞读取，立即返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于阻塞读，则当前读 goroutine 被挂起到 recvq 中等待后续数据写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">    mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan receive"</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="select-channel"><a href="#select-channel" class="headerlink" title="select channel"></a>select channel</h3><p>select 用于多个channel监听并收发消息，当任何一个case满足条件则会执行，若没有可执行的case，就会执行default，如果没有default，程序就会阻塞。select 的作用很类似于 IO多路复用。</p>
<h5 id="多-channel-select"><a href="#多-channel-select" class="headerlink" title="多 channel select"></a>多 channel select</h5><p>前面提到，典型的 select 用法是用在多个 channel 上，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">chs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;- ch:</span><br><span class="line">    fmt.Println(<span class="string">"received msg: "</span>, msg)</span><br><span class="line"><span class="keyword">case</span> msgs := &lt;- chs:</span><br><span class="line">    fmt.Println(<span class="string">"receied msgs: "</span>, msgs)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select 的结构为 <code>hselect</code> ，其定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select statement header.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.</span></span><br><span class="line"><span class="keyword">type</span> hselect <span class="keyword">struct</span> &#123;</span><br><span class="line">	tcase     <span class="keyword">uint16</span>   <span class="comment">// total count of scase[]</span></span><br><span class="line">	ncase     <span class="keyword">uint16</span>   <span class="comment">// currently filled scase[]</span></span><br><span class="line">	pollorder *<span class="keyword">uint16</span>  <span class="comment">// case poll order</span></span><br><span class="line">	lockorder *<span class="keyword">uint16</span>  <span class="comment">// channel lock order</span></span><br><span class="line">	scase     [<span class="number">1</span>]scase <span class="comment">// one per case (in order of appearance)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select case descriptor.</span></span><br><span class="line"><span class="comment">// Known to compiler.</span></span><br><span class="line"><span class="comment">// Changes here must also be made in src/cmd/internal/gc/select.go's selecttype.</span></span><br><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">	c           *hchan         <span class="comment">// chan</span></span><br><span class="line">	pc          <span class="keyword">uintptr</span>        <span class="comment">// return pc</span></span><br><span class="line">	kind        <span class="keyword">uint16</span></span><br><span class="line">	so          <span class="keyword">uint16</span> <span class="comment">// vararg of selected bool</span></span><br><span class="line">	receivedp   *<span class="keyword">bool</span>  <span class="comment">// pointer to received bool (recv2)</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其操作的具体源码实现是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectgoImpl(sel *hselect) (<span class="keyword">uintptr</span>, <span class="keyword">uint16</span>)</span><br></pre></td></tr></table></figure>
<p>select 的多个选项会被包装成多个<code>scase</code> 结构，然后依据 lockorder 来处获得所有锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">sellock(scases, lockorder)</span><br></pre></td></tr></table></figure>
<p><code>sellock</code> 是实现为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sellock</span><span class="params">(scases []scase, lockorder []<span class="keyword">uint16</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		c0 := scases[o].c</span><br><span class="line">		<span class="keyword">if</span> c0 != <span class="literal">nil</span> &amp;&amp; c0 != c &#123;</span><br><span class="line">			c = c0</span><br><span class="line">			lock(&amp;c.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁会有去重判断，方式多个case 操作一个 channel 导致重复上锁问题。</p>
<p>然后依次查看所有的case是否有对应的事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sel.ncase); i++ &#123;</span><br><span class="line">    <span class="comment">//按照pollorder顺序来遍历</span></span><br><span class="line">    cas = &amp;scases[pollorder[i]]</span><br><span class="line">    c = cas.c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> caseRecv:</span><br><span class="line">        sg = c.sendq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> recv</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> bufrecv</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> rclose</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseSend:</span><br><span class="line">        <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">            racereadpc(unsafe.Pointer(c), cas.pc, chansendpc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> sclose</span><br><span class="line">        &#125;</span><br><span class="line">        sg = c.recvq.dequeue()</span><br><span class="line">        <span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> send</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">            <span class="keyword">goto</span> bufsend</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseDefault:</span><br><span class="line">        dfl = cas</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里遍历的时候并不是按照代码里 case 的顺序，而是按照 <code>pollorder</code> 来的，这个 <code>pollorder</code> 是随机出来的顺序，因此如果有多个满足条件的 case，则最终选中的 case 是哪一个是随机的。这样能避免一直选中写在前面的 case 而导致其他 case <strong>饿死</strong> 的情况。<code>pollorder</code> 通过以下代码随机洗牌而来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generate permuted order</span></span><br><span class="line">pollslice := slice&#123;unsafe.Pointer(sel.pollorder), <span class="keyword">int</span>(sel.ncase), <span class="keyword">int</span>(sel.ncase)&#125;</span><br><span class="line">pollorder := *(*[]<span class="keyword">uint16</span>)(unsafe.Pointer(&amp;pollslice))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="keyword">int</span>(sel.ncase); i++ &#123;</span><br><span class="line">    j := <span class="keyword">int</span>(fastrand()) % (i + <span class="number">1</span>)</span><br><span class="line">    pollorder[i] = pollorder[j]</span><br><span class="line">    pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果过程中遍历到的 case 有一个是非阻塞的操作，则 select 会立即返回，不会再去检查后续的 case 是否 ready；如果每个 case 对其 channel 的操作都是阻塞的且没有 default 分支，则 select 会一直阻塞，而且会挂起在涉及的所有的 channel 的 recvq 或者 sendq 上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">gp = getg()</span><br><span class="line">done = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nextp = &amp;gp.waiting</span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">    cas = &amp;scases[casei]</span><br><span class="line">    c = cas.c</span><br><span class="line">    sg := acquireSudog()</span><br><span class="line">    sg.g = gp</span><br><span class="line">    <span class="comment">// Note: selectdone is adjusted for stack copies in stack1.go:adjustsudogs</span></span><br><span class="line">    sg.selectdone = (*<span class="keyword">uint32</span>)(noescape(unsafe.Pointer(&amp;done)))</span><br><span class="line">    <span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">    <span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">    sg.elem = cas.elem</span><br><span class="line">    sg.releasetime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.c = c</span><br><span class="line">    <span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">    *nextp = sg</span><br><span class="line">    nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> caseRecv:</span><br><span class="line">        c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> caseSend:</span><br><span class="line">        c.sendq.enqueue(sg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for someone to wake us up</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gopark(selparkcommit, <span class="literal">nil</span>, <span class="string">"select"</span>, traceEvGoBlockSelect, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="单-channel-非阻塞select"><a href="#单-channel-非阻塞select" class="headerlink" title="单 channel 非阻塞select"></a>单 channel 非阻塞select</h5><p>单 channel 的非阻塞 select 和前面多 channel 的select的实现机制不太一样，相对更简单，编译器会将其编译成 <code>chanrecv</code> 或者 <code>chansend</code> 调用</p>
<p>编译器会将以下非阻塞读取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- v:</span><br><span class="line">	... foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbsend(c, v) &#123;</span><br><span class="line">	... foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 非阻塞写的实现还是调用前面提到的 <code>chansend</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会将以下非阻塞写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;-c:</span><br><span class="line">	... foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, c) &#123;</span><br><span class="line">	... foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	... bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 非阻塞读的实现还是调用前面提到的 <code>chanrecv</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(t *chantype, elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	selected, _ = chanrecv(t, c, elem, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="close-channel"><a href="#close-channel" class="headerlink" title="close channel"></a>close channel</h3><p>close channel 的操作对应源码中的 <code>closechan</code> 调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;c))</span><br><span class="line">		racewritepc(unsafe.Pointer(c), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(unsafe.Pointer(c))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all readers</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all writers (they will panic)</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">		&#125;</span><br><span class="line">		gp.schedlink.set(glist)</span><br><span class="line">		glist = gp</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">	<span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">		gp := glist</span><br><span class="line">		glist = glist.schedlink.ptr()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="nil-channel-2"><a href="#nil-channel-2" class="headerlink" title="nil channel"></a>nil channel</h5><p>如果关闭一个未初始化的 channel，会 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="closed-channel-2"><a href="#closed-channel-2" class="headerlink" title="closed channel"></a>closed channel</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭一个已经关闭的 channel 也会导致 panic。所以一般使用时，是由唯一的一个生产者来关闭 channel。</p>
<h5 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h5><p>正常关闭 channel 时，首先设置 closed 标识，然后将循环遍历，将 recvq 和 sendq 中挂起等待的 goroutine 收集到 glist 链表中等待调度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.recvq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.schedlink.set(glist)</span><br><span class="line">    glist = gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sg := c.sendq.dequeue()</span><br><span class="line">    <span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    sg.elem = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.schedlink.set(glist)</span><br><span class="line">    glist = gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调度 glist 中的 goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line"><span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">    gp := glist</span><br><span class="line">    glist = glist.schedlink.ptr()</span><br><span class="line">    gp.schedlink = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使 g 的状态切换到 Grunnable，交给调度器调度</span></span><br><span class="line">    goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的：</p>
<ul>
<li>等待读的 goroutine，会将数据区 elem 置为零值 ( <code>typedmemclr(c.elemtype, sg.elem)</code> ) 然后继续执行</li>
<li>等待写的 goroutine，将会 panic</li>
</ul>
<p>参考资料</p>
<p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/" target="_blank" rel="noopener">Go Channel 源码剖析</a></p>
<p><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="noopener">Diving Deep Into The Golang Channels.</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/GUID生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/GUID生成/" itemprop="url">GUID生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-21T17:18:09+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/21/GUID生成/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/21/GUID生成/" class="cy_cmt_count" data-xid="2018/11/21/GUID生成/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MangoDB objectid</p>
<p>twitter snowflake</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/游戏服务器数据一致性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/游戏服务器数据一致性/" itemprop="url">游戏服务器数据一致性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T13:55:27+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/19/游戏服务器数据一致性/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/19/游戏服务器数据一致性/" class="cy_cmt_count" data-xid="2018/11/19/游戏服务器数据一致性/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>游戏服务器是一种很常见的分布式系统，分布式系统最大的难题是状态同步，CAP 定理是这方面的原理。</p>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p><img src="/images/image-20181119135742290.png" alt="image-20181119135742290"></p>
<ul>
<li><p>Consistency 一致性</p>
</li>
<li><p>Availability 可用性</p>
</li>
<li><p>Partition tolerance 分区容错性</p>
</li>
</ul>
<p>CAP 这三个指标不可能同时做到，最多只能满足其二。这个结论就叫做 CAP 定理。</p>
<p><strong><code>Partition tolerance</code> 分区容错</strong>，意思是分布式的各节点（也叫区）之间通信是不可靠的。一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p>
<p><strong><code>Consistency</code> 一致性</strong>，意思是从各个节点访问同一数据，其值必须都是最新的，即一致的。节点的多份数据必须通过一定的算法做同步。</p>
<p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p>
<p><img src="/images/image-20181119140749199.png" alt="image-20181119140749199"></p>
<p><img src="/images/image-20181119140847181.png" alt="image-20181119140847181"></p>
<p>此时如果有用户向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p>
<p><img src="/images/image-20181119141002062.png" alt="image-20181119141002062"></p>
<p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p>
<p><img src="/images/image-20181119141107638.png" alt="image-20181119141107638"></p>
<p>注意这里说的其实是强一致性。相对的还有弱一致性，即最终一致性。</p>
<p><strong>Availability 可用性</strong>， 意思是通过任意节点都可以拿到数据，强调服务的可用性。一般可以用 <code>服务可用时间/总服务时间</code> 去度量。比如4个9的可用性，即99.99%，换算到一年的时间内，可以反推出最长故障时间：</p>
<p><code>365 × 86400 ×（1-99.99%）秒 = 3153.6 秒 = 52.56 分钟</code></p>
<p>保证系统各个环节无单点、大部分故障可自愈是保障高可用性的关键。</p>
<p>以下为一些案例：</p>
<ol>
<li>CDN 缓存。最大可用性 + 最终一致性。各CDN节点的数据可以在运行一段时间后才趋于一致。</li>
<li>zookeeper。强一致性 + 不错的可用性。paxos/raft 一致性算法保证一致性。当出现分区(P故障)的时候，并非是完全不可用的，它提供了在大多数节点连通的情况下的可用性保证。</li>
<li>两阶段提交协议：强一致性 + 糟糕的可用性。两阶段提交协议中任意一节点与协调节点之间发生了分区，则服务完全终止。</li>
<li>Git。优先保证可用性，一般就是提交在本地。远程合并时，有一个专门的合并算法处理一致性问题，遇到无法处理的冲突（小部分情况下），把选择权交给了用户。</li>
</ol>
<h3 id="游戏中的数据一致性"><a href="#游戏中的数据一致性" class="headerlink" title="游戏中的数据一致性"></a>游戏中的数据一致性</h3><p>游戏是一种逻辑极其复杂，数据结构繁杂的系统，需要处理的问题千差万别；不同的游戏类型，其要求也是不同的，不能简单的套用理论上的CAP定理，去过分强调系统的一致性或者可用性。对于游戏中产生的数据，我们可以分为以下几大类：</p>
<ul>
<li>玩家的存档数据。这部分数据可以说是游戏中最重要的数据了，通常我们的考虑是强一致性。</li>
<li>全局重要数据，如工会数据、SLG大地图城池数据等。这也要求强一致性。</li>
<li>旁路数据，如好友列表数据。因为好友信息，如名字、等级、头像等，这些数据的更新有一定的延迟容忍度，可以做成弱一致性，保证最终的数据一致性即可。</li>
</ul>
<h3 id="多方修改"><a href="#多方修改" class="headerlink" title="多方修改"></a>多方修改</h3><p>对于玩家存档数据和全局重要数据，很可能有多方同时修改，如何保证强一致性呢？</p>
<p>方法一，某一玩家的数据读取或者修改统一指定到特定逻辑进程来操作。例如A在进程1，玩家B在进程2，如果A想读取或者修改B的数据，将修改请求统一发放到进程2处理，完成后返回进程1。这样处理有个问题，如果某一个进程挂掉，该进程上的玩家都无法得到服务。好处是简单，没有同时读写的问题。</p>
<p>方法二，所有进程对等，玩家操作不一定落在某一固定进程处理，所有进程的需要做的就是取玩家的数据，修改，然后存入数据层。一般在逻辑层做乐观锁机制，保证多进程同时修改一个玩家数据。简单的可以设置一个版本号，更新的时候去检查版本号，不一致则失败，需要做回滚。这种情况一般要求业务需求可以重试，如很多游戏里的偷菜等玩法就采用这种方式。复杂的地方在回滚怎么做。这种方式的并发性能比较高。</p>
<p>方法三，对于同时操作概率比较大的数据，如公会数据、大地图数据等，可以添加独占锁，严格保证一致性。这种方式性能会比较低，并发不高。可以做的改进是用读写锁。</p>
<p>方法二和方法三的情况，无论是操作玩家数据或者全局数据，本质上都是用的是锁（乐观锁和悲观锁），所以要注意尽量减小锁的粒度，做垂直划分：将关联度低的数据拆分成多块，分别加锁控制，减小锁冲突。</p>
<h3 id="数据软拷贝"><a href="#数据软拷贝" class="headerlink" title="数据软拷贝"></a>数据软拷贝</h3><p>所谓数据软拷贝，意思是对核心数据的冗余备份，用以提高性能和逻辑复杂度。</p>
<p>举个例子，上文提到的好友列表中的某一个玩家的数据，如名字、等级等，在该玩家存档数据中一定是准确的，这个由强一致性保证。这是不是意味着拥有该玩家为好友的所有其他玩家，其好友列表中一定要实时更新？答案是否。我们可以为所有玩家维护一份冗余的简要数据放到全局服务中；各逻辑服如果有玩家存档数据更新，只需要同时通知简要数据修改，但可能更新失败，这可以容忍。下次找个时机，如玩家登录时再使用存档数据同步一下简要数据。拉取玩家好友列表，直接取简要数据里的数据即可。</p>
<p>另一个例子，是公会相关数据。全局的公会数据需要维护公会的基本信息，以及成员的信息；同时玩家存档数据需要记录自己属于哪个公会。这里我们就需要区分数据准确性，通常认为公会数据是准确的，玩家存档里的是软拷贝。如果有一个玩家加入公会，永远以公会数据做基本判断，加入成功后再同步玩家存档数据。如果同步出错怎么办？其实问题不大，只是其他玩家看到的软拷贝是脏数据。找个时机，如玩家登录时从公会服拉取同步一下，或者公会服控制定时 push 到游戏逻辑服。</p>
<h3 id="事务数据"><a href="#事务数据" class="headerlink" title="事务数据"></a>事务数据</h3><p>分布式事务经常出现在互联网产品中，如电商后台的订单系统，就会涉及一个操作修改多份数据：下单会修改商品库存、订单、支付信息等，要求事务性。</p>
<p>游戏中类似的系统有建角，双向好友，拍卖行，特定玩法如俘虏与被俘虏等。</p>
<p>一种做法是用状态机，将事务的各个操作拆分N个原子操作，然后每一步都有其对应的回滚逻辑，如果中间失败，依次回滚。</p>
<p>另一种做法是互联网产品中经常使用的方式，利用消息队列的方式保存消息，利用消息队列的重传特性，如果中间失败，则会重传继续重试。这里要注意，对于操作要做到幂等性，即使重试多次调用接口不会多次运行逻辑。</p>
<p>不使用两阶段提交是因为，有可能多个原子步骤之间有依赖关系；并且两阶段提交整个过程是阻塞的，第一阶段prepare 会锁住资源，这是不可接受的。</p>
<p>参考资料</p>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP 定理的含义</a></p>
<p><a href="http://gad.qq.com/article/detail/15801" target="_blank" rel="noopener">有一千个程序员，就有一千种对CAP的解读</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/深度探索C-对象模型总结1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/深度探索C-对象模型总结1/" itemprop="url">深度探索C++对象模型总结1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T20:05:21+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/18/深度探索C-对象模型总结1/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/18/深度探索C-对象模型总结1/" class="cy_cmt_count" data-xid="2018/11/18/深度探索C-对象模型总结1/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++ class 相对于 C struct，支持了更多特性，如添加了类的方法，构造析构函数，继承等。一般来说 class 和 struct  效率大部分情况下是相同的，引起效率差异的地方主要在两点：</p>
<ul>
<li><p>virutal function。class需要维护一个虚函数表，并通过虚指针指向它，中间多了一道访问转换。</p>
</li>
<li><p>virutal base class。虚基类，主要是为了解决菱形继承关系，防止基类对象在子类对象布局中存在多份，因而引入了指针，这中间也多了一道访问转换。</p>
</li>
</ul>
<h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h5 id="非静态成员变量"><a href="#非静态成员变量" class="headerlink" title="非静态成员变量"></a>非静态成员变量</h5><p>非静态成员变量存放在每个object上</p>
<h5 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h5><p>静态成员变量存放在静态数据区，需要在类外单独定义。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;	<span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">1</span>;		<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><p>成员函数，包括非静态和静态成员函数，存放于代码区，也是独立于每个object之外。</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>所有的虚函数被放在类的虚函数表里，虚函数表由编译器生成；每个object有个指向虚函数表的指针，在运行时由构造函数、析构函数、赋值操作符来设置或者重置。</p>
<h5 id="TypeInfo"><a href="#TypeInfo" class="headerlink" title="TypeInfo"></a>TypeInfo</h5><p>类的类型信息，用来在运行时支持类型识别 (RTTI)，也存放在虚函数表里，通常放在虚表的第一个slot。</p>
<h5 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h5><p>未涉及继承的class对象布局，总体的示意图就类似下面这样</p>
<p><img src="/images/image-20181118203839822.png" alt="image-20181118203839822"></p>
<h2 id="C-多态语义"><a href="#C-多态语义" class="headerlink" title="C++多态语义"></a>C++多态语义</h2><p>c++多态从语法上说，需要的形式是基类指针或者引用指向子类对象，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base *bp = &amp;d;</span><br><span class="line">bp-&gt;DoSomething();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Base &amp;bi = d;</span><br><span class="line">bi.DoSomething();</span><br></pre></td></tr></table></figure>
<p>如果直接将子类对象直接赋值给基类对象，则子类对象会被截断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base b;</span><br><span class="line">Derived d;</span><br><span class="line">b = d;	<span class="comment">//截断</span></span><br><span class="line">b.DoSomething(); <span class="comment">//调用的是基类的方法</span></span><br></pre></td></tr></table></figure>
<p>因此，如果有一个基类的指针<code>*bp</code> 或者引用 <code>bi</code>，我们必然不能确定该指针或引用指向的是什么，可能是基类的对象，也可能是子类的对象，因此其调用的方法必须在运行时确定，这也是多态的具体表现。</p>
<p>但是也要注意，并不是任意一个指针或者引用就支持指针，比如下面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no polymorphism</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="comment">// no language supported polymorphism</span></span><br><span class="line"><span class="keyword">void</span> *pvi;</span><br><span class="line"><span class="comment">// ok: class x serves as a base class</span></span><br><span class="line">x *px;</span><br></pre></td></tr></table></figure>
<p>以下是多态语法形式的内存布局：</p>
<p><img src="/images/image-20181118212121033.png" alt="image-20181118212121033"></p>
<p>更复杂的形式：</p>
<p><img src="/images/image-20181118212454317.png" alt="image-20181118212454317"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/深度探索C-对象模型总结2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/深度探索C-对象模型总结2/" itemprop="url">深度探索C++对象模型总结2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T20:11:51+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/16/深度探索C-对象模型总结2/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/16/深度探索C-对象模型总结2/" class="cy_cmt_count" data-xid="2018/11/16/深度探索C-对象模型总结2/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offset of z: %p\n"</span>, &amp;A::z);       <span class="comment">//int A::*</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a: %p, &amp;a.z: %p\n"</span>, &amp;a, &amp;a.z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offset of z: 0x8</span><br><span class="line">&amp;a: 0x7ffeeea7fa20, &amp;a.z: 0x7ffeeea7fa28</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/Go研究之Interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/Go研究之Interface/" itemprop="url">Go研究之Interface</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T20:53:03+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/15/Go研究之Interface/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/15/Go研究之Interface/" class="cy_cmt_count" data-xid="2018/11/15/Go研究之Interface/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="空接口interface"><a href="#空接口interface" class="headerlink" title="空接口interface{}"></a>空接口interface{}</h2><h5 id="interface-赋值"><a href="#interface-赋值" class="headerlink" title="interface{} 赋值"></a>interface{} 赋值</h5><p><code>interface{}</code> 有点类似于 <code>C/C++</code> 里的 <code>void*</code>，<code>interface{}</code> ，在 Golang 中可以存储任何数据类型：int、string、struct、function、nil、map等等所有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span>     <span class="comment">//字面1为int类型</span></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>由于Go中所有的变量有类型信息，因此存储到 <code>interface{}</code> 里也会带上类型信息，这样才可以在运行时支持反射等特性（这也是不同于void*的地方）。而且<code>interface{}</code> 还可以通过类型assert反转换到具体类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span></span><br><span class="line">b := a.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>空接口<code>interface{}</code> 底层是通过<code>eface</code>结构来实现的，意思是<code>empty interface</code>。<code>eface</code> 本质上类似一个 <code>pair&lt;type, data&gt;</code> ，其中<code>type</code> 存储了变量的实际类型，而<code>data</code> 指向变量的值。具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span> <span class="comment">// type size 描述类型的大小</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">    hash       <span class="keyword">uint32</span>  <span class="comment">// hash of type; avoids computation in hash tables</span></span><br><span class="line">    tflag      tflag   <span class="comment">// extra type information flags</span></span><br><span class="line">    align      <span class="keyword">uint8</span>   <span class="comment">// 变量对齐</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span>   <span class="comment">// 结构体对齐</span></span><br><span class="line">    kind       <span class="keyword">uint8</span>   <span class="comment">// 和反射里的kind一致，数据的大类</span></span><br><span class="line">    alg        *typeAlg  <span class="comment">//算法函数指针，存储了hash/equal/print/copy四个函数操作</span></span><br><span class="line">    gcdata    *<span class="keyword">byte</span>    <span class="comment">// garbage collection data</span></span><br><span class="line">    str       nameOff  <span class="comment">// string form</span></span><br><span class="line">    ptrToThis typeOff  <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go1.7 源码中将变量赋值给 <code>interface{}</code>是通过<code>convT2E</code> 实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E</span><span class="params">(t *_type, elem unsafe.Pointer, x unsafe.Pointer)</span> <span class="params">(e eface)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;t)), funcPC(convT2E))</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(elem, t.size)</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> isDirectIface(t) &#123;</span><br><span class="line">        throw(<span class="string">"direct convT2E"</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        x = newobject(t)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> We allocate a zeroed object only to overwrite it with</span></span><br><span class="line">        <span class="comment">// actual data. Figure out how to avoid zeroing. Also below in convT2I.</span></span><br><span class="line">    &#125;   </span><br><span class="line">    typedmemmove(t, x, elem)</span><br><span class="line">    e._type = t </span><br><span class="line">    e.data = x </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在运行时，通过 <code>typedmemmove</code> 进行了内存拷贝，<code>data</code> 不是简单的指向原数据区。而反射里修改数据时，如果不是指针类型，修改会失败，应该也是基于这个原因：修改的只是拷贝的数据。</p>
<p>我们可以用以下实验试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u := User&#123;1, &quot;Tom&quot;&#125;</span><br><span class="line">    var i interface&#123;&#125; = u</span><br><span class="line">    u.id = 2</span><br><span class="line">    u.name = &quot;Jack&quot;</span><br><span class="line">    fmt.Printf(&quot;u: %#v\n&quot;, u);</span><br><span class="line">    fmt.Printf(&quot;i: %#v\n&quot;, i);</span><br><span class="line">    </span><br><span class="line">    u2 := &amp;User&#123;2, &quot;Tom2&quot;&#125;</span><br><span class="line">    var i2 interface&#123;&#125; = u2</span><br><span class="line">    u2.id = 2</span><br><span class="line">    u2.name = &quot;Jack2&quot;</span><br><span class="line">    fmt.Printf(&quot;u2: %#v\n&quot;, u2);</span><br><span class="line">    fmt.Printf(&quot;i2: %#v\n&quot;, i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u: main.User&#123;id:2, name:&quot;Jack&quot;&#125;</span><br><span class="line">i: main.User&#123;id:1, name:&quot;Tom&quot;&#125;</span><br><span class="line">u2: &amp;main.User&#123;id:2, name:&quot;Jack2&quot;&#125;</span><br><span class="line">i2: &amp;main.User&#123;id:2, name:&quot;Jack2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>证明了代码里的拷贝实现。</p>
<h5 id="interface-与-nil"><a href="#interface-与-nil" class="headerlink" title="interface{} 与 nil"></a>interface{} 与 nil</h5><p>当将 nil 赋值给 interface{} 变量时，<code>type</code> 和 <code>data</code> 域都将被赋值为 <code>nil</code>, 因此其本质上是一个<code>nil</code></p>
<p>而如果是一个其他类型的 nil 值，被赋值给 <code>interface{}</code>，则其 <code>type</code>是有具体类型的，只不过<code>data</code> 是nil，因而组合而成的 <code>eface</code>结构就不是一个<code>nil</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">  </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 interface&#123;&#125; = nil   // type 和 data 都是 nil</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, i1 == nil);</span><br><span class="line"></span><br><span class="line">    var u2 *User</span><br><span class="line">    var i2 interface&#123;&#125; = u2   // type 是 *User，data是 nil</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, i2 == nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不仅是空接口<code>interface{}</code> 是这样，其他有方法的<code>interface</code> 如果被赋值为一个具体类型的<code>nil</code> 值，本质上是不等于<code>nil</code>，而只有被直接赋值为<code>nil</code>，才是真正上的<code>nil</code>。可以认为直接赋值字面上的<code>nil</code> 是类型<code>type</code>和<code>data</code> 都为<code>nil</code> 的<code>nil</code>。</p>
<h2 id="非空-interface"><a href="#非空-interface" class="headerlink" title="非空 interface"></a>非空 interface</h2><h5 id="非空interface赋值"><a href="#非空interface赋值" class="headerlink" title="非空interface赋值"></a>非空interface赋值</h5><p>非空 interface 一般用来实现类似C++的运行时的多态特性。将一个<code>struct</code> 变量赋值给非空interface时编译器会先做一次校验：看该<code>struct</code>类型是否实现了接口所需的所有方法，如果没有，则会报错。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b I = a</span><br></pre></td></tr></table></figure>
<p>编译器会给出提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use a (type int) as type I in assignment:</span><br><span class="line">    int does not implement I (missing String method)</span><br></pre></td></tr></table></figure>
<p>运行时赋值底层借助接口 <code>iface</code> 来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// layout of Itab known to compilers</span></span><br><span class="line"><span class="comment">// allocated in non-garbage-collected memory</span></span><br><span class="line"><span class="comment">// Needs to be in sync with</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    link   *itab</span><br><span class="line">    bad    <span class="keyword">int32</span></span><br><span class="line">    unused <span class="keyword">int32</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>itab</code> 结构包含了两个类型：1)该 <code>interface</code>自己的类型<code>*interfacetype</code>； 2) 其<code>data</code>所指向的具体接口实现的实际类型<code>*_type</code>。<code>interfacetype</code> 是对<code>_type</code>的封装，加上了一些<code>interface</code>才有的数据，专门来表示<code>interface</code>的具体类型。我们可以看到其<code>mhdr</code>成员表示该<code>interface</code>的方法集，但是注意这里只是函数原型<code>metadata</code>，不是具体的函数定义，具体的函数定义是由实现接口的<code>struct</code>来定义的。</p>
<p>相比于 <code>empty interface</code>，<code>non-empty interface</code> 要包含实现该 <code>interface</code>的<code>method</code> 具体定义，定义会被存放在 <code>itab.fun</code> 变量里。虽然 <code>fun</code> 数组只有一个元素，但实际赋值的时候会在内存上依次连续的存储各函数指针。</p>
<p>一个法国的bloger <a href="https://github.com/teh-cmc" target="_blank" rel="noopener">teh-cmc</a> 的 <a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals</a> 里通过汇编代码，详细说明了如何在运行时一个个填充<code>itab</code>结构的各个成员的，有兴趣的同学可以自行查看。</p>
<p>当<code>itab</code>结构被填充好了之后，运行时就可以通过调用<code>convT2I</code> 来将变量赋值给非空 <code>interface</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(elem, t.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isDirectIface(t) &#123;</span><br><span class="line">		<span class="comment">// This case is implemented directly by the compiler.</span></span><br><span class="line">		throw(<span class="string">"direct convT2I"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	x := newobject(t)</span><br><span class="line">	typedmemmove(t, x, elem)</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>x := newobject(t)</code> 会在堆上分配一个 t 类型的对象。由此可见，不管赋值给非空<code>interface</code>的变量存放在哪里，赋值操作都会在堆上重新生成一个对象，然后将对象的类型和指针存储在非空<code>interface</code>里，必要时可能会引发变量逃逸。因此该转换是比较消耗性能的，看下一个<code>benchmark</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Addifier <span class="keyword">interface</span>&#123; Add(a, b <span class="keyword">int32</span>) <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span>&#123; id <span class="keyword">int32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirect</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        adder.Add(<span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkInterface</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    adder := Adder&#123;id: <span class="number">6754</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Addifier(adder).Add(<span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用和通过<code>interface</code>来调用的差别很大，测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkDirect-4      	2000000000	         1.77 ns/op</span><br><span class="line">BenchmarkInterface-4   	100000000	        22.5 ns/op</span><br></pre></td></tr></table></figure>
<h5 id="非空interface动态dispatch"><a href="#非空interface动态dispatch" class="headerlink" title="非空interface动态dispatch"></a>非空interface动态dispatch</h5><p>动态dispatch实际上就类似于C++里的多态实现，C++通过虚函数表存储了各个具体实现类的函数指针，这是编译时完成的。而运行时通过构造函数来生成指向虚函数表的虚表指针，调用的时候通过指针来查找具体应该调用虚函数表里的哪个函数。</p>
<p>而Go的实现方式也有些许类似，上文提到的<code>itab.fun</code> 结构就类似于<code>虚表</code>概念，所不同的是，虚表是在运行时通过<code>go</code>的<code>runtime</code>来赋值的。一旦虚表被填充好，函数调用就简单的在虚表中查找了，主要的开销应该还是在<code>interface</code> 赋值的时候。</p>
<p>参考资料</p>
<p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html" target="_blank" rel="noopener">深入解析Go</a></p>
<p><a href="https://juejin.im/post/5a6873fd518825734501b3c5" target="_blank" rel="noopener">Golang interface接口深入理解</a></p>
<p><a href="https://ninokop.github.io/2017/10/30/Go-%E5%8F%8D%E5%B0%84%E4%B8%8Einterface%E6%8B%BE%E9%81%97/" target="_blank" rel="noopener">Go 反射与interface拾遗</a></p>
<p><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">go-internals</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/随机数生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/随机数生成/" itemprop="url">随机数生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T17:24:55+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/12/随机数生成/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/11/12/随机数生成/" class="cy_cmt_count" data-xid="2018/11/12/随机数生成/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/Go泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="philipyao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHILIP x BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/Go泛型/" itemprop="url">Go泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-17T16:06:45+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/10/17/Go泛型/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::http://yoursite.com/2018/10/17/Go泛型/" class="cy_cmt_count" data-xid="2018/10/17/Go泛型/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Go 语言本身不支持泛型 generics。我们这里主要看下怎么处理泛型的需求。</p>
<h2 id="泛型数据"><a href="#泛型数据" class="headerlink" title="泛型数据"></a>泛型数据</h2><p>如果要存储泛型数据，Go 提供了空接口 interface{}。可以将任意的数据结构存储到 interface{} 中，然后使用的时候需要做一下 cast 转换。</p>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>这种使用比较常用，意思是针对不同的数据类型，需要运行同样的一套函数化的流程或者算法。</p>
<p>目前 Go 并不支持这种传统意义上的泛型编程。<code>Jon Bodner</code> 在他的 <a href="https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5" target="_blank" rel="noopener">Closures are the Generics for Go</a> 这篇文章中提供了一种间接实现泛型函数需求的做法，就是利用回调形式的闭包。</p>
<p>简单来说，就是将需要泛型抽象的一套流程和算法封装成一个公共接口，并且提供一个回调，可以在回调时候利用闭包的特性来读取或者修改变量 T，而 T 在通常的泛型编程中是需要传给泛型函数的。</p>
<p>下面是一个C++ 中的泛型函数的使用，compare 就是一套函数化的流程或者算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs &lt; rhs) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rhs &lt; lhs) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 中如果实现类似的效果呢？方法就是回调闭包函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(fnCmp <span class="keyword">func</span>()</span> <span class="title">int</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">    ret := fnCmp()</span><br><span class="line">    <span class="keyword">return</span> ret &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">2</span>;</span><br><span class="line">    result := compare(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) &#123;<span class="keyword">return</span> <span class="number">-1</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过闭包的特性，可以不需要传之前需要的泛型参数 T，就可以对变量进行读取和修改。</p>
<p>我们只需要将相同的流程抽象成一个公共接口，这里是<code>compare</code>，然后将不同的部分通过回调闭包的形式作为参数让公共接口调用即可，这里是 <code>fnCmp func() int</code> 参数。</p>
<p>另一个比较恰当的例子是数据库的批量分页拉取。针对每个业务的数据库表，都可能会需要分页拉取 table 里的所有数据，就有必要将分页拉取的操作封装成一个公共接口，拉取后通过闭包参数来让调用方自定义后续操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> records []*DBTerritoryRespawn</span><br><span class="line">batchGet(dbtbl, fields, wheres, <span class="function"><span class="keyword">func</span><span class="params">(rows [][]hqdb.TbField)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">        record := do_something_with(row)</span><br><span class="line">        records = <span class="built_in">append</span>(records, record)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每次拉取一页（batchGet 内部调用一次闭包函数），都可以修改最终的结果 <code>records</code>。</p>
<p>利用闭包，我们可以方便的抽象出一个通用的排序接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sorter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    fnSwap <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">fnLess</span> <span class="title">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(s sorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> s.<span class="built_in">len</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.fnSwap(i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.fnLess(i, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//slice排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>, fnSwap <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span>, <span class="title">fnLess</span> <span class="title">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">    sort.Sort(sorter&#123;<span class="built_in">len</span>, fnSwap, fnLess&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    Sort(<span class="built_in">len</span>(data), <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        data[i], data[j] = data[j], data[i]</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data[i] &lt; data[j]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过这里用了2个闭包函数 fnSwap 和 fnLess。</p>
<p>以上通过 closure 闭包提供的解决方式实质上使用了软件理论中的<code>side-effects</code>来实现的，意思是函数调用会影响调用方的数据。现代编程理论认为这是一种不好的方式，和其相对的是函数化编程。</p>
<p>这里仅仅是提供一个泛型的一种 <code>work around</code>，所以还是期待未来 Go 能支持真正意义上的泛型。</p>
<p>参考资料</p>
<p><a href="https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5" target="_blank" rel="noopener">Closures are the Generics for Go</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">philipyao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/philipyao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sjtutrume@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">philipyao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




<div style="text-align:center;width:100%;height:50">
   备案号：沪ICP备17048801号
<div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytDLaiT8"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
